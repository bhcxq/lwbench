//
// File: Lifting_wing_HIL_model_dll.cpp
//
// Code generated for Simulink model 'Lifting_wing_HIL_model_dll'.
//
// Model version                  : 10.19
// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024
// C/C++ source code generated on : Wed Dec 24 11:26:19 2025
//
// Target selection: ert.tlc
// Embedded hardware selection: Intel->x86-64 (Windows64)
// Code generation objectives: Unspecified
// Validation result: Not run
//
#include "Lifting_wing_HIL_model_dll.h"
#include "rtwtypes.h"
#include <cmath>
#include <cstring>
#include "cmath"
#include <cfloat>
#include "limits"
#ifndef ATMOS_TYPEDEF

typedef enum { COESA = 1, MILHDBK310, MILSTD210C } AtmosTypeIdx;

typedef enum { PROFILE = 1, ENVELOPE } ModelIdx;

typedef enum { HIGHTEMP = 1, LOWTEMP, HIGHDENSITY,
  LOWDENSITY, HIGHPRESSURE, LOWPRESSURE } VarIdx;

typedef enum { PP1 = 1, PP10 } PPercentIdx;

typedef enum { K5 = 1, K10, K20, K30, K40 } PAltIdx;

typedef enum { EXTREME = 1, P1, P5, P10, P20 } EPercentIdx;

#define ATMOS_TYPEDEF
#endif                                 // ATMOS_TYPEDEF

#ifndef ATMOS_DEFINE
#define PRESSURE0                      101325.0                  //  N/m^2                  
#define TEMPERATURE0                   288.15                    //  K                      
#define GRAV_CONST                     9.80665                   //  m/s^2                  
#define MOL_WT                         28.9644                   //  kg/kgmol (air)         
#define R_HAT                          8314.32                   //  J/kgmol.K (gas const.) 
#define GAMMA                          1.4                       //  (specific heat ratio) 
#define GMR                            ( GRAV_CONST * MOL_WT / R_HAT )
#define ATMOS_DEFINE
#endif                                 // ATMOS_DEFINE

#ifndef COESA76_DEFINE_DATA

// 1976 COESA atmosphere model
#define NUM1976PTS                     8

static real_T altitude76[NUM1976PTS] = {// in meters (m)
  0.0, 11000.0, 20000.0, 32000.0, 47000.0, 51000.0, 71000.0, 84852.0 };

static real_T tempGradient76[NUM1976PTS] = {// in K/m
  (-0.0065), 0.0, 0.0010, 0.0028, 0.0, -0.0028, -0.0020, -0.0020 };

#define COESA76_DEFINE_DATA
#endif                                 // COESA76_DEFINE_DATA

// Block parameters (default storage)
MulticopterModelClass::P_Lifting_wing_HIL_model_dll_T MulticopterModelClass::
  Lifting_wing_HIL_model_dll_P{
  // Variable: LW_ANGLE
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S172>/kappa'
  //    '<S173>/Aerodynamics and torque'
  //    '<S173>/b2l'
  //    '<S173>/b2l1'

  34.0,

  // Variable: ModelFailWind_ConstWindX
  //  Referenced by: '<S180>/ModelFailWind_ConstWindX'

  0.0,

  // Variable: ModelFailWind_ConstWindY
  //  Referenced by: '<S180>/ModelFailWind_ConstWindY'

  0.0,

  // Variable: ModelFailWind_ConstWindZ
  //  Referenced by: '<S180>/ModelFailWind_ConstWindZ'

  0.0,

  // Variable: ModelFailWind_GustStartTime
  //  Referenced by: '<S215>/Gust start time'

  15.0,

  // Variable: ModelFailWind_GustWindAmplitude
  //  Referenced by: '<S215>/Gust magnitude//2.0'

  { -0.0, -5.0, 0.0 },

  // Variable: ModelInit_AngEuler
  //  Referenced by:
  //    '<S173>/MATLAB Function'
  //    '<S297>/Initial Euler Angles'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelInit_PosE
  //  Referenced by: '<S295>/xe,ye,ze'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelInit_Rads
  //  Referenced by:
  //    '<S277>/Init_Rads'
  //    '<S278>/Init_Rads'
  //    '<S279>/Init_Rads'
  //    '<S280>/Init_Rads'

  0.0,

  // Variable: ModelInit_RateB
  //  Referenced by: '<S295>/p,q,r '

  { 0.0, 0.0, 0.0 },

  // Variable: ModelInit_VelB
  //  Referenced by: '<S295>/ub,vb,wb'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelInit_servoRads
  //  Referenced by:
  //    '<S282>/Init_Rads'
  //    '<S283>/Init_Rads'

  0.0,

  // Variable: ModelParam_DeltaRatemax
  //  Referenced by:
  //    '<S284>/Constant'
  //    '<S285>/Constant'

  8.7266,

  // Variable: ModelParam_GPSEphFinal
  //  Referenced by: '<S91>/ModelParam.GPSEphFinal'

  0.3,

  // Variable: ModelParam_GPSEpvFinal
  //  Referenced by: '<S91>/ModelParam.GPSEpvFinal'

  0.4,

  // Variable: ModelParam_GPSFix3DFix
  //  Referenced by: '<S91>/ModelParam_GPSFix3DFix'

  3.0,

  // Variable: ModelParam_GPSLatLong
  //  Referenced by:
  //    '<S18>/ref_position'
  //    '<S125>/ref_position'
  //    '<S177>/ref_position'

  { 40.1540302, 116.2593683 },

  // Variable: ModelParam_GPSSatsVisible
  //  Referenced by: '<S91>/ModelParam.GPSSatsVisible'

  10.0,

  // Variable: ModelParam_LBCY0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.0,

  // Variable: ModelParam_LBCYB
  //  Referenced by: '<S170>/aerodynamic coefficients'

  -0.224,

  // Variable: ModelParam_LBCl0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.0,

  // Variable: ModelParam_LBClB
  //  Referenced by: '<S170>/aerodynamic coefficients'

  -0.05,

  // Variable: ModelParam_LBCl_d
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.1,

  // Variable: ModelParam_LBClp
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S173>/Aerodynamics and torque'

  -0.4,

  // Variable: ModelParam_LBCm_d
  //  Referenced by: '<S170>/aerodynamic coefficients'

  -0.2,

  // Variable: ModelParam_LBCmq
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S173>/Aerodynamics and torque'

  -1.0,

  // Variable: ModelParam_LBCn0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.0,

  // Variable: ModelParam_LBCnB
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.03,

  // Variable: ModelParam_LBCn_d
  //  Referenced by: '<S170>/aerodynamic coefficients'

  -0.0,

  // Variable: ModelParam_LBCnr
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S173>/Aerodynamics and torque'

  -0.01,

  // Variable: ModelParam_LBRho
  //  Referenced by:
  //    '<S173>/Aerodynamics and torque'
  //    '<S181>/airDensity'

  1.22,

  // Variable: ModelParam_LBS
  //  Referenced by: '<S173>/Aerodynamics and torque'

  0.16,

  // Variable: ModelParam_LBb
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S173>/Aerodynamics and torque'

  0.9,

  // Variable: ModelParam_LBc
  //  Referenced by:
  //    '<S170>/aerodynamic coefficients'
  //    '<S173>/Aerodynamics and torque'

  0.2,

  // Variable: ModelParam_efficiency
  //  Referenced by:
  //    '<S174>/throttle2rads'
  //    '<S174>/throttle2rads1'
  //    '<S174>/throttle2rads2'
  //    '<S174>/throttle2rads3'

  1.0,

  // Variable: ModelParam_envAltitude
  //  Referenced by:
  //    '<S14>/ModelParam_envAltitude'
  //    '<S91>/ModelParam_envAltitude'
  //    '<S172>/envAltitude'

  -41.5260009765625,

  // Variable: ModelParam_lDeltamax
  //  Referenced by: '<S287>/Constant'

  0.3490658503988659,

  // Variable: ModelParam_lDeltamin
  //  Referenced by: '<S287>/Constant1'

  -0.3490658503988659,

  // Variable: ModelParam_motorJm
  //  Referenced by: '<S173>/Propeller Model'

  8.8493E-6,

  // Variable: ModelParam_motorT
  //  Referenced by:
  //    '<S277>/motorT'
  //    '<S278>/motorT'
  //    '<S279>/motorT'
  //    '<S280>/motorT'

  0.002,

  // Variable: ModelParam_motorUp1
  //  Referenced by: '<S174>/throttle2rads'

  -1.035,

  // Variable: ModelParam_motorUp2
  //  Referenced by: '<S174>/throttle2rads'

  67.0,

  // Variable: ModelParam_motorUp3
  //  Referenced by: '<S174>/throttle2rads'

  -12.22,

  // Variable: ModelParam_motorp1
  //  Referenced by:
  //    '<S174>/throttle2rads1'
  //    '<S174>/throttle2rads2'
  //    '<S174>/throttle2rads3'

  -387.3,

  // Variable: ModelParam_motorp2
  //  Referenced by:
  //    '<S174>/throttle2rads1'
  //    '<S174>/throttle2rads2'
  //    '<S174>/throttle2rads3'

  1269.0,

  // Variable: ModelParam_motorp3
  //  Referenced by:
  //    '<S174>/throttle2rads1'
  //    '<S174>/throttle2rads2'
  //    '<S174>/throttle2rads3'

  -32.5,

  // Variable: ModelParam_noiseAccelBa
  //  Referenced by: '<S89>/Random Number1'

  { 0.0001, 0.0001, 0.0001 },

  // Variable: ModelParam_noiseAccelBaSeed
  //  Referenced by: '<S89>/Random Number1'

  { 4455.0, 5566.0, 6677.0 },

  // Variable: ModelParam_noiseAccelNa
  //  Referenced by: '<S89>/Random Number'

  { 0.05, 0.05, 0.1 },

  // Variable: ModelParam_noiseAccelNaSeed
  //  Referenced by: '<S89>/Random Number'

  { 1122.0, 2233.0, 3344.0 },

  // Variable: ModelParam_noiseBaroNbm
  //  Referenced by: '<S90>/Random Number2'

  0.0001,

  // Variable: ModelParam_noiseBaroNbmSeed
  //  Referenced by: '<S90>/Random Number2'

  2.0202121E+7,

  // Variable: ModelParam_noiseBaroNm
  //  Referenced by: '<S90>/Random Number1'

  0.01,

  // Variable: ModelParam_noiseBaroNmSeed
  //  Referenced by: '<S90>/Random Number1'

  1.919202E+7,

  // Variable: ModelParam_noiseFBa
  //  Referenced by:
  //    '<S272>/Random Number1'
  //    '<S273>/Random Number3'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelParam_noiseFBaSeed
  //  Referenced by:
  //    '<S272>/Random Number1'
  //    '<S273>/Random Number3'

  { 1819.0, 1920.0, 2021.0 },

  // Variable: ModelParam_noiseFNa
  //  Referenced by: '<S272>/Random Number'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelParam_noiseFNaSeed
  //  Referenced by: '<S272>/Random Number'

  { 1516.0, 1617.0, 1718.0 },

  // Variable: ModelParam_noiseGyroNbg
  //  Referenced by: '<S92>/Random Number1'

  { 1.0E-5, 1.0E-5, 1.0E-5 },

  // Variable: ModelParam_noiseGyroNbgSeed
  //  Referenced by: '<S92>/Random Number1'

  { 1.0101111E+7, 1.1111212E+7, 1.2121313E+7 },

  // Variable: ModelParam_noiseGyroNg
  //  Referenced by: '<S92>/Random Number'

  { 0.0005, 0.0005, 0.0005 },

  // Variable: ModelParam_noiseGyroNgSeed
  //  Referenced by: '<S92>/Random Number'

  { 7788.0, 8899.0, 991010.0 },

  // Variable: ModelParam_noiseMNa
  //  Referenced by: '<S273>/Random Number2'

  { 0.0, 0.0, 0.0 },

  // Variable: ModelParam_noiseMNaSeed
  //  Referenced by: '<S273>/Random Number2'

  { 2122.0, 2223.0, 2324.0 },

  // Variable: ModelParam_noiseMagNm
  //  Referenced by:
  //    '<S93>/Random Number'
  //    '<S93>/Random Number1'

  { 5.0E-5, 5.0E-5, 5.0E-5 },

  // Variable: ModelParam_noiseMagNmSeed
  //  Referenced by: '<S93>/Random Number'

  { 1.3131414E+7, 1.4141515E+7, 1.5151616E+7 },

  // Variable: ModelParam_propellerkM0
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkMV
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkMV2
  //  Referenced by: '<S173>/Propeller Model'

  -0.0005944,

  // Variable: ModelParam_propellerkMvarpi
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkMvarpi2
  //  Referenced by: '<S173>/Propeller Model'

  0.0003188,

  // Variable: ModelParam_propellerkMvarpiV
  //  Referenced by: '<S173>/Propeller Model'

  0.0003198,

  // Variable: ModelParam_propellerkT0
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkTV
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkTV2
  //  Referenced by: '<S173>/Propeller Model'

  -0.01619,

  // Variable: ModelParam_propellerkTvarpi
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_propellerkTvarpi2
  //  Referenced by: '<S173>/Propeller Model'

  0.008977,

  // Variable: ModelParam_propellerkTvarpiV
  //  Referenced by: '<S173>/Propeller Model'

  0.007314,

  // Variable: ModelParam_pu_alpha0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.20943951023931953,

  // Variable: ModelParam_pu_breaks
  //  Referenced by: '<S170>/aerodynamic coefficients'

  { -3.1415926535897931, -3.1353031788078312, -3.1290137040258696,
    -3.1227242292439081, -3.1164347544619466, -3.1101452796799851,
    -3.1038558048980236, -3.0975663301160621, -3.0912768553341006,
    -3.0849873805521391, -3.0786979057701775, -3.072408430988216,
    -3.0661189562062545, -3.059829481424293, -3.0535400066423311,
    -3.0472505318603695, -3.040961057078408, -3.0346715822964465,
    -3.028382107514485, -3.0220926327325235, -3.015803157950562,
    -3.0095136831686005, -3.0032242083866389, -2.9969347336046774,
    -2.9906452588227159, -2.9843557840407544, -2.9780663092587925,
    -2.9717768344768309, -2.9654873596948694, -2.9591978849129079,
    -2.9529084101309464, -2.9466189353489849, -2.9403294605670234,
    -2.9340399857850619, -2.9277505110031004, -2.9214610362211388,
    -2.9151715614391773, -2.9088820866572158, -2.9025926118752543,
    -2.8963031370932923, -2.8900136623113308, -2.8837241875293693,
    -2.8774347127474078, -2.8711452379654463, -2.8648557631834848,
    -2.8585662884015233, -2.8522768136195618, -2.8459873388376002,
    -2.8396978640556387, -2.8334083892736772, -2.8271189144917157,
    -2.8208294397097542, -2.8145399649277922, -2.8082504901458307,
    -2.8019610153638692, -2.7956715405819077, -2.7893820657999462,
    -2.7830925910179847, -2.7768031162360232, -2.7705136414540616,
    -2.7642241666721, -2.7579346918901386, -2.7516452171081771,
    -2.7453557423262156, -2.7390662675442541, -2.7327767927622921,
    -2.7264873179803306, -2.7201978431983691, -2.7139083684164076,
    -2.7076188936344461, -2.7013294188524846, -2.6950399440705231,
    -2.6887504692885615, -2.6824609945066, -2.6761715197246385,
    -2.669882044942677, -2.6635925701607155, -2.657303095378754,
    -2.651013620596792, -2.6447241458148305, -2.638434671032869,
    -2.6321451962509075, -2.625855721468946, -2.6195662466869845,
    -2.6132767719050229, -2.6069872971230614, -2.6006978223411,
    -2.5944083475591384, -2.5881188727771769, -2.5818293979952154,
    -2.5755399232132534, -2.5692504484312919, -2.5629609736493304,
    -2.5566714988673689, -2.5503820240854074, -2.5440925493034459,
    -2.5378030745214843, -2.5315135997395228, -2.5252241249575613,
    -2.5189346501756, -2.5126451753936383, -2.5063557006116768,
    -2.5000662258297153, -2.4937767510477533, -2.4874872762657918,
    -2.4811978014838303, -2.4749083267018688, -2.4686188519199073,
    -2.4623293771379458, -2.4560399023559842, -2.4497504275740227,
    -2.4434609527920612, -2.4371714780100997, -2.4308820032281382,
    -2.4245925284461767, -2.4183030536642152, -2.4120135788822532,
    -2.4057241041002917, -2.39943462931833, -2.3931451545363687,
    -2.3868556797544072, -2.3805662049724456, -2.3742767301904841,
    -2.3679872554085226, -2.3616977806265611, -2.3554083058445996,
    -2.3491188310626381, -2.3428293562806766, -2.3365398814987151,
    -2.3302504067167531, -2.3239609319347916, -2.31767145715283,
    -2.3113819823708686, -2.305092507588907, -2.2988030328069455,
    -2.292513558024984, -2.2862240832430225, -2.279934608461061,
    -2.2736451336790995, -2.267355658897138, -2.2610661841151765,
    -2.2547767093332149, -2.248487234551253, -2.2421977597692915,
    -2.23590828498733, -2.2296188102053685, -2.2233293354234069,
    -2.2170398606414454, -2.2107503858594839, -2.2044609110775224,
    -2.1981714362955609, -2.1918819615135994, -2.1855924867316379,
    -2.1793030119496763, -2.1730135371677144, -2.1667240623857529,
    -2.1604345876037914, -2.15414511282183, -2.1478556380398683,
    -2.1415661632579068, -2.1352766884759453, -2.1289872136939838,
    -2.1226977389120223, -2.1164082641300608, -2.1101187893480993,
    -2.1038293145661378, -2.0975398397841762, -2.0912503650022143,
    -2.0849608902202528, -2.0786714154382913, -2.0723819406563297,
    -2.0660924658743682, -2.0598029910924067, -2.0535135163104452,
    -2.0472240415284837, -2.0409345667465222, -2.0346450919645607,
    -2.0283556171825992, -2.0220661424006376, -2.0157766676186761,
    -2.0094871928367142, -2.0031977180547527, -1.9969082432727914,
    -1.9906187684908296, -1.9843292937088681, -1.9780398189269066,
    -1.9717503441449451, -1.9654608693629836, -1.9591713945810221,
    -1.9528819197990606, -1.9465924450170988, -1.9403029702351373,
    -1.9340134954531758, -1.9277240206712143, -1.9214345458892528,
    -1.9151450711072913, -1.9088555963253295, -1.902566121543368,
    -1.8962766467614065, -1.889987171979445, -1.8836976971974835,
    -1.877408222415522, -1.8711187476335602, -1.8648292728515987,
    -1.8585397980696372, -1.8522503232876757, -1.8459608485057142,
    -1.8396713737237527, -1.8333818989417912, -1.8270924241598294,
    -1.8208029493778679, -1.8145134745959064, -1.8082239998139449,
    -1.8019345250319834, -1.7956450502500219, -1.7893555754680601,
    -1.7830661006860986, -1.7767766259041371, -1.7704871511221756,
    -1.7641976763402141, -1.7579082015582526, -1.751618726776291,
    -1.7453292519943293, -1.7390397772123678, -1.7327503024304063,
    -1.7264608276484448, -1.7201713528664833, -1.7138818780845217,
    -1.70759240330256, -1.7013029285205985, -1.695013453738637,
    -1.6887239789566755, -1.682434504174714, -1.6761450293927525,
    -1.6698555546107907, -1.6635660798288292, -1.6572766050468677,
    -1.6509871302649062, -1.6446976554829447, -1.6384081807009832,
    -1.6321187059190216, -1.62582923113706, -1.6195397563550984,
    -1.6132502815731369, -1.6069608067911754, -1.6006713320092139,
    -1.5943818572272523, -1.5880923824452906, -1.5818029076633291,
    -1.5755134328813676, -1.5692239580994061, -1.5629344833174446,
    -1.556645008535483, -1.5503555337535215, -1.5440660589715598,
    -1.5377765841895983, -1.5314871094076368, -1.5251976346256753,
    -1.5189081598437137, -1.5126186850617522, -1.5063292102797905,
    -1.500039735497829, -1.4937502607158675, -1.487460785933906,
    -1.4811713111519444, -1.4748818363699829, -1.4685923615880212,
    -1.4623028868060597, -1.4560134120240982, -1.4497239372421367,
    -1.4434344624601751, -1.4371449876782136, -1.4308555128962521,
    -1.4245660381142904, -1.4182765633323289, -1.4119870885503674,
    -1.4056976137684059, -1.3994081389864443, -1.3931186642044828,
    -1.3868291894225211, -1.3805397146405596, -1.3742502398585981,
    -1.3679607650766366, -1.361671290294675, -1.3553818155127135,
    -1.349092340730752, -1.3428028659487903, -1.3365133911668288,
    -1.3302239163848673, -1.3239344416029057, -1.3176449668209442,
    -1.3113554920389827, -1.305066017257021, -1.2987765424750595,
    -1.292487067693098, -1.2861975929111364, -1.2799081181291749,
    -1.2736186433472134, -1.2673291685652517, -1.2610396937832902,
    -1.2547502190013287, -1.2484607442193671, -1.2421712694374056,
    -1.2358817946554441, -1.2295923198734826, -1.2233028450915209,
    -1.2170133703095594, -1.2107238955275978, -1.2044344207456363,
    -1.1981449459636748, -1.1918554711817133, -1.1855659963997516,
    -1.17927652161779, -1.1729870468358286, -1.166697572053867,
    -1.1604080972719055, -1.154118622489944, -1.1478291477079825,
    -1.1415396729260208, -1.1352501981440593, -1.1289607233620977,
    -1.1226712485801362, -1.1163817737981747, -1.1100922990162132,
    -1.1038028242342515, -1.09751334945229, -1.0912238746703284,
    -1.0849343998883669, -1.0786449251064054, -1.0723554503244439,
    -1.0660659755424822, -1.0597765007605207, -1.0534870259785591,
    -1.0471975511965976, -1.0409080764146361, -1.0346186016326746,
    -1.0283291268507131, -1.0220396520687514, -1.0157501772867898,
    -1.0094607025048283, -1.0031712277228668, -0.99688175294090531,
    -0.99059227815894368, -0.98430280337698217, -0.97801332859502066,
    -0.971723853813059, -0.96543437903109752, -0.959144904249136,
    -0.95285542946717439, -0.94656595468521287, -0.94027647990325136,
    -0.93398700512128974, -0.92769753033932822, -0.92140805555736671,
    -0.91511858077540509, -0.90882910599344358, -0.90253963121148206,
    -0.89625015642952055, -0.88996068164755893, -0.88367120686559741,
    -0.8773817320836359, -0.87109225730167428, -0.86480278251971276,
    -0.85851330773775125, -0.85222383295578963, -0.84593435817382812,
    -0.8396448833918666, -0.833355408609905, -0.82706593382794347,
    -0.820776459045982, -0.81448698426402033, -0.80819750948205882,
    -0.80190803470009731, -0.79561855991813579, -0.78932908513617417,
    -0.78303961035421266, -0.77675013557225114, -0.77046066079028952,
    -0.764171186008328, -0.75788171122636649, -0.75159223644440487,
    -0.74530276166244336, -0.73901328688048185, -0.73272381209852022,
    -0.72643433731655871, -0.7201448625345972, -0.71385538775263557,
    -0.70756591297067406, -0.70127643818871255, -0.694986963406751,
    -0.68869748862478941, -0.6824080138428279, -0.67611853906086639,
    -0.66982906427890476, -0.66353958949694325, -0.65725011471498174,
    -0.65096063993302011, -0.6446711651510586, -0.63838169036909709,
    -0.63209221558713546, -0.625802740805174, -0.61951326602321244,
    -0.61322379124125082, -0.6069343164592893, -0.60064484167732779,
    -0.59435536689536628, -0.58806589211340465, -0.58177641733144314,
    -0.57548694254948163, -0.56919746776752, -0.56290799298555849,
    -0.556618518203597, -0.55032904342163536, -0.54403956863967384,
    -0.53775009385771233, -0.53146061907575071, -0.52517114429378919,
    -0.51888166951182768, -0.51259219472986606, -0.50630271994790454,
    -0.500013245165943, -0.49372377038398146, -0.4874342956020199,
    -0.48114482082005838, -0.47485534603809681, -0.4685658712561353,
    -0.46227639647417373, -0.45598692169221217, -0.44969744691025065,
    -0.44340797212828909, -0.43711849734632752, -0.430829022564366,
    -0.42453954778240444, -0.41825007300044292, -0.41196059821848136,
    -0.40567112343651979, -0.39938164865455827, -0.39309217387259671,
    -0.38680269909063514, -0.38051322430867363, -0.37422374952671206,
    -0.36793427474475054, -0.361644799962789, -0.35535532518082741,
    -0.3490658503988659, -0.34277637561690433, -0.33648690083494276,
    -0.33019742605298125, -0.32390795127101968, -0.31761847648905817,
    -0.3113290017070966, -0.30503952692513503, -0.29875005214317352,
    -0.29246057736121195, -0.28617110257925038, -0.27988162779728887,
    -0.2735921530153273, -0.26730267823336579, -0.26101320345140422,
    -0.25472372866944265, -0.24843425388748111, -0.24214477910551957,
    -0.23585530432355803, -0.22956582954159649, -0.22327635475963492,
    -0.21698687997767338, -0.21069740519571184, -0.2044079304137503,
    -0.19811845563178873, -0.19182898084982719, -0.18553950606786565,
    -0.17925003128590411, -0.17296055650394254, -0.166671081721981,
    -0.16038160694001946, -0.15409213215805792, -0.14780265737609635,
    -0.14151318259413481, -0.13522370781217327, -0.12893423303021173,
    -0.12264475824825018, -0.11635528346628862, -0.11006580868432708,
    -0.10377633390236553, -0.097486859120403987, -0.091197384338442433,
    -0.084907909556480893, -0.078618434774519338, -0.0723289599925578,
    -0.066039485210596244, -0.0597500104286347, -0.053460535646673149,
    -0.047171060864711609, -0.040881586082750054, -0.034592111300788514,
    -0.028302636518826963, -0.022013161736865416, -0.015723686954903868,
    -0.009434212172942321, -0.0031447373909807737, 0.0031447373909807737,
    0.009434212172942321, 0.015723686954903868, 0.022013161736865416,
    0.028302636518826963, 0.034592111300788514, 0.040881586082750054,
    0.047171060864711609, 0.053460535646673149, 0.0597500104286347,
    0.066039485210596244, 0.0723289599925578, 0.078618434774519338,
    0.084907909556480893, 0.091197384338442433, 0.097486859120403987,
    0.10377633390236553, 0.11006580868432708, 0.11635528346628862,
    0.12264475824825018, 0.12893423303021173, 0.13522370781217327,
    0.14151318259413481, 0.14780265737609635, 0.15409213215805792,
    0.16038160694001946, 0.166671081721981, 0.17296055650394254,
    0.17925003128590411, 0.18553950606786565, 0.19182898084982719,
    0.19811845563178873, 0.2044079304137503, 0.21069740519571184,
    0.21698687997767338, 0.22327635475963492, 0.22956582954159649,
    0.23585530432355803, 0.24214477910551957, 0.24843425388748111,
    0.25472372866944265, 0.26101320345140422, 0.26730267823336579,
    0.2735921530153273, 0.27988162779728887, 0.28617110257925038,
    0.29246057736121195, 0.29875005214317352, 0.30503952692513503,
    0.3113290017070966, 0.31761847648905817, 0.32390795127101968,
    0.33019742605298125, 0.33648690083494276, 0.34277637561690433,
    0.3490658503988659, 0.35535532518082741, 0.361644799962789,
    0.36793427474475054, 0.37422374952671206, 0.38051322430867363,
    0.38680269909063514, 0.39309217387259671, 0.39938164865455827,
    0.40567112343651979, 0.41196059821848136, 0.41825007300044292,
    0.42453954778240444, 0.430829022564366, 0.43711849734632752,
    0.44340797212828909, 0.44969744691025065, 0.45598692169221217,
    0.46227639647417373, 0.4685658712561353, 0.47485534603809681,
    0.48114482082005838, 0.4874342956020199, 0.49372377038398146,
    0.500013245165943, 0.50630271994790454, 0.51259219472986606,
    0.51888166951182768, 0.52517114429378919, 0.53146061907575071,
    0.53775009385771233, 0.54403956863967384, 0.55032904342163536,
    0.556618518203597, 0.56290799298555849, 0.56919746776752,
    0.57548694254948163, 0.58177641733144314, 0.58806589211340465,
    0.59435536689536628, 0.60064484167732779, 0.6069343164592893,
    0.61322379124125082, 0.61951326602321244, 0.625802740805174,
    0.63209221558713546, 0.63838169036909709, 0.6446711651510586,
    0.65096063993302011, 0.65725011471498174, 0.66353958949694325,
    0.66982906427890476, 0.67611853906086639, 0.6824080138428279,
    0.68869748862478941, 0.694986963406751, 0.70127643818871255,
    0.70756591297067406, 0.71385538775263557, 0.7201448625345972,
    0.72643433731655871, 0.73272381209852022, 0.73901328688048185,
    0.74530276166244336, 0.75159223644440487, 0.75788171122636649,
    0.764171186008328, 0.77046066079028952, 0.77675013557225114,
    0.78303961035421266, 0.78932908513617417, 0.79561855991813579,
    0.80190803470009731, 0.80819750948205882, 0.81448698426402033,
    0.820776459045982, 0.82706593382794347, 0.833355408609905,
    0.8396448833918666, 0.84593435817382812, 0.85222383295578963,
    0.85851330773775125, 0.86480278251971276, 0.87109225730167428,
    0.8773817320836359, 0.88367120686559741, 0.88996068164755893,
    0.89625015642952055, 0.90253963121148206, 0.90882910599344358,
    0.91511858077540509, 0.92140805555736671, 0.92769753033932822,
    0.93398700512128974, 0.94027647990325136, 0.94656595468521287,
    0.95285542946717439, 0.959144904249136, 0.96543437903109752,
    0.971723853813059, 0.97801332859502066, 0.98430280337698217,
    0.99059227815894368, 0.99688175294090531, 1.0031712277228668,
    1.0094607025048283, 1.0157501772867898, 1.0220396520687514,
    1.0283291268507131, 1.0346186016326746, 1.0409080764146361,
    1.0471975511965976, 1.0534870259785591, 1.0597765007605207,
    1.0660659755424822, 1.0723554503244439, 1.0786449251064054,
    1.0849343998883669, 1.0912238746703284, 1.09751334945229, 1.1038028242342515,
    1.1100922990162132, 1.1163817737981747, 1.1226712485801362,
    1.1289607233620977, 1.1352501981440593, 1.1415396729260208,
    1.1478291477079825, 1.154118622489944, 1.1604080972719055, 1.166697572053867,
    1.1729870468358286, 1.17927652161779, 1.1855659963997516, 1.1918554711817133,
    1.1981449459636748, 1.2044344207456363, 1.2107238955275978,
    1.2170133703095594, 1.2233028450915209, 1.2295923198734826,
    1.2358817946554441, 1.2421712694374056, 1.2484607442193671,
    1.2547502190013287, 1.2610396937832902, 1.2673291685652517,
    1.2736186433472134, 1.2799081181291749, 1.2861975929111364,
    1.292487067693098, 1.2987765424750595, 1.305066017257021, 1.3113554920389827,
    1.3176449668209442, 1.3239344416029057, 1.3302239163848673,
    1.3365133911668288, 1.3428028659487903, 1.349092340730752,
    1.3553818155127135, 1.361671290294675, 1.3679607650766366,
    1.3742502398585981, 1.3805397146405596, 1.3868291894225211,
    1.3931186642044828, 1.3994081389864443, 1.4056976137684059,
    1.4119870885503674, 1.4182765633323289, 1.4245660381142904,
    1.4308555128962521, 1.4371449876782136, 1.4434344624601751,
    1.4497239372421367, 1.4560134120240982, 1.4623028868060597,
    1.4685923615880212, 1.4748818363699829, 1.4811713111519444,
    1.487460785933906, 1.4937502607158675, 1.500039735497829, 1.5063292102797905,
    1.5126186850617522, 1.5189081598437137, 1.5251976346256753,
    1.5314871094076368, 1.5377765841895983, 1.5440660589715598,
    1.5503555337535215, 1.556645008535483, 1.5629344833174446,
    1.5692239580994061, 1.5755134328813676, 1.5818029076633291,
    1.5880923824452906, 1.5943818572272523, 1.6006713320092139,
    1.6069608067911754, 1.6132502815731369, 1.6195397563550984, 1.62582923113706,
    1.6321187059190216, 1.6384081807009832, 1.6446976554829447,
    1.6509871302649062, 1.6572766050468677, 1.6635660798288292,
    1.6698555546107907, 1.6761450293927525, 1.682434504174714,
    1.6887239789566755, 1.695013453738637, 1.7013029285205985, 1.70759240330256,
    1.7138818780845217, 1.7201713528664833, 1.7264608276484448,
    1.7327503024304063, 1.7390397772123678, 1.7453292519943293,
    1.751618726776291, 1.7579082015582526, 1.7641976763402141,
    1.7704871511221756, 1.7767766259041371, 1.7830661006860986,
    1.7893555754680601, 1.7956450502500219, 1.8019345250319834,
    1.8082239998139449, 1.8145134745959064, 1.8208029493778679,
    1.8270924241598294, 1.8333818989417912, 1.8396713737237527,
    1.8459608485057142, 1.8522503232876757, 1.8585397980696372,
    1.8648292728515987, 1.8711187476335602, 1.877408222415522,
    1.8836976971974835, 1.889987171979445, 1.8962766467614065, 1.902566121543368,
    1.9088555963253295, 1.9151450711072913, 1.9214345458892528,
    1.9277240206712143, 1.9340134954531758, 1.9403029702351373,
    1.9465924450170988, 1.9528819197990606, 1.9591713945810221,
    1.9654608693629836, 1.9717503441449451, 1.9780398189269066,
    1.9843292937088681, 1.9906187684908296, 1.9969082432727914,
    2.0031977180547527, 2.0094871928367142, 2.0157766676186761,
    2.0220661424006376, 2.0283556171825992, 2.0346450919645607,
    2.0409345667465222, 2.0472240415284837, 2.0535135163104452,
    2.0598029910924067, 2.0660924658743682, 2.0723819406563297,
    2.0786714154382913, 2.0849608902202528, 2.0912503650022143,
    2.0975398397841762, 2.1038293145661378, 2.1101187893480993,
    2.1164082641300608, 2.1226977389120223, 2.1289872136939838,
    2.1352766884759453, 2.1415661632579068, 2.1478556380398683, 2.15414511282183,
    2.1604345876037914, 2.1667240623857529, 2.1730135371677144,
    2.1793030119496763, 2.1855924867316379, 2.1918819615135994,
    2.1981714362955609, 2.2044609110775224, 2.2107503858594839,
    2.2170398606414454, 2.2233293354234069, 2.2296188102053685, 2.23590828498733,
    2.2421977597692915, 2.248487234551253, 2.2547767093332149,
    2.2610661841151765, 2.267355658897138, 2.2736451336790995, 2.279934608461061,
    2.2862240832430225, 2.292513558024984, 2.2988030328069455, 2.305092507588907,
    2.3113819823708686, 2.31767145715283, 2.3239609319347916, 2.3302504067167531,
    2.3365398814987151, 2.3428293562806766, 2.3491188310626381,
    2.3554083058445996, 2.3616977806265611, 2.3679872554085226,
    2.3742767301904841, 2.3805662049724456, 2.3868556797544072,
    2.3931451545363687, 2.39943462931833, 2.4057241041002917, 2.4120135788822532,
    2.4183030536642152, 2.4245925284461767, 2.4308820032281382,
    2.4371714780100997, 2.4434609527920612, 2.4497504275740227,
    2.4560399023559842, 2.4623293771379458, 2.4686188519199073,
    2.4749083267018688, 2.4811978014838303, 2.4874872762657918,
    2.4937767510477533, 2.5000662258297153, 2.5063557006116768,
    2.5126451753936383, 2.5189346501756, 2.5252241249575613, 2.5315135997395228,
    2.5378030745214843, 2.5440925493034459, 2.5503820240854074,
    2.5566714988673689, 2.5629609736493304, 2.5692504484312919,
    2.5755399232132534, 2.5818293979952154, 2.5881188727771769,
    2.5944083475591384, 2.6006978223411, 2.6069872971230614, 2.6132767719050229,
    2.6195662466869845, 2.625855721468946, 2.6321451962509075, 2.638434671032869,
    2.6447241458148305, 2.651013620596792, 2.657303095378754, 2.6635925701607155,
    2.669882044942677, 2.6761715197246385, 2.6824609945066, 2.6887504692885615,
    2.6950399440705231, 2.7013294188524846, 2.7076188936344461,
    2.7139083684164076, 2.7201978431983691, 2.7264873179803306,
    2.7327767927622921, 2.7390662675442541, 2.7453557423262156,
    2.7516452171081771, 2.7579346918901386, 2.7642241666721, 2.7705136414540616,
    2.7768031162360232, 2.7830925910179847, 2.7893820657999462,
    2.7956715405819077, 2.8019610153638692, 2.8082504901458307,
    2.8145399649277922, 2.8208294397097542, 2.8271189144917157,
    2.8334083892736772, 2.8396978640556387, 2.8459873388376002,
    2.8522768136195618, 2.8585662884015233, 2.8648557631834848,
    2.8711452379654463, 2.8774347127474078, 2.8837241875293693,
    2.8900136623113308, 2.8963031370932923, 2.9025926118752543,
    2.9088820866572158, 2.9151715614391773, 2.9214610362211388,
    2.9277505110031004, 2.9340399857850619, 2.9403294605670234,
    2.9466189353489849, 2.9529084101309464, 2.9591978849129079,
    2.9654873596948694, 2.9717768344768309, 2.9780663092587925,
    2.9843557840407544, 2.9906452588227159, 2.9969347336046774,
    3.0032242083866389, 3.0095136831686005, 3.015803157950562,
    3.0220926327325235, 3.028382107514485, 3.0346715822964465, 3.040961057078408,
    3.0472505318603695, 3.0535400066423311, 3.059829481424293,
    3.0661189562062545, 3.072408430988216, 3.0786979057701775,
    3.0849873805521391, 3.0912768553341006, 3.0975663301160621,
    3.1038558048980236, 3.1101452796799851, 3.1164347544619466,
    3.1227242292439081, 3.1290137040258696, 3.1353031788078312,
    3.1415926535897931 },

  // Variable: ModelParam_pu_c0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.267,

  // Variable: ModelParam_pu_c1
  //  Referenced by: '<S170>/aerodynamic coefficients'

  1.88,

  // Variable: ModelParam_pu_c2
  //  Referenced by: '<S170>/aerodynamic coefficients'

  4.0151999999999992,

  // Variable: ModelParam_pu_c3
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.8,

  // Variable: ModelParam_pu_cl0
  //  Referenced by: '<S170>/aerodynamic coefficients'

  0.18245999999999998,

  // Variable: ModelParam_pu_coefs
  //  Referenced by: '<S170>/aerodynamic coefficients'

  { -80.48935526181603, -46.0737656842747, -166.52832920575409,
    -153.7528672945617, -356.30436835179762, 1056.5035635397846,
    897.87828814100988, -4403.7637383116444, -767.43759982991719,
    -500.15034743449206, 1051.4004092095822, 2334.383066303863,
    1734.8634284442894, 770.52640797539414, -127.33266812257848,
    20.286909367258158, 220.02783104752709, 47.457911566155857,
    -100.96561603260383, -139.20407457584875, -69.51044674796988,
    -29.359973689808122, -40.641875243279678, -10.800979994627857,
    89.574849453576761, 66.182756717459071, 271.1906702125118,
    -336.4934035257134, 140.54155490930557, -111.12460064429673,
    328.81803587334946, -1221.5620530325057, 4526.135884954886,
    -5868.0140470163178, 2625.6435680944946, -703.54290264162921,
    188.50951550804379, -50.51546151245568, 13.530951030604584,
    -3.6302867463477106, 0.96806093984697894, -0.26400885549312242,
    0.066213853624294022, -0.022145327258695169, 0.0016880236447013412,
    -0.0045022059252136622, -0.0026017186853518177, -0.0028129142362162138,
    -0.0023893427068215037, -0.0020518384347344727, -0.0015895869304249121,
    -0.001038216411244489, -0.00036298152270594852, 0.00045828581194593177,
    0.0014604907778046328, 0.00268902570759223, 0.0042078502473841,
    0.0061043927433904761, 0.00850820087221934, 0.011559901000868088,
    0.015525237916250462, 0.020190096144648811, 0.026327854528986144,
    0.027538077007709959, 0.032654982097338109, -0.038544182418917668,
    9.5207360290652332E-5, -0.66545704601574129, 0.36357347475989543,
    -0.13026542370126068, 0.0031385692164883397, -0.031378989369183263,
    -0.020740687173881975, -0.022025925662518805, -0.019925835162684081,
    -0.018528641885210039, -0.016726271844356277, -0.014804177854576918,
    -0.012675210537897576, -0.010351849190618266, -0.0078180044294877439,
    -0.0050607897224567693, -0.0020582723519540738, 0.001222524956037255,
    0.0048324591451259485, 0.0088483054340138239, 0.013384046794232043,
    0.018602026782644665, 0.024732828808450978, 0.03205929779891243,
    0.041002601470192024, 0.0517392176272374, 0.065386027784369791,
    0.095047748266011617, 0.12993194896060031, 0.16330752973040624,
    0.19041830243660066, 0.20841108895426938, 0.21582147175069438,
    0.21226453743600002, 0.19814610032502128, 0.17443365872100136,
    0.14246749536797249, 0.10380905189760505, 0.060120091860079675,
    0.013067839084547565, -0.035748086322286168, -0.084850342664679182,
    -0.13292288164190422, -0.1788364521914611, -0.22166243434331317,
    -0.26067634482811447, -0.29535229586421852, -0.32534982351654562,
    -0.35049470044603409, -0.37075557011647342, -0.38621816728249014,
    -0.397058737011075, -0.40351796347083557, -0.40587610233771215,
    -0.40442975361878952, -0.39947024539500309, -0.39126328793762444,
    -0.38002948659149394, -0.36592573726711969, -0.34902814042316754,
    -0.3293206634035073, -0.30669158242403577, -0.27901749293154848,
    -0.246254300135168, -0.20847740578744239, -0.165891764015944,
    -0.11884287763395848, -0.067823795499361322, -0.013478220384656837,
    0.043401146216180589, 0.10187995729192469, 0.16089589581119587,
    0.21927966961399736, 0.2757837382414251, 0.32911906134600666,
    0.37799959987850906, 0.42119399602064878, 0.45758344973075982,
    0.48622426690116916, 0.50641295064303393, 0.51775079151441994,
    0.52020411740842742, 0.51415504642223031, 0.50043632778492342,
    0.48034215890135262, 0.45560547410936841, 0.42833134752633995,
    0.40087633671474621, 0.37566508373064705, 0.3549400177005862,
    0.34044764264771155, 0.33307704070833477, 0.33245790093029232,
    0.33659003796785886, 0.34135520651202755, 0.34056448214156515,
    0.32407588993847053, 0.30534736706347304, 0.28537254213330021,
    0.26416810340166436, 0.24206818518934736, 0.21936489266663375,
    0.19638760689223367, 0.17346282105902058, 0.150905947672895,
    0.12900629679973069, 0.10801702453476764, 0.08814806425336294,
    0.069563274691853375, 0.052381530025482959, 0.036681546948182236,
    0.022509726261160285, 0.00989013486195148, -0.0011647034922867136,
    -0.010643910016774019, -0.018530816444343089, -0.024799119972928794,
    -0.029413012959911049, -0.032331098926906977, -0.033513279003399239,
    -0.032929404249939322, -0.030568613764432109, -0.026448279392050428,
    -0.020621882944501742, -0.013185198768518428, -0.0042802604539899924,
    0.0059034237752908451, 0.01713051346913572, 0.029124107577522745,
    0.041572270617064741, 0.054136413724561239, 0.066461189858090977,
    0.0781855311946021, 0.088954446336496559, 0.098431036400401087,
    0.10630795335404686, 0.11231723729104075, 0.11623753253387764,
    0.11789806869228442, 0.11717937263671101, 0.11401117924661326,
    0.10836917134588138, 0.10027214477787068, 0.089780638488355033,
    0.076996738193183159, 0.062064528335782382, 0.045170039516232982,
    0.026539670385061956, 0.0064359764905444639, -0.014849669656755202,
    -0.03700772740896939, -0.059723841609413623, -0.0826937302712952,
    -0.10563739632532661, -0.12831031930127121, -0.15050936328155,
    -0.17207206141617598, -0.19286915261632367, -0.21279282361028276,
    -0.2317452772244141, -0.24963081668280088, -0.26635158235778222,
    -0.28180623330121318, -0.29589043564601625, -0.30849869847970979,
    -0.3195272448034675, -0.32887760837365726, -0.3364604391057478,
    -0.342199072766243, -0.34603246477677174, -0.34791739843097946,
    -0.34783017986840353, -0.3457681979844307, -0.34175191094611607,
    -0.33582732728495379, -0.32806884718962076, -0.31858182116435646,
    -0.30750411682058088, -0.29500608770029318, -0.281288581085319,
    -0.26657889593085971, -0.25112488247787795, -0.23518750086442486,
    -0.21903194405025372, -0.20291745603415937, -0.18708611260105432,
    -0.17175121824108008, -0.15708634082153655, -0.14321589218594846,
    -0.13020812566113385, -0.11807085405833526, -0.10675026427850717,
    -0.09613291031281, -0.086050977903151624, -0.076290775023234253,
    -0.066604087020288555, -0.056722256293686935, -0.046372496100707566,
    -0.035295974468473587, -0.023266856862185183, -0.01011140119235584,
    0.0042741091241405, 0.019908207635780443, 0.036714349509739619,
    0.0545190091483004, 0.0730600197621649, 0.092005725887842782,
    0.11098351444889808, 0.1296142278166259, 0.14754779869456205,
    0.16449491300408758, 0.18025062088230762, 0.19470776375800783,
    0.20785951683516746, 0.21979144785690696, 0.23066466116245962,
    0.24069268387669995, 0.25011525031443715, 0.259172077118685,
    0.26807939639743172, 0.27701104474146049, 0.28608522734682951,
    0.29535690498086076, 0.3048156387835842, 0.31438827310676715,
    0.32394590175448273, 0.33331428687699771, 0.34228677102727306,
    0.3506384690724158, 0.35814036524851722, 0.36457204060306336,
    0.3697320574937244, 0.373445298139413, 0.37556694212258546,
    0.37598292268051048, 0.37460704064258571, 0.37137521606458063,
    0.36623801360081371, 0.35915301313547965, 0.3500786843438457,
    0.33897079231081939, 0.32578150170883369, 0.31046052833137661,
    0.29295770853110553, 0.27322673559703475, 0.25123021438772131,
    0.22694609463083826, 0.20037507706017735, 0.17154744093121602,
    0.14052702983125287, 0.10741064939857184, 0.0723232531677806,
    0.035413343339463985, -0.0031446899585628432, -0.043141922589838025,
    -0.084311592499022717, -0.12633454501333238, -0.16873143046394412,
    -0.21119248227561635, -0.25230523522565462, -0.27924783675485476,
    -0.30415845773840389, -0.33211010393821649, -0.36426411069466852,
    -0.39895551148851444, -0.43316225400222552, -0.46349974883297707,
    -0.48692273068148684, -0.5011234643702267, -0.504704144211845,
    -0.49718524742322284, -0.47890878969663869, -0.45088303049840256,
    -0.41460395198481748, -0.37187793787364587, -0.3246612086047771,
    -0.27492439915638456, -0.22454567559398309, -0.17523247969547459,
    -0.12846973369733794, -0.085491070339260358, -0.047268690715821272,
    -0.014517302057135242, 0.012292048495507048, 0.03291167794825927,
    0.047292680779532463, 0.0555577439930229, 0.057972789478103512,
    0.054919082491356248, 0.046867089577073591, 0.034352923443321616,
    0.017957555053385359, -0.0017109553821446585, -0.024033568229144552,
    -0.048390935977213466, -0.072356293534308433, -0.095958797443284283,
    -0.11927458430768133, -0.14235070130537411, -0.16517217699448369,
    -0.18765260096519482, -0.20963781193071918, -0.23091454804376726,
    -0.25121971740573612, -0.27024828569926457, -0.28765978964739536,
    -0.30308459277033284, -0.31613157347104226, -0.32639832394168677,
    -0.33348426035400797, -0.33700597123410786, -0.33661401810144509,
    -0.33201074874805081, -0.32296883978649726, -0.30935023715766558,
    -0.29112430495937675, -0.26838331876835253, -0.2413526428823855,
    -0.21039398807709536, -0.17600302684682123, -0.13880703613611639,
    -0.099572502506978647, -0.05923144173622983, -0.018931899440797987,
    0.019888087177467057, 0.0553876714554459, 0.085213425309401,
    0.10621576664457082, 0.1146272817149748, 0.10430408029126662,
    0.09307789897480602, 0.083030703576303044, 0.0743672251373967,
    0.067192940247080973, 0.061343240633445088, 0.056585281629990304,
    0.052756101409787405, 0.049420004735706347, 0.047288768828063016,
    0.042946929952250038, 0.048532222640403917, 0.018264417156176698,
    -0.52119682050185945, -0.33597588203293194, 0.10346482224365504,
    0.56186728261178009, 0.88625391533402675, 1.0084314129490572,
    0.91333784435408272, 0.62290760272045809, 0.18116241275211442,
    -0.35651213467748788, -0.93148060410443778, -1.4876482282803838,
    -1.9756389305959006, -2.3560812183601425, -2.6024974305323134,
    -2.7045888632989343, -2.6768140281970281, -2.5572920542699928,
    -2.3058304376962568, -1.8945087312422679, -1.303934086550822,
    -0.52585668277208519, 0.43548118425167959, 1.5616099366789487,
    2.818793942145688, 4.1582876818055947, 5.5188473380876966,
    6.8324665726090892, 8.03427045893349, 9.0738316825837817, 9.9160091214924861,
    10.537934553469432, 10.926181176716874, 11.07463961611646,
    10.983174669671541, 10.579681141381114, 10.004461704049403, 9.26835010916151,
    8.3860916377823482, 7.376578662349238, 6.262440310088059, 5.0693536577273592,
    3.8250644850215556, 2.5582115844076174, 1.2970196664896962,
    0.067954754272978687, -1.1055514377850579, -2.2042089567114522,
    -3.2137571496795676, -4.12559314464337, -4.9373337806847708,
    -5.6537964085769215, -6.2882499106131684, -6.8481844134472025,
    -7.3396858426642035, -7.765737517888752, -8.1249218066305886,
    -8.4106894858256265, -8.6112705857549177, -8.7102495115937391,
    -8.6877779239302626, -8.5222980482482544, -8.1925009768808614,
    -7.6789956952935032, -6.9656331876626822, -6.0410433072175334,
    -4.902721465397704, -3.5532781343169497, -2.0257141835029464,
    -0.29909168266033981, 0.47580518786664816, 1.1590508726202786,
    1.8026984571099434, 2.3785486761385792, 2.8782205023248837,
    3.2863000927228523, 3.5876455264277829, 3.7659810223920824,
    3.8056345050646874, 3.6936037762372353, 3.4229552608164218,
    2.9972547122986084, 2.4355975862847012, 1.7765871531886002,
    1.0793952537376417, 0.41568413358975248, -0.15629469363162016,
    -0.65820457817868316, -1.081700431760896, -1.4261864733275249,
    -1.701149646337516, -1.9212016973694159, -2.1008543214945536,
    -2.2490405828102848, -2.3650500817439113, -2.4405103588201462,
    -2.4807473011775509, -2.4386853233505361, -2.3074520698058509,
    -2.0450225356865639, -1.8478918540019276, -3.7631189655376258,
    -3.49817744075049, -2.1787513191212153, -0.38631588017549612,
    1.418310484004738, 2.9527900112159955, 4.050845075777465, 4.6396921580442587,
    4.71340265883692, 4.3130737416825484, 3.5101523009311091, 2.3932799021171602,
    1.0580344237962567, -0.40075136476709616, -1.894475628204723,
    -3.3444242440535659, -4.683973007666312, -5.8596718198297975,
    -6.8315053759411075, -7.5725770717352709, -8.0683959374946319,
    -8.3158924326031585, -8.3222599529433534, -8.1036761466432257,
    -7.68392798265198, -7.09295360974516, -6.3653080087262648,
    -5.5385360691360308, -4.6514261900271059, -3.7421615935194708,
    -2.8492529930511572, -2.0012946389106041, -1.2203421523933327,
    -0.52218746774581282, 0.0833538032988616, 0.26980921666897684,
    0.45368716853617874, 0.65423035920143524, 0.88996331168988041,
    1.1777662763187278, 1.5311779018230665, 1.959168505385227,
    2.4653023780631482, 3.0474288495209936, 3.6977978369010542,
    4.403423119396134, 5.146490947289676, 5.90465335556019, 6.6511686449567229,
    7.3550251173561758, 7.9812651072396044, 8.49173260251582, 8.8464412751916761,
    9.0057094009047045, 8.9331344182795522, 8.59931812230851, 7.9859549585397724,
    7.0897061758083355, 5.92530043721897, 4.5275010325002185, 2.951963309108526,
    1.2751920360431039, -0.40579308721545604, -1.9746770313175248,
    -3.2943820997840763, -4.2482178787974716, -4.6607501058253931,
    -4.2927280308347271, -2.9399108037418191, -0.10337417796464772,
    0.019522087523146128, -0.01413023001947975, -0.0059866275080457561,
    -0.0091989921358278572, -0.0095257255236330489, -0.010777935338067908,
    -0.011924344947797545, -0.013226471958684339, -0.014595463189170323,
    -0.016033382743702859, -0.017516049061027977, -0.019025416396249127,
    -0.020541553849233014, -0.022045235592627874, -0.02351738192222538,
    -0.024939024738512641, -0.02629076862496197, -0.027551882478738528,
    -0.028698731600180237, -0.029702125405104446, -0.030523163903125455,
    -0.031106358329951938, -0.031371311171201663, -0.031195717983233406,
    -0.0304177664660444, -0.028763180196337088, -0.02607781425823363,
    -0.024366074353896209, -0.021478325397684243, -0.016370823600524366,
    -0.00860811612344477, 0.001740655387795931, 0.014274376496438246,
    0.028380551313686792, 0.04333940120686932, 0.058405064969503741,
    0.072868703036262361, 0.086105142906404891, 0.09760548904709343,
    0.10699619102593465, 0.11404277729631185, 0.11864436838905536,
    0.12082195666272703, 0.12070183194447684, 0.11849487397744028,
    0.11447219688915986, 0.10893830738875038, 0.10220416295903383,
    0.0945633281011732, 0.086273330137189269, 0.0775429263508016,
    0.068524762963898464, 0.059312158605907155, 0.049938749008709926,
    0.040380268488654072, 0.030558622503235759, 0.020348841769976259,
    0.0095896819533378, -0.0019018457551065748, -0.01431210719015439,
    -0.027809458138932892, -0.042522511226343429, -0.0588674931244077,
    -0.076811267239311393, -0.096251998859436888, -0.11702162807007883,
    -0.13889085422978489, -0.16157716866236455, -0.18475556091340242,
    -0.20807197147303713, -0.23115965269836988, -0.25365814128841024,
    -0.27523306101218648, -0.29559452542308096, -0.31451220296266641,
    -0.33182495106293919, -0.34744206705629493, -0.36133666191025721,
    -0.37353430061837078, -0.38409896025296819, -0.39311673127633706,
    -0.40067733541080125, -0.40685430847062043, -0.41168646228222977,
    -0.41516331308285492, -0.41721549417332532, -0.41770967796518454,
    -0.41644726648828989, -0.41316700429062997, -0.40755249774872054,
    -0.39924515731356308, -0.38786153876105806, -0.37300724062681445,
    -0.3542835659807767, -0.33123631624344091, -0.30333749552393752,
    -0.26954223301241864, -0.23306366187248681, -0.19473262297993749,
    -0.15521682508726697, -0.11523278710006866, -0.075447958041875277,
    -0.036469131914497147, 0.0011852376050514419, 0.037098102912461704,
    0.070958556342179471, 0.10255665514215194, 0.13177164882761708,
    0.15855792402878036, 0.18293317014977781, 0.20496523922895502,
    0.22475950800182623, 0.24244770540281138, 0.25817820610591052,
    0.2721076261847577, 0.2843934397233337, 0.29518647376042356,
    0.30462276710807384, 0.31281553435924236, 0.31984870280563044,
    0.32577399285585279, 0.33061280347694988, 0.33436315898236846,
    0.33701060866941784, 0.33854094663587225, 0.33895246181047156,
    0.33826582996240823, 0.33653052317583787, 0.33382714614598036,
    0.33026544963254584, 0.32597820109412717, 0.3211114804856865,
    0.31581245387523227, 0.31021577983509196, 0.30442985839937409,
    0.29852414158945623, 0.2925188673832026, 0.28637904610547,
    0.28001449667812545, 0.27328719565507237, 0.26602594263459067,
    0.25804639886857766, 0.24917417329465769, 0.23926803741790265,
    0.22823988987077709, 0.21606884644867752, 0.20281021344299432,
    0.18860018131376674, 0.17365490385069768, 0.15826222992118283,
    0.14276597606500593, 0.1275448358778212, 0.11298959593769151,
    0.09948114868847395, 0.087369759768084962, 0.076954975718720425,
    0.068465994356180448, 0.062043216115675044, 0.057722492843529247,
    0.055423777557833509, 0.054945861662003388, 0.055968823534638404,
    0.058065111687989605, 0.060719367584328325, 0.063355147784760965,
    0.065365852093451055, 0.066146980998904273, 0.0651278789997672,
    0.061800928076963947, 0.0557468299434729, 0.046654570921914017,
    0.034335104294682749, 0.018728012783454751, -9.8734126819838031E-5,
    -0.021955342717160292, -0.0465426019604175, -0.073469802479141727,
    -0.10227756502868808, -0.13246414683542435, -0.16351256942924353,
    -0.19491564060799732, -0.22619633967863445, -0.25692187648065085,
    -0.28671089160811397, -0.31523425276592087, -0.34221046171676622,
    -0.36739728853058795, -0.3905815817538365, -0.41156926190130677,
    -0.43017724433513843, -0.44622826124722759, -0.45954889595897791,
    -0.46997068136761833, -0.47733370525892743, -0.48149207992021315,
    -0.48232086530211216, -0.47972414702516697, -0.47364403355379348,
    -0.46407008522319465, -0.45104870580108519, -0.43469169859840873,
    -0.41518316335270444, -0.39278374383599896, -0.36783130260101793,
    -0.34073716596986853, -0.311977548299709, -0.28208008663118328,
    -0.25160608139640178, -0.22112936238407505, -0.19121301247518274,
    -0.16238541202384238, -0.13511707800168787, -0.10980001394368336,
    -0.086731183463058525, -0.066101472157344549, -0.047990981601961379,
    -0.03237062439224761, -0.01910947846144077, -0.0079868147027431623,
    0.0012923947019999359, 0.0090796025094689644, 0.015763406251144467,
    0.0217493745639616, 0.027439559902608164, 0.033212430319027021,
    0.039404020089841126, 0.046291553712904138, 0.054080905594161455,
    0.062899863065261075, 0.072798459248994557, 0.083757027207097351,
    0.09570060576111028, 0.10851687854886471, 0.12207382826665197,
    0.13623367806722714, 0.15086089388554644, 0.16582399929106628,
    0.1809923499151202, 0.19622991719915051, 0.21138862690196736,
    0.2263037091702883, 0.24079264485157406, 0.25465801270598687,
    0.2676934546972598, 0.27969171639733575, 0.29045343172936855,
    0.29979543373560918, 0.30755764793026069, 0.31360803827375827,
    0.31784591960843672, 0.32020351357869703, 0.32064580181708935,
    0.31916850928957818, 0.31579461460739283, 0.31056986609611731,
    0.30355789311046072, 0.2948353399388885, 0.28448713941973669,
    0.27260180299483339, 0.25926649007156616, 0.24456181569734523,
    0.22855693007000802, 0.21130520300410627, 0.19284275011993066,
    0.17318700527102041, 0.1523519541170785, 0.13032451779668647,
    0.10721163233196863, 0.082769478591404613, 0.058240093655379674,
    0.052194008634986404, 0.049558531795698878, 0.041541291547112884,
    0.022922972150655058, -0.008048504914000644, -0.050584348973988669,
    -0.10209558472997231, -0.15892857401615781, -0.21698235437777819,
    -0.27220283029289355, -0.320944768009251, -0.36021125619214817,
    -0.38778589331148311, -0.40227681562503037, -0.40309248645234047,
    -0.39036831709259345, -0.36486128699686715, -0.32782699298977053,
    -0.28089087323130169, -0.22592242068574589, -0.16491865033794936,
    -0.099900683025796438, -0.032825724355694447, 0.034484545476907609,
    0.10039882611658461, 0.16351434445397109, 0.22267847833317672,
    0.27699420613891046, 0.32581072873820333, 0.368701807893619,
    0.4054358503285535, 0.43594252911275128, 0.460280675199879,
    0.47860884189117625, 0.49116537338655991, 0.500983943829901,
    0.50807449176412578, 0.51223686268101432, 0.51311327745595614,
    0.51024119272005708, 0.50310543315223588, 0.49118558297714021,
    0.47399880852298565, 0.45113867799492569, 0.42231056842939929,
    0.38736385166659854, 0.34632043241135896, 0.29939879094314437,
    0.24703273376975377, 0.189884233934145, 0.12884974933077697,
    0.0650591994097867, -0.00013342107232570174, -0.065168785177471544,
    -0.12831125161793866, -0.18768890665798074, -0.241345408834034,
    -0.28730461655480866, -0.32364967541755774, -0.34861946100270691,
    -0.36072656646111589, -0.35890227774138561, -0.34267470581845977,
    -0.31238858493623234, -0.26946947706140395, -0.21675679686836713,
    -0.15884444180712623, -0.10267901715770145, -0.057500118322238392,
    -0.037563968486292412, -0.023088306520331683, -0.011868196114650049,
    -0.0032863390191545374, 0.0034685505632713488, 0.0089138826422731927,
    0.013437491510084883, 0.017301126912576226, 0.020679613945395869,
    0.023699572832174283, 0.026404412210453376, 0.028973284089680876,
    0.03096336595750156, 0.034178390599569362, 0.031990003557983926,
    0.049208481406925152, 0.24470305308491555, 0.16472390914420615,
    -0.26881091441243354, 0.23733486777869373, -2.5916892965360763,
    0.3837837276410484, 1.864513292061341, 0.90583635991555278,
    0.48610042027727962, 0.20270109913742715, 0.080094229703602277,
    0.016792013365371568, -0.01273796775251497, -0.027046397135119669,
    -0.033084331300504942, -0.034708752975822807, -0.033763870826809844,
    -0.031299028947216707, -0.027922389677222506, -0.02402002986562805,
    -0.0198466029876499, -0.0155774401335362, -0.011327920216155581,
    -0.0071933510077462392, -0.0031663213560933078, 0.0005139173482910475,
    0.0046382637717225592, 0.0062440311120580926, 0.016454924995827229,
    -0.0061075911377040243, 0.093181920029786633, -0.26248809416495866,
    1.0798898978971188, -3.9144394429385212, 14.741081948455841,
    -54.855199794612993, 204.93932433813774, -764.60103092266013,
    2853.7617962901663, -4627.7327912812589, 4071.2141764775715,
    -4395.357717922403, 261.06319543902833, 166.70524224388961, 792.507589710423,
    730.15176994512126, 1254.0036814061968, 1149.3774728213132,
    -35.90210798594029, -1848.0136212455159, -1626.5028921521621,
    1817.7134220851274, 1710.6138425310999, 1963.2350167505056,
    812.68050488487563, 203.50156369714466, 651.96731735874289,
    2193.5327947229471, 2347.9150288805295, -13328.046971015479,
    4858.7687918796364, -310.77528845696952, 300.13962168422427,
    -582.14252062054845, -330.06190853344958, -20.92279127365644,
    -22.441498584062895, -23.310837946206217, -26.452965127270271,
    -29.354039471779974, -36.0769414901339, -16.142383930325913,
    0.79916462127490817, -82.292918312207533, -96.773256604785473,
    -106.21030559692105, -86.372036518518087, -42.325906237649683,
    -9.59176688760655, 4.9468523477844863, 2.544285532553991, 2.9270675471619709,
    7.078646031271389, 7.97410204527108, 6.0690399576242582, 3.442478407850996,
    2.1309258021382727, 1.5769493597749853, 0.81010121147230252,
    0.6063037375822633, 2.2964400077910878, 3.54520434591665, 8.6621449901311429,
    2.3130446628170138, 4.9648423590762167, 2.8680962388526723,
    9.0723744722913136, -13.976576709155921, 71.424475815308568,
    -39.295703291406539, 10.24605373244283, -3.0286923001346913,
    0.528185231708181, -0.42496193213709821, -0.16965420628822586,
    -0.23815199711552848, -0.21988621250985518, -0.2248676436264237,
    -0.22361829253867305, -0.2240361399706686, -0.22400428962421684,
    -0.22408923915609749, -0.22413832948828133, -0.22419140474771235,
    -0.2242364878798036, -0.22427520283807933, -0.22430519583882791,
    -0.22432478534658337, -0.22433163423597469, -0.22432298710474141,
    -0.224295429945019, -0.22424469226688235, -0.22416529676279545,
    -0.22405011649010392, -0.22388958014560922, -0.2236714630281284,
    -0.22337852625103613, -0.22299757094937706, -0.22250080581803389,
    -0.2219812056954289, -0.22136505763615402, -0.22209232562609052,
    -0.2220905292132157, -0.23464665514141717, -0.22778659653873973,
    -0.23024449983071391, -0.23018527997488064, -0.23077735206183453,
    -0.2311686961486919, -0.23158429066073852, -0.23196025977402537,
    -0.2323098660516596, -0.2326254644465183, -0.23290479595637803,
    -0.23314395720752465, -0.23333928029087078, -0.233486793716002,
    -0.23358228284403712, -0.23362111920023731, -0.23359805208059337,
    -0.23350687119082661, -0.23333991760918213, -0.23308738173479454,
    -0.23273639079973965, -0.23226972129050891, -0.23166481285542426,
    -0.23089115837161717, -0.22991492085806706, -0.22868118953950448,
    -0.22688778829214468, -0.22443617714312122, -0.22135482137327211,
    -0.21776192803968858, -0.21382953917488948, -0.20975732806293521,
    -0.20575223069702311, -0.20201352599361722, -0.19872223770065453,
    -0.19603410054253467, -0.19407538730038226, -0.19294101589544391,
    -0.19269444636230854, -0.19336895642459956, -0.19496994869588602,
    -0.19747799403199651, -0.20085235610045746, -0.20503477697320652,
    -0.20995332886435752, -0.21552616131422395, -0.22166499984515745,
    -0.22827828258411872, -0.23527385600964085, -0.24256118428004317,
    -0.25005305702020031, -0.25766680518615515, -0.2653250477169079,
    -0.27295599992628877, -0.28049337402995189, -0.2878758957777206,
    -0.29504645339468194, -0.30195089548452303, -0.30853650654667797,
    -0.31475026856964355, -0.32053705549013051, -0.32580167594665821,
    -0.33044810657858975, -0.33438174673751636, -0.33751186293646973,
    -0.33975424078214889, -0.34103396893637933, -0.3412882817180376,
    -0.34046937047412634, -0.33854705620759951, -0.33551120416992924,
    -0.33137374231321814, -0.32617013771237358, -0.31996017960256418,
    -0.31282792274946813, -0.30488065570060074, -0.2962467769974248,
    -0.287072491202278, -0.27751727675530918, -0.26774813511559303,
    -0.2579327030818479, -0.24823140748637751, -0.23878896249563761,
    -0.22972566281027521, -0.22112910539047176, -0.21304716776469951,
    -0.20548326293334163, -0.19839505472158284, -0.19169789585027239,
    -0.18527418526123823, -0.17898954631728078, -0.1727165895653805,
    -0.16636566589840773, -0.15992483100926508, -0.15349891584308162,
    -0.14738411443145458, -0.1416226907368035, -0.13623816051515975,
    -0.13125372464153143, -0.12668627940273824, -0.12254720952131422,
    -0.11884168481819825, -0.11556871470222296, -0.11272135724521348,
    -0.11028721169390614, -0.10824910063840543, -0.10658588555680633,
    -0.10527333617103221, -0.1042849792346236, -0.10359285624114183,
    -0.10316813317413434, -0.10298152191272091, -0.10300349803244896,
    -0.10320433184334492, -0.1035539791514937, -0.10402189947055084,
    -0.10457687668036861, -0.10518691357448973, -0.10581925634394745,
    -0.10644058231679208, -0.10701736389296469, -0.10751640125175185,
    -0.10790550368995998, -0.10815428761540931, -0.10823504938596595,
    -0.10812366108108031, -0.10780043528368204, -0.10725090926321464,
    -0.1064665060201902, -0.1054450371934708, -0.10419101926069607,
    -0.1027157814804085, -0.10103735123947771, -0.099180112675869819,
    -0.097174249100641832, -0.095054999806076249, -0.092861780717306538,
    -0.090637229927662488, -0.088426239800170156, -0.0862750284899687,
    -0.084230272979002513, -0.08233829560126342, -0.080644276416221225,
    -0.079191469286742172, -0.078020409429276016, -0.077168121955964453,
    -0.0766673601931398, -0.076545923457633808, -0.076826113326115872,
    -0.077524390830946241, -0.078651285617999042, -0.080211586011502523,
    -0.08220479723216427, -0.084625810784696914, -0.087465685319124173,
    -0.090712413991999, -0.094351551006796056, -0.098366616300433835,
    -0.10273928453125762, -0.10744942471023794, -0.11247505939136324,
    -0.11779229898460807, -0.12337528528426905, -0.12919616963733177,
    -0.13522514528235385, -0.14143054755501588, -0.1477790258956635,
    -0.15423578321139181, -0.16076487059425448, -0.167329523705173,
    -0.17389253113923872, -0.18041663222412627, -0.18686495230088337,
    -0.19320148481902952, -0.19939162704246402, -0.20540276403307561,
    -0.21120488219736161, -0.21677118224470995, -0.22207865455627609,
    -0.22710857828636954, -0.23184690913277917, -0.23628452669994382,
    -0.24041731436560571, -0.24424604703325, -0.24777606719503747,
    -0.25101674206271729, -0.25398071380026732, -0.25668297202710405,
    -0.25913979419535615, -0.26136760517260538, -0.2633818144580366,
    -0.26519569100343621, -0.26681933736989188, -0.26825882408672214,
    -0.2695155382638, -0.27058579786539644, -0.27146077379979366,
    -0.27212675322376112, -0.27256576215223705, -0.27275654836067914,
    -0.272675902656011, -0.27230026614636421, -0.27160752422023138,
    -0.27057883642069525, -0.26920030896512981, -0.26746430588681858,
    -0.26537022184081682, -0.26292460558909975, -0.26014061111202075,
    -0.25703685129071591, -0.25363580608731245, -0.24996197737727918,
    -0.24603999580931593, -0.24189287750355107, -0.23754059879514691,
    -0.2329991070988115, -0.22827982642050154, -0.2233896576908449,
    -0.2183314218812018, -0.21310465994054517, -0.2077066824718499,
    -0.20213376305520153, -0.1963823722353622, -0.19045036088906453,
    -0.18433801214960405, -0.17804889674426297, -0.17159048470055541,
    -0.164974489274119, -0.15821694488722871, -0.15133804492052386,
    -0.14436178356546897, -0.1373154592102124, -0.13022910277594393,
    -0.12313489744400659, -0.1160666528382151, -0.10905938766997286,
    -0.10214905341778616, -0.095372401960868089, -0.088766968790219433,
    -0.082371124040042612, -0.076224140421769657, -0.070366239430508362,
    -0.06483858907052556, -0.059683231080633017, -0.054942912787084422,
    -0.050660797569939672, -0.046880035587655404, -0.043643205676705835,
    -0.040991682045800636, -0.038965012333653494, -0.037600386502827911,
    -0.036932192513245352, -0.036991527857837408, -0.037805547960359773,
    -0.039396374864908636, -0.041780108669745318, -0.044963804900228825,
    -0.048948674274509982, -0.053709276517453504, -0.058978243199014388,
    -0.064717234047994732, -0.070983628418654313, -0.077856718233220573,
    -0.0853843801191594, -0.093557469338293231, -0.10230297928352887,
    -0.11149044398971047, -0.12094585416514532, -0.130468826127221,
    -0.13984992835404181, -0.14888618262104727, -0.15739363497082307,
    -0.16521655827237097, -0.17223330900899625, -0.1783591544616463,
    -0.18354654468794868, -0.18778336778007712, -0.191089728566174,
    -0.19351375001716051, -0.195126831810058, -0.19601871752472663,
    -0.19629263614028039, -0.1960607045531747, -0.19543971304777707,
    -0.19454737467833907, -0.19349908758894879, -0.19240523239646762,
    -0.19136899584333408, -0.19048468770941671, -0.18983650217232775,
    -0.18949767140336043, -0.18952995443556525, -0.18998342999945517,
    -0.19089649071401529, -0.19226173996451598, -0.19407233127435791,
    -0.19632285474480188, -0.19900878818295711, -0.20212532690856605,
    -0.20566603581318998, -0.20962157100760623, -0.21397856468774804,
    -0.21871868491986074, -0.22381784425316467, -0.22924553123147962,
    -0.23496425994049508, -0.24092916461790972, -0.24708778669982695,
    -0.25338010923683768, -0.25973888090926395, -0.26609025704358408,
    -0.27235477673833469, -0.27844868985793814, -0.28428564140414664,
    -0.28977869832753339, -0.29484266867339032, -0.29939661275625179,
    -0.30336641580305507, -0.30668731559976647, -0.3093063856597596,
    -0.31118516189025175, -0.31230276586758809, -0.31265998097994269,
    -0.31228472411167679, -0.31123964602307536, -0.30963180295433251,
    -0.30762767879704167, -0.30546484260400525, -0.30349678895611187,
    -0.30174055566106717, -0.30017389711222914, -0.29877070475084544,
    -0.29750287984121593, -0.29634542954616944, -0.29527775444069276,
    -0.29428232993245834, -0.2933498523119118, -0.29245758775479369,
    -0.29164724685610671, -0.29073152028490518, -0.29038689951161117,
    -0.30022106228863332, -0.30656039780080474, -0.30460817962977277,
    -0.29400662931533666, -0.27728441436263029, -0.25825690253934769,
    -0.24102365652087041, -0.22927037154441018, -0.22585212226498677,
    -0.23257894450652533, -0.2501545158147111, -0.27822409386330621,
    -0.31550128756007478, -0.35995682778141325, -0.40906185365978515,
    -0.4600931840137204, -0.51060044699280693, -0.55885251864918528,
    -0.602359905817336, -0.63810630048539274, -0.66270948214955017,
    -0.67263156918525435, -0.6644147254061572, -0.63494960645813658,
    -0.581763406214065, -0.50330306968149185, -0.39917111620628276,
    -0.27025323758518549, -0.11865921325636959, 0.052549693373737029,
    0.23964916129571689, 0.43848338217970778, 0.64464320510199447,
    0.85360420485667843, 1.0608394051891639, 1.2604613184089013,
    1.4492297471930582, 1.6241089100388879, 1.7823412456640764,
    1.9215256620859826, 2.0396880432975233, 2.135338759270859,
    2.2075116991246468, 2.2557811208658056, 2.2802538383180204,
    2.2815360374579394, 2.260676023793641, 2.219086073851376, 2.1584475402065646,
    2.0806040980749785, 1.9874443891637557, 1.8807661593614968,
    1.7621167916550897, 1.632902342143286, 1.4944140350984294,
    1.3478868042521466, 1.1945823318275155, 1.035885873567483,
    0.87340476599821659, 0.70905608205493631, 0.54513140156341267,
    0.384329065586957, 0.22974948070110024, 0.084858931372079713,
    -0.046571591450511762, -0.16055656006295621, -0.2530631891217579,
    -0.3201079487789984, -0.3583299835968114, -0.36397337238357025,
    -0.3549956781929271, -0.33312621448985869, -0.29911213503343625,
    -0.25423266928470428, -0.19992518348582783, -0.13791787880841277,
    -0.070224660613156534, 0.00083346739587024377, 0.072639794142773884,
    0.142332277558384, 0.20691804993644924, 0.26347152372079891,
    0.3094274125146384, 0.34294881280844619, 0.36331530049289712,
    0.37115860511931714, 0.36820957051686043, 0.355790287229381,
    0.33538030446778977, 0.30847041289268973, 0.27637239948974307,
    0.24012235060973974, 0.20048253978289382, 0.15804668769531449,
    0.11342191915370203, 0.06737333408295712, 0.02056554130943266,
    -0.025448608217625221, -0.0689865930285126, -0.10757294602874372,
    -0.14243975367535566, -0.21344387918116714, -0.27944897557044551,
    -0.32055858000378251, -0.32784775196248572, -0.30108646789606769,
    -0.2453719729601592, -0.16893890911094583, -0.081395228638689157,
    0.0075392528412666672, 0.088920158434425509, 0.15515120156707085,
    0.20030862233869903, 0.22027206481943923, 0.21271051801181923,
    0.17696474794591183, 0.11386073211644586, 0.025481541783127303,
    -0.085081232641044571, -0.21398097499549112, -0.35686357257690748,
    -0.50910149091616719, -0.66600927814925248, -0.823037210458146,
    -0.975940810754627, -1.1209244245745105, -1.2547572831488576,
    -1.3748606157497802, -1.4793640645572221, -1.5671291477242149,
    -1.6377378406416165, -1.6914987551833109, -1.7292600316714204,
    -1.7522859652499503, -1.7621388199794437, -1.7605660650480082,
    -1.7554751902554959, -1.7469148282392282, -1.7345705322017644,
    -1.7177783267845068, -1.6955557329026705, -1.6666648185020372,
    -1.6296983957773838, -1.5831820243670951, -1.5256818436705879,
    -1.4559102249386442, -1.3728245689473577, -1.2757183938617729,
    -1.1643068887336758, -1.0388098163446515, -0.90003208135569268,
    -0.74943818449528177, -0.589212570319314, -0.42229416238808337,
    -0.2523706158760925, -0.083816444933202047, 0.078439138483718418,
    0.22912152544853567, 0.36289311006130481, 0.47469419308764793,
    0.56012100379519925, 0.61581990016488808, 0.63988076462350052,
    0.63222408845730482, 0.59496504428436925, 0.53280524486814373,
    0.45264806721723322, 0.36470705645036056, 0.28371004236298913,
    0.22823855777884933, 0.22628804992255436, 0.22665640095407624,
    0.22638978577792443, 0.22627682754974118, 0.22610325706258558,
    0.22592352163125221, 0.2257201589737427, 0.22549516537322095,
    0.22524560268771038, 0.22497020929479813, 0.22466768462554293,
    0.22433718437896569, 0.22397820474903038, 0.22359061799427923,
    0.22317465913431742, 0.22273092319273502, 0.22226036309117861,
    0.22176429771238335, 0.22124443710228681, 0.22070293725631396,
    0.22014250495022228, 0.21956658094130641, 0.21897965297251207,
    0.21838772576108234, 0.21779911171636984, 0.21722517639101183,
    0.21668246050145076, 0.21619041323598295, 0.21573066380544292,
    0.2153254016476269, 0.21501651000099264, 0.21485408841316947,
    0.21488693183767518, 0.21515626683069169, 0.21569176311603586,
    0.21650950932888982, 0.21761152087870983, 0.21898643848909313,
    0.22061110686383575, 0.22245276864971686, 0.22447161818548947,
    0.2266234257010947, 0.22886205799008238, 0.231141777938726,
    0.2334192313231489, 0.23565504288818498, 0.23781495287482932,
    0.2398704470861493, 0.24179887860276747, 0.24358313960490419,
    0.24521098140762562, 0.24667409424704745, 0.24796704855286908,
    0.24908617553023191, 0.25002844103782651, 0.25079035307887115,
    0.25136694613570115, 0.25175089671718642, 0.25193183890557991,
    0.25189595407281884, 0.25162590716109334, 0.25110118650410762,
    0.25029885371804961, 0.24918811687754244, 0.24773880929276129,
    0.24592268573417714, 0.24371467199813562, 0.24109402042279632,
    0.23804531383987709, 0.23455926751630579, 0.23063327726408059,
    0.22627165884533809, 0.22148552939671612, 0.21629231520748105,
    0.21071491226746916, 0.20478056256004232, 0.19851954857481133,
    0.19196386421799952, 0.18514601074934811, 0.17809800705754936,
    0.17085066488467449, 0.16343317158145018, 0.15587302159112321,
    0.14819632185195175, 0.14042844698411519, 0.1325949694199981,
    0.12472277043227552, 0.1168412469750633, 0.10898354323333154,
    0.10118773287072864, 0.09349785940000381, 0.085964732353766,
    0.07864639625293933, 0.0716083373527316, 0.064923564691068428,
    0.058673657317401928, 0.052950156731827729, 0.047864319500213637,
    0.043466775428415455, 0.039792477664069327, 0.036863780742657705,
    0.034689519617085815, 0.033265935528702391, 0.032577820472223573,
    0.032600184038315209, 0.033300166786547791, 0.03463904293857456,
    0.036574125427291222, 0.03906044881410993, 0.04205218700805069,
    0.045503847689358674, 0.049371218799251035, 0.053612076571984066,
    0.058186682759236795, 0.063058098708920013, 0.068192340867522933,
    0.073558396969411313, 0.079128100617470651, 0.084875852252718653,
    0.0907781884969802, 0.096813229548006391, 0.10296007148606819,
    0.10919821415624555, 0.11550712012555964, 0.12186597929901227,
    0.12825371353859977, 0.13464921242111758, 0.1410317556425611,
    0.14738155635916689, 0.15368034861081731, 0.15991193726125968,
    0.16606263228702942, 0.17212149996317741, 0.17808038335661919,
    0.18393366632937483, 0.18967777808121866, 0.19531045826221946,
    0.20082982838120972, 0.20623334974688412, 0.21151678209320185,
    0.21667328086911852, 0.2216927712417629, 0.22656170019652433,
    0.2312632242342873, 0.23577783509668201, 0.2400843621914262,
    0.24416124087415889, 0.24798795004310725, 0.25154653829584195,
    0.25482313271143625, 0.25780929162351951, 0.260503060642064,
    0.2629096307285374, 0.26504156637135978, 0.26691861889922053,
    0.26856714860152781, 0.27001916773892914, 0.27131101317370893,
    0.27248167090313197, 0.27357080339240597, 0.27461656274623591,
    0.27565330458013459, 0.27670934809273051, 0.27780494525976834,
    0.27895062405335874, 0.28014603586625786, 0.28137938650129735,
    0.28262747580798059, 0.28385633626570667, 0.28502242240164777,
    0.28607427724497231, 0.2869545754868198, 0.28760242480461429,
    0.28795579289697071, 0.28795392993955876, 0.28753966721650104,
    0.28666148165255911, 0.28527522224277213, 0.28334540574474265,
    0.28084601601162856, 0.27776079146573934, 0.27408304044708887,
    0.269815071924551, 0.26496736093537426, 0.25955757816792435,
    0.25360960451837139, 0.24715263231108414, 0.24022042436755772,
    0.23285076534133181, 0.22508510186006098, 0.21696833507000235,
    0.20854871088166563, 0.19987774730503508, 0.19101014105886616,
    0.18200360615344791, 0.17291860927033187, 0.1638179745129385,
    0.15476633573789961, 0.14582941912391284, 0.13707314782969202,
    0.1285625694479729, 0.12036062201918422, 0.11252676991177925,
    0.10511555955691723, 0.098175162451742043, 0.0917459890138102,
    0.085859464246101566, 0.0805370574720186, 0.075789647160225848,
    0.071617284515427967, 0.068009396255591575, 0.064945439393944468,
    0.062395993029833383, 0.06032423977355951, 0.058687758999957755,
    0.057440528373405519, 0.056535014167764581, 0.055924231490390483,
    0.055563665741751311, 0.055412967132768214, 0.055437352584427967,
    0.055608670377468562, 0.055906101015751886, 0.056316477444282372,
    0.056834218704388921, 0.057460884933206356, 0.058204376705195369,
    0.059077825384280414, 0.060098246860040221, 0.0612850681676536,
    0.062658660388490342, 0.064239023519784735, 0.066044743159444391,
    0.068092285672594913, 0.070395626465857009, 0.0729661413138298,
    0.075812648676860092, 0.078941486262216393, 0.082356526723770515,
    0.08605907607084147, 0.090047646385123012, 0.094317640800798214,
    0.098861018603223369, 0.10366601405004179, 0.10871696774788552,
    0.11399430973889814, 0.11947470834148737, 0.12513137580216824,
    0.13093450401413581, 0.13685179355856547, 0.14284904524634481,
    0.14889078101759087, 0.15494086207100541, 0.16096306894212314,
    0.16692161573668496, 0.17278157975923217, 0.17850923889998629,
    0.18407231720612188, 0.18944014127363695, 0.19458370776998898,
    0.19947565792332625, 0.20409015404069938, 0.20840266318445735,
    0.21238965942123211, 0.21602829826252123, 0.21929606416915676,
    0.22217070548935786, 0.22462972379382354, 0.22665263836747807,
    0.22821436801241946, 0.22931326681345543, 0.23029808551670194,
    0.23123317692458881, 0.23201699564138248, 0.23244951600718991,
    0.23229765340112041, 0.23134320643941447, 0.22941682362289256,
    0.22641809184767986, 0.22232397670971521, 0.2171879381995937,
    0.21113221612519928, 0.20433559728920392, 0.19701868849885273,
    0.18942835883713069, 0.18182263875210583, 0.17445700369400069,
    0.16757264610356046, 0.16138706728778973, 0.15608709909678431,
    0.15182429899404945, 0.14871254391692079, 0.14682757543714775,
    0.1462082057405435, 0.14685887477797233, 0.14875324243295546,
    0.15183850047074771, 0.15604009249263837, 0.1612665367153967,
    0.16741407180166659, 0.1743708939700761, 0.1820208296391142,
    0.19024637826884053, 0.19893114936670886, 0.20796174409118928,
    0.21722926078025445, 0.22668203842291179, 0.23626860353281928,
    0.24593370602348927, 0.25561534508004463, 0.26524279242303256,
    0.27473559922647783, 0.28400349723865354, 0.29294710789732215,
    0.30145938391256288, 0.30942771892341847, 0.31673666445294218,
    0.323271185331338, 0.32892036876747749, 0.33358148721555586,
    0.3371643035180053, 0.33959549526524369, 0.34082305984731986,
    0.34082054240190612, 0.33959091010906739, 0.33716987896518419,
    0.33362848502934628, 0.32907467744155239, 0.32365369201991312,
    0.31754693260474448, 0.31096903267932524, 0.30416269075047986,
    0.29739077027537736, 0.29092503851342, 0.28503075813200629,
    0.27994629369052165, 0.27585643446735458, 0.27285929013438787,
    0.27092189886726448, 0.26983696223478665, 0.26912818933724536,
    0.26869254937240955, 0.26846861521190563, 0.26840660717278442,
    0.26847205325670387, 0.26864024417699411, 0.26889378846892414,
    0.26922023347320795, 0.26961042520445644, 0.27005759880147889,
    0.27055580845567823, 0.27110248867461145, 0.27168671860264809,
    0.27233161097997544, 0.27293521194195147, 0.27386369845060515,
    0.27848085949493839, 0.28158894011261065, 0.276516901710707,
    0.2809950367080562, 0.23209394328834418, 0.23933533751853853,
    0.27451576551169404, 0.29160747033846796, 0.30077941934297253,
    0.30460406969686588, 0.30611532161057015, 0.30643216044436977,
    0.3061918150635336, 0.30568149216539126, 0.30505724296323994,
    0.30440234348357564, 0.30376527244126461, 0.3031747090815009,
    0.30264785758431995, 0.3021946374679968, 0.301820163340975,
    0.30152624159028635, 0.30131250158468276, 0.30117677438539092,
    0.3011170308904022, 0.30112672770104015, 0.30121424443002853,
    0.30133205945862684, 0.30164253796603657, 0.30152729734472805,
    0.30328549335321436, 0.29833275660674979, 0.31870857744712416,
    0.24484927296151876, 0.52299026248242431, -0.51204092482060326,
    3.3548412119502693, -11.071975494799268, 42.774013059677273,
    -44.544013005588567, 32.273383679171118, -50.660090894547487,
    -45.734239741911324, -42.588774490570145, -27.635404990579687,
    -13.858591558356652, 9.802482033716803, 31.489423924509783,
    30.812007716119275, -4.0570974865157918, -34.746644255451244,
    -0.44925606833672127, 31.827331804484196, 68.870483191232438,
    84.20448381502797, 88.044237673916783, 100.34583367748958,
    141.73434126493626, 186.03579835793386, -65.443447593065727,
    26.233863770661145, 20.37002375184051, 26.033185496792409,
    15.049073387940421, 6.550419009080537, 6.277680401582721, 5.9899222347597751,
    5.6769340502746388, 5.3259373021920995, 4.9144107974731375,
    4.5859786671101137, 4.4894778761917324, 3.9769249674652265, 2.85069277602249,
    1.5740327804021408, 0.36279099621600219, -0.44665146923924126,
    -0.77318636509866234, -0.80240043796124227, -0.7552851151746568,
    -0.72087317795657613, -0.65794249472949007, -0.56326861530285666,
    -0.47494462781614188, -0.41512217291832154, -0.3800683876899158,
    -0.356747800364401, -0.34173450599327443, -0.33282606278515031,
    -0.3145693292001282, -0.27782845435229303, -0.20105063854862576,
    -0.13202245999916337, -0.086248373109000881, -0.036983303328674159,
    0.038115986093815994, 0.0072711297994168317, 0.36858824250423283,
    0.57066134706869243, 0.38795430874277054, 0.43334772146357381,
    0.41762084531458876, 0.41827006565415237, 0.4145302424465786,
    0.41196535561434311, 0.40908453584572962, 0.40628726768338069,
    0.40346652669780597, 0.40065101543350512, 0.39783307645026877,
    0.39501480350104479, 0.3921956875114761, 0.38937592895399514,
    0.38655555303178618, 0.38373465006360119, 0.38091331495844061,
    0.37809166800534255, 0.37526985476861285, 0.37244805284187954,
    0.36962647862112169, 0.36680539683377195, 0.36398513351578987,
    0.36116609397724914, 0.35834878855141916, 0.35553386465698955,
    0.352722155023142, 0.34991468381652946, 0.34711273301044615,
    0.34431717460799705, 0.34152875946509559, 0.33873964543619306,
    0.33594596857210163, 0.33307333156911911, 0.33016486929433625,
    0.32728409426436628, 0.32438823277541479, 0.32148901992579326,
    0.31858362190494655, 0.31567314866413143, 0.31275769690385624,
    0.3098376816554575, 0.30691348261904611, 0.30398554178600196,
    0.30105433990581321, 0.29812040534735956, 0.29518431452733135,
    0.2922466953488731, 0.28930823133366923, 0.28636966813824949,
    0.28343182350280394, 0.28049560239760674, 0.27756201966076433,
    0.27463223279057, 0.2717075885751204, 0.26878968402212838,
    0.26588044990585025, 0.26298222169116042, 0.26009789301970909,
    0.25723260342219317, 0.25439401272309348, 0.25159022147989912,
    0.24882840775812945, 0.24611392410897348, 0.24344978518951105,
    0.24083644829802642, 0.23827181585437324, 0.23575139837438797,
    0.23326858833998768, 0.23081500455399573, 0.22838087464589008,
    0.22595543013098987, 0.22352729409492342, 0.22108484634431355,
    0.21861655490529394, 0.21611126621324597, 0.21355844932545659,
    0.21094839209897726, 0.20827234957525706, 0.20552264679224846,
    0.20269273986409631, 0.19977724037828609, 0.1967719089424467,
    0.19367362409455369, 0.19048033282490587, 0.18719098875490067,
    0.18380548368014096, 0.1803245777995508, 0.17674983361025351,
    0.17308355819529195, 0.16932875842461834, 0.16548911330483787,
    0.16156896685081365, 0.15757334324683989, 0.15350821209486273,
    0.14938074563700238, 0.14519931504027558, 0.14097345712607,
    0.1367138090460544, 0.13243200876917302, 0.1281405601805109,
    0.12385266261963894, 0.11958200592748661, 0.11534253349726932,
    0.11114817744389374, 0.1070125717924396, 0.10294875145582642,
    0.098968846643757685, 0.095083784116994613, 0.091303008288295115,
    0.08763423646112091, 0.084083263353398247, 0.080653830295960335,
    0.077347573920757112, 0.0741640675118043, 0.071100965176500872,
    0.068154254255659227, 0.06531861456073354, 0.062587873839798053,
    0.059955537250439048, 0.057415354756567373, 0.054961874981324738,
    0.052590918583670335, 0.050299891029924042, 0.048087844157628887,
    0.045955194862878773, 0.043902999010984288, 0.041931728259088565,
    0.040039332027856714, 0.0382216310149357, 0.036474032198092067,
    0.034791648732019717, 0.0331693415813241, 0.031601793837915983,
    0.030083584474322047, 0.028609266177908838, 0.027173441527423264,
    0.02577083475691935, 0.024396356131562418, 0.023045156903604595,
    0.021712673671221365, 0.020394661931127149, 0.019087219527173578,
    0.017786801498352777, 0.016490228441373937, 0.01519469085296685,
    0.013897751907120037, 0.012597350724157099, 0.01129180747022022,
    0.0099798307280709719, 0.0086605266590943711, 0.0073334086745540719,
    0.0059984057720741286, 0.0046558674023785664, 0.0033065626966216144,
    0.0019516720580085604, 0.0005927694491975735, -0.00076820582895794829,
    -0.0021289884822981472, -0.0034870376412021462, -0.0048395976495567671,
    -0.0061837679434477832, -0.0075165802504966505, -0.0088350809409549931,
    -0.010136416046432502, -0.011417916236419886, -0.012677178926623754,
    -0.013912144733345323, -0.015121165746699533, -0.016303063598908756,
    -0.017457175998875162, -0.018583391176098887, -0.019682170397386414,
    -0.020754559191166259, -0.021802188002719297, -0.022827262779322489,
    -0.0238325456711773, -0.024821325817786483, -0.025797380172383592,
    -0.02676492455793127, -0.027728555641714371, -0.028693185199323828,
    -0.029663968802802709, -0.03064623178138413, -0.031645395806287863,
    -0.0326669095528763, -0.033716186454857661, -0.03479855157979269,
    -0.035919198242107812, -0.037083153383017535, -0.0382952494363222,
    -0.039560099928106773, -0.040882076514334204, -0.042265286011027157,
    -0.0437135467546417, -0.045230364194127362, -0.046818905990500127,
    -0.048481977182500607, -0.050221996185887283, -0.052040972504807256,
    -0.053940487030464966, -0.055921675698876953, -0.057985217117926105,
    -0.060131324626919107, -0.062359743174910845, -0.064669751438659717,
    -0.067060169710395523, -0.0695293741870202, -0.072075318301569283,
    -0.074695561586507891, -0.077387306251099436, -0.080147441232727171,
    -0.082972593006070086, -0.085859181970235635, -0.088803482830548938,
    -0.09180168703844524, -0.094849965027704014, -0.097944525707310159,
    -0.10108167050256064, -0.10425783926616579, -0.10746964564024059,
    -0.11071389992035842, -0.1139876180825076, -0.11728801632412351,
    -0.12061249121503549, -0.12395858631961419, -0.12732394692247381,
    -0.1307062652128628, -0.13410321894615113, -0.13751240718928809,
    -0.14093128723229156, -0.14435711707167215, -0.14778690799168404,
    -0.15121739163761702, -0.15464500550806959, -0.1580658998392927,
    -0.16147596728166735, -0.16487089460440008, -0.16824623316588266,
    -0.17159748249098392, -0.17492017948554514, -0.17820998497530813,
    -0.18146275958288902, -0.18467462238330531, -0.18784198794265775,
    -0.1909615798448179, -0.19403042134680923, -0.197045806105618,
    -0.20000525371974964, -0.20290645593956944, -0.20574721976966914,
    -0.20852541336029864, -0.21123891971694467, -0.21388560204301094,
    -0.21646328318978106, -0.21896974037289588, -0.22140271509271886,
    -0.22375993711351835, -0.22603916043831929, -0.228238208510697,
    -0.23035502542700217, -0.23238772980190586, -0.23433466810393186,
    -0.23619446471822486, -0.23796606663331488, -0.2396487814089778,
    -0.24124230789901807, -0.24274676001732412, -0.24416268457186319,
    -0.24549107473582191, -0.24673338094832215, -0.24789152087702737,
    -0.24896788959611629, -0.24996537051248732, -0.25088734700984672,
    -0.25173771436910347, -0.2525208912167482, -0.25324182945795753,
    -0.25390602133112966, -0.25451950194148576, -0.25508884558459943,
    -0.25562115457660417, -0.25612404018955287, -0.25660559633470564,
    -0.25707436711086151, -0.25753930848592416, -0.25800974280804717,
    -0.25849530235477564, -0.25900585980085528, -0.25955143345774223,
    -0.26014209362722296, -0.2607877582198968, -0.26149650353339532,
    -0.26227448311818313, -0.26312797027055757, -0.26406409787736296,
    -0.26509079864882967, -0.26621624889842987, -0.26744810825082027,
    -0.26879275659504637, -0.27025465883070376, -0.27183592512221771,
    -0.27353608811161934, -0.27535208660023858, -0.27727842578920658,
    -0.27930747446401333, -0.281429856894456, -0.2836348993522001,
    -0.28591109612044979, -0.28824656624070549, -0.29062947902573888,
    -0.29304843290534349, -0.29549277804399288, -0.29795287811261073,
    -0.30042031047816403, -0.30288800692007395, -0.30535033892370222,
    -0.30780315287724641, -0.31024376131590609, -0.31267089680470495,
    -0.31508463513518586, -0.3174862942482895, -0.31987831478109663,
    -0.32226412749973721, -0.32464801219411776, -0.32703495205493865,
    -0.32943048671122133, -0.33184035074057494, -0.3342701891390446,
    -0.33672556981651103, -0.33921199821521669, -0.34173492111626957,
    -0.3442997146084098, -0.34691165553877057, -0.34957587790986189,
    -0.3522973163494928, -0.35508063868982337, -0.35793016936456434,
    -0.36084980513968051, -0.36384292483234176, -0.36691229514082435,
    -0.37005997535149948, -0.37328722430016847, -0.37659441340294336,
    -0.37998094986438735, -0.38344521437736157, -0.38698451776277831,
    -0.39059508095074408, -0.3942720422954924, -0.39800949527049528,
    -0.4018005581381181, -0.40563747569741765, -0.40951175254733668,
    -0.4134143184880727, -0.41733573008656277, -0.42126641752252558,
    -0.42519699148531953, -0.4291186322872208, -0.43302358760840437,
    -0.43690582555280638, -0.44076185550516767, -0.44459190433004692,
    -0.44839852934611785, -0.45218425511773386, -0.45595130208694412,
    -0.45970154976038569, -0.46343654372658832, -0.46715754282269722,
    -0.47086556610581326, -0.47456146389710835, -0.4782458850184938,
    -0.48191959764580089, -0.485582454215284, -0.48923738386192733,
    -0.49295199774369536, -0.49676833443508966, -0.50061226379036694,
    -0.50437723653533628, -0.50797035714770922, -0.51133863075506292,
    -0.51447884324039617, -0.51743674567002018, -0.52029922711753829,
    -0.52318251775126556, -0.526218657676365, -0.5295418816172629,
    -0.53327610243113555, -0.53752437921384744, -0.54236110281762906,
    -0.54782763150869118, -0.5539327846219172, -0.56065908207981618,
    -0.56796249833999857, -0.57576437926241508, -0.58394582732327494,
    -0.592344421190963, -0.60075374014311067, -0.60892605934095156,
    -0.61657854515103816, -0.62340304338793506, -0.62907913202144761,
    -0.63328945961305017, -0.63573551466500922, -0.6361513088231584,
    -0.63431353149539693, -0.63004843396438059, -0.62323613660800015,
    -0.61381294730592606, -0.60177210249905611, -0.587172340136637,
    -0.57012980651262679, -0.55080012053153848, -0.52937533818123594,
    -0.50607996066919925, -0.48116600696322959, -0.45490728117446194,
    -0.4275930327345534, -0.39952126509871355, -0.37099198761283042,
    -0.34230072522852983, -0.31373259701496686, -0.28555724627264106,
    -0.25802485899983463, -0.2313634506214301, -0.20577756224914523,
    -0.18144854955287809, -0.15853672909882169, -0.13718384187251986,
    -0.11751466438264284, -0.0996380849307992, -0.083647289415510681,
    -0.0696188158857118, -0.057610380556728069, -0.047657532959456281,
    -0.039769352409386872, -0.033923534240414416, -0.030061302709392113,
    -0.028082581035464869, -0.027841773776559806, -0.029144501062138083,
    -0.031745952043956596, -0.035350897461531645, -0.039617915728335423,
    -0.04416082447070023, -0.048682762183311946, -0.053010687474255982,
    -0.056987134629771743, -0.06046738282226017, -0.063323797184290154,
    -0.065448652604850444, -0.066757759857595855, -0.067194194017426115,
    -0.066732085791830362, -0.065380024368039913, -0.063183423240669362,
    -0.060224919879454442, -0.0566216864673891, -0.052518582649868292,
    -0.048076552319855026, -0.043457097212498186, -0.038806859717249495,
    -0.034253280869810755, -0.029906180863297965, -0.025856698013111405,
    -0.022178343893220633, -0.018929863187454387, -0.016158689840520983,
    -0.013903729305700642, -0.012196334348829524, -0.011059227162899209,
    -0.010506137823764724, -0.010536849749942437, -0.011130797566709481,
    -0.01224126433512485, -0.013813712905083909, -0.016052034039247862,
    -0.019152071219417189, -0.022925803609187671, -0.027003938882553719,
    -0.030959604797866743, -0.034396541381021987, -0.037002339225700481,
    -0.03857680947214092, -0.039041324769415964, -0.03843464573471464,
    -0.036899565070986136, -0.034663909472530327, -0.032018677846869154,
    -0.02929544481112337, -0.026844592052728031, -0.02501545252992398,
    -0.02413906281217143, -0.024513913564835, -0.026394857778002764,
    -0.029985170164379616, -0.035431635593279033, -0.042822465141327433,
    -0.052187785480592115, -0.063502412378312958, -0.076690593397087475,
    -0.091632383587780919, -0.10817129904909854, -0.12612287319794172,
    -0.14528371543000279, -0.16544064553287069, -0.18637979514549494,
    -0.20789457127059122, -0.22979166702046741, -0.2518955530802684,
    -0.27405151661894106, -0.29616556942650862, -0.31819376312442532,
    -0.34009047750268784, -0.36180393858981569, -0.38327201708062864,
    -0.40441861845008148, -0.42515101175847714, -0.44535834213843434,
    -0.46491146303700775, -0.48366411116262215, -0.50145536731362561,
    -0.51811331148715456, -0.53345978896938739, -0.54731623592769552,
    -0.55951053314949262, -0.56988483479015783, -0.57830424495441757,
    -0.58466609104156486, -0.58890937815073507, -0.59102381819171668,
    -0.59105763862502536, -0.5891232435853, -0.5853997824647087,
    -0.5801317982438623, -0.5736233541590765, -0.56622730349854211,
    -0.55832960583366364, -0.550328734440201, -0.54261035933712509,
    -0.53551727654365477, -0.52931929278849355, -0.524178558350279,
    -0.52010035535909915, -0.51688046754884609, -0.51402173391197725,
    -0.51117295121055939, -0.5083235286440444, -0.50547649339488443,
    -0.50263126026085359, -0.49978824923548776, -0.49694764769589039,
    -0.49410974029217553, -0.49127481759825431, -0.48844319660235036,
    -0.48561521040752437, -0.48279120560694239, -0.47997153727265651,
    -0.47715656444882026, -0.47434664550486388, -0.47154213358968211,
    -0.46874337211640671, -0.46595069020971369, -0.46316439794390835,
    -0.460384781077926, -0.45761209478642545, -0.45484655557931125,
    -0.45208833010038629, -0.44933751900138891, -0.44659413288685079,
    -0.44385805859725852, -0.44112900745732242, -0.43840646443415549,
    -0.43568990771230581, -0.43297879145902735, -0.43027216685809189,
    -0.42756850656985934, -0.4248656612602173, -0.42216091540703859,
    -0.41945110758783083, -0.41673278858405671, -0.414002395312247,
    -0.41125642345694713, -0.40849158578123779, -0.40570494670939744,
    -0.40289402704895438, -0.40005687614616181, -0.3971921116829365,
    -0.39429892915725689, -0.39137708440482155, -0.38842685358630258,
    -0.38544897598793532, -0.3824445857111694, -0.37941513863400456,
    -0.37636234067086966, -0.37328808237319006, -0.37019438359423684,
    -0.36708335060047625, -0.36395714688231245, -0.36081797808809918,
    -0.35766809091216989, -0.354509785242182, -0.35134543825720405,
    -0.34817753839339505, -0.34500872619500594, -0.34184183814660896,
    -0.33867994876879293, -0.33552640586014126, -0.33238489515466146,
    -0.32925948578403597, -0.32615461426023878, -0.32307505244647527,
    -0.32002586040141823, -0.31701232564152737, -0.31403989104524815,
    -0.3111140742660955, -0.30824038219268174, -0.30542422464879132,
    -0.30267083193505151, -0.29998518074613251, -0.29737193243518589,
    -0.29483538655664082, -0.29237945097910623, -0.29000762793047041,
    -0.28772301384077553, -0.2855283099683959, -0.2834258402089247,
    -0.2814175719592415, -0.27950513549168865, -0.27768983728664443,
    -0.27597266339428561, -0.27435426995853346, -0.2728349591628208,
    -0.27141463983966363, -0.27009277289871486, -0.26886830277571694,
    -0.26773957733057607, -0.26670425978837375, -0.26575923643049071,
    -0.26490052247565321, -0.26412316086471033, -0.26342110570118132,
    -0.26278703559526323, -0.2622126109769008, -0.26168895400421077,
    -0.26120682640008192, -0.26075679372190308, -0.26032938960046675,
    -0.25991526695754935, -0.2595053315418418, -0.25909085294720668,
    -0.258663551000934, -0.25821565757435333, -0.25773995582701753,
    -0.25722979994951545, -0.25667911847727748, -0.25608240413916022,
    -0.25543469329995949, -0.25473153782249131, -0.25396897182700295,
    -0.25314347549716554, -0.25225193780621569, -0.25129161993009691,
    -0.250260121204378, -0.24915534954473303, -0.24797549805162675,
    -0.24671902891266378, -0.24538466472533219, -0.24397138619199452,
    -0.24247843406924771, -0.24090531256867362, -0.23925179124574603,
    -0.23751790274924275, -0.2357039344966258, -0.23381041323750767,
    -0.23183808246369753, -0.22978787362896289, -0.2276608730575157,
    -0.22545828714378047, -0.22318140890756491, -0.22083158914969225,
    -0.21841021534585833, -0.21591870100289565, -0.21335848740939381,
    -0.21073105849002444, -0.20803796788713641, -0.20528087565711703,
    -0.20246159046310422, -0.19958211214634319, -0.19664466918154042,
    -0.19365174589200809, -0.19060609538325141, -0.18751073545801467,
    -0.18436892589088666, -0.18118412661473618, -0.17795993790946571,
    -0.17470002544071214, -0.17140803451777817, -0.16808749877751195,
    -0.164741748607245, -0.16137382437644968, -0.15798639932191688,
    -0.15458171680035218, -0.15116154642723556, -0.14772716316052609,
    -0.14427935254540727, -0.14081844409158467, -0.13734437311710135,
    -0.13385676945282371, -0.13035506933991214, -0.1268386449966688,
    -0.12330694501325783, -0.11975963807591024, -0.11619675242548341,
    -0.11261880381885161, -0.10902690552836282, -0.10542285500976997,
    -0.10180919324563756, -0.098189234349852758, -0.094567064671385759,
    -0.090947512204892333, -0.0873360885593071, -0.083738907083279232,
    -0.0801625819830486, -0.076614114263712854, -0.073100770835051732,
    -0.069629962970654949, -0.066209129508937078, -0.062845628883628574,
    -0.059546642506628465, -0.05631909045219273, -0.053169558991895148,
    -0.050104238442507207, -0.047128869124760574, -0.044248693036241772,
    -0.041468409092390725, -0.038792130362582958, -0.036223342453531877,
    -0.03376486293709284, -0.031418802380676028, -0.029186528057210261,
    -0.027068631805341515, -0.025064903820090263, -0.023174314400322225,
    -0.021395005839715295, -0.01972429669470915, -0.018158700559331085,
    -0.016693961180744506, -0.015325105238063786, -0.014046513368583577,
    -0.012852009075879902, -0.011734964056462798, -0.01068841732931056,
    -0.0097052044627789127, -0.0087780922833185625, -0.0078999137957202464,
    -0.0070636977097626522, -0.0062627869818344213, -0.0054909411723810322,
    -0.0047424182073441618, -0.0040120322724370144, -0.003295185971863946,
    -0.0025878763822985654, -0.001886676064163092, -0.001188691330311777,
    -0.0004915010398781008, 0.00020692012117786655, 0.00090828946367172867,
    0.0016141105408628111, 0.00232576899085127, 0.0030446251628816292,
    0.0037720989091053364, 0.00450974236152001, 0.00525929726251389,
    0.0060227345613314606, 0.0068022755164676109, 0.007600395299298051,
    0.0084198117643260167, 0.0092634632244923739, 0.010134479455493669,
    0.011036149678641432, 0.011971890126378632, 0.012945212355482218,
    0.013959692140538139, 0.015018937827203663, 0.016126556617024338,
    0.017286117441449353, 0.018501109748184093, 0.019774898412722286,
    0.021110675820858137, 0.022511412784269703, 0.023979810285855597,
    0.025518254083591482, 0.027128773977216931, 0.028813009142755277,
    0.030572180514912242, 0.0324070707950931, 0.034318012252260735,
    0.036304882059890325, 0.038367104515569218, 0.040503659196992517,
    0.042713093942084272, 0.044993541495617975, 0.047342738683974886,
    0.049758046998206608, 0.052236473441330478, 0.054774690438540066,
    0.057369053610217921, 0.060015616311689418, 0.062710140252680846,
    0.065448101852168428, 0.0682246959670097, 0.071034835999556,
    0.073873165035913527, 0.07673403960168626, 0.079611648122974069,
    0.082502362132957766, 0.0854051513691691, 0.088318751647262064,
    0.0912400020593414, 0.09416301766132297, 0.097079075157176981,
    0.099977013746789647, 0.10284397595237932, 0.10566632787617646,
    0.1084306269813702, 0.11112453579060187, 0.11373761012578845,
    0.11626191778488461, 0.11869246674366775, 0.12102744053078333,
    0.12326825235727445, 0.12541943921435933, 0.12748842303601557,
    0.12948516879941555, 0.1314217697727863, 0.13331198866732519,
    0.13517078079506062, 0.13701382195099013, 0.13885705996333444,
    0.14071630491977488, 0.14260686910643361, 0.14454326375278259,
    0.14653895579533588, 0.14860618419392371, 0.15075583211699878,
    0.15299734887513855, 0.15533871409142683, 0.1577864363371968,
    0.16034557892955967, 0.16301980703221564, 0.16581177595398172,
    0.16872349234185527, 0.17175629160761324, 0.17491077171644562,
    0.17818669583725072, 0.18158287631433437, 0.18509705177124786,
    0.18872576805268793, 0.19246427269316044, 0.19630643172107298,
    0.20024467681968094, 0.20426999005115656, 0.20837193238366974,
    0.21253872109987781, 0.21675735983580346, 0.22101382352369603,
    0.22529329886725513, 0.22958047911388707, 0.23385990978581267,
    0.23811637970211555, 0.24233534909624022, 0.246503403924527,
    0.25060872254372546, 0.2546415377024801, 0.25859457301619443,
    0.26246342847829113, 0.26624688380141481, 0.26994708124462108,
    0.27356954070314721, 0.27712294962297213, 0.2806186568654665,
    0.28406979057781473, 0.28748988865294556, 0.29089097787296941,
    0.29428078560213794, 0.29766339557546817, 0.30104185717397025,
    0.3044185203462188, 0.30779520514196318, 0.31117335939175372,
    0.31455416613452641, 0.31793862070535112, 0.32132758254485189,
    0.32472181097246816, 0.32812198536420223, 0.33152873156444324,
    0.33494259059553466, 0.33836418016036918, 0.34179362209257674,
    0.34523270005029444, 0.3487066572184469, 0.35222920209921671,
    0.35573939471702964, 0.35924585199435671, 0.36247291219494637,
    0.3654379547680594, 0.36866980832225121, 0.37223042613761348,
    0.37595622854142946, 0.3797637727291614, 0.3836048769396444,
    0.38745747888078297, 0.39131056192556479, 0.39515892366113659,
    0.399000149534095, 0.4028333302336769, 0.40665838511724184,
    0.41047571882519335, 0.41428602458058122, 0.41809016620027156,
    0.42188910205789121, 0.42568383405649374, 0.42947537312928208,
    0.43326471423689816, 0.43705282593651207, 0.44084062286876641,
    0.44462903122312775, 0.44841873100639984, 0.45221112453106554,
    0.45600474599949242, 0.4598087007943949, 0.46359256360588597,
    0.46747342951584553, 0.471017912404167, 0.47584721979893491,
    0.47591608538203806, 0.49379580609809287, 0.4452590846371034,
    0.64464825043820029, 0.63351588041431806, 0.55634006670701819,
    0.44069733535259886, -0.16557237630946886, -0.72107774699148874,
    -1.1627509529221198, -1.4237263978194519, -1.4492371963875477,
    -1.1895327951641557, -0.79768951198032012, -0.62941517879758524,
    -0.87347033392943418, -1.094834061444345, -0.89748244539536715,
    -0.26414607738118129, 0.69861506735428391, 1.781969057384114,
    2.966843660320714, 4.4894008158339327, 6.5509028432719782,
    7.3093653923050645, 7.0627577036428368, 7.3558716789569818,
    7.6477234933283382, 7.9061093245698828, 0.01125959707921494,
    0.051610613660123823, 0.090194733849284378, 0.1269046488230432,
    0.16152491631132485, 0.19377244540195954, 0.22351724852648303,
    0.25194548186029248, 0.27911791453180179, 0.30068444698792512,
    0.3146612645566681, 0.32062127467493068, 0.32006716309450367,
    0.31601528003104856, 0.31096462141054448, 0.30608194932821658,
    0.30143729549932113, 0.29707391129199484, 0.29322761938615582,
    0.28997527129408468, 0.287193561643712, 0.28470154311032281,
    0.282388102013345, 0.28019661435265086, 0.27807664212905769,
    0.2760296107075107, 0.27415844224947161, 0.27261875770295324,
    0.27161318935801404, 0.27090930182962919, 0.27053559423898949,
    0.27049825194666755, 0.27079294229471518, 0.27141187939317546,
    0.27509554148257187, 0.27778351136093005, 0.28045380984355794,
    0.28310643232102373, 0.28574137374224362, 0.28835862878808405,
    0.29095819199893447, 0.2935400578676951, 0.29610422090795896,
    0.29865067570577186, 0.30117941696208855, 0.30369043953195213,
    0.30618373846545993, 0.30865930905476774, 0.31111714689071668,
    0.31355724793218576, 0.31597960859101043, 0.31838422583529391,
    0.32077109731431297, 0.32314022150906058, 0.32549159791401938,
    0.32782522725832358, 0.33014111177846744, 0.33243925556078452,
    0.33471966498062367, 0.33698234927667614, 0.33922732131096545,
    0.34145459856713334, 0.34366420439490686, 0.34585616930001084,
    0.34803053135806122, 0.35018733264918106, 0.35232660293279339,
    0.35444831199847848, 0.35655228478839768, 0.35863794952999306,
    0.36070547007310638, 0.36275480801618432, 0.364785926266219,
    0.36679878921602643, 0.36879336293789722, 0.37076961539433312,
    0.37272751666566506, 0.37466703919360356, 0.37658815803937296,
    0.3784908511551337, 0.38037509966801131, 0.38224088817739016,
    0.3840882050683212, 0.38591704284721368, 0.38772739851076471,
    0.38951927396581704, 0.39129267652713473, 0.39304761953259582,
    0.39478412313131062, 0.39650221531902841, 0.398201933313778,
    0.39988332537514337, 0.40154645315695703, 0.40319139461828046,
    0.40481825135019306, 0.40642716653694094, 0.40801833376236762,
    0.40959199524923362, 0.41114843298072778, 0.41268795543488218,
    0.41421088205599915, 0.41571752707964288, 0.41720818390643533,
    0.41868311087311227, 0.42014251898659577, 0.42158656195888511,
    0.42301532869898489, 0.42442883827544586, 0.42582703725317589,
    0.42720979922588315, 0.42857692630673822, 0.42992815230131226,
    0.43126314726586384, 0.43258152314849496, 0.43388284021861634,
    0.43516661400942253, 0.43643232252626263, 0.4376794135082327,
    0.43890731156839952, 0.44011542507741569, 0.44130315269403475,
    0.44246988948304633, 0.44361503259583224, 0.44473798652109719,
    0.44583816794380221, 0.44691501027941249, 0.447967967978186,
    0.44899652071868185, 0.45000017762608713, 0.45097848213401254,
    0.45193101899823168, 0.45285742186383809, 0.45375738071734184,
    0.45463064903008021, 0.45547705038412944, 0.45629648436143211,
    0.45708893147243285, 0.45785445690321847, 0.45859321287129046,
    0.45930543940076052, 0.45999146335920293, 0.46065169564135244,
    0.46128662643962648, 0.46189681860773785, 0.46248289920056695,
    0.46304554935947845, 0.46358549280510941, 0.46410348329606466,
    0.46460029150741838, 0.46507669187157807, 0.46553344999823304,
    0.46597131134010156, 0.46639099178497323, 0.46679317081806354,
    0.46717848779675192, 0.46754754169750129, 0.46790089441995031,
    0.46823907736039744, 0.46856260050248405, 0.46887196273506843,
    0.46916766152513456, 0.46945019948341549, 0.46972008479419058,
    0.46997782193808424, 0.47022389413023946, 0.47045875687553679,
    0.47068283586508686, 0.47089652521967279, 0.47110018614254395,
    0.47129414602798797, 0.47147869805160186, 0.47165410124590584,
    0.47182058104305968, 0.47197833024695318, 0.47212751038144307,
    0.47226825335126371, 0.47240066334781322, 0.472524818933593,
    0.47264077524610448, 0.47274856627349543, 0.47284820716881726,
    0.47293969658544022, 0.47302301903055782, 0.47309814724452987,
    0.4731650446194573, 0.47322366767023566, 0.47327396856569076,
    0.47331589771742033, 0.47334940641131795, 0.47337444945308449,
    0.47339098778584743, 0.4733989910264057, 0.47339843985751806,
    0.47338932820786483, 0.47337166514952517, 0.47334547644520664,
    0.47331080568374756, 0.47326771495205494, 0.47321628500406726,
    0.47315661490201011, 0.47308882112159384, 0.47301303613027845,
    0.472929406465475, 0.4728380903563929, 0.47273925494767888,
    0.47263307319361186, 0.47251972049755347, 0.47239937117253206,
    0.47227219479612564, 0.47213835252833952, 0.47199799345720095,
    0.471851251034676, 0.47169823966509, 0.47153905150862035,
    0.47137375356209882, 0.47120238507672818, 0.47102495536590927,
    0.47084144204537215, 0.47065178973205962, 0.47045590920856828,
    0.47025367703827831, 0.47004493559567151, 0.46982949346019354,
    0.46960712611353039, 0.46937757688126819, 0.46914055807043603,
    0.468895752270834, 0.46864281380431982, 0.46838137031800969,
    0.46811102452389, 0.46783135608958626, 0.46754192368442288,
    0.46724226718224227, 0.46693191001824519, 0.46661036169187214,
    0.46627712040217628, 0.46593167579690875, 0.4655735118121806,
    0.46520210957621572, 0.46481695034808534, 0.46441751845984608,
    0.46400330422752117, 0.46357380679269461, 0.46312853685240568,
    0.46266701923138931, 0.46218879524851869, 0.46169342482944409,
    0.46118048832041741, 0.46064958796427868, 0.460100349008309,
    0.45953242042473741, 0.45894547523790763, 0.4583392104672428,
    0.45771334671173253, 0.45706762741873236, 0.45640181789600903,
    0.45571570413980883, 0.45500909156210462, 0.45428180370647492,
    0.453533681043818, 0.45276457993610564, 0.45197437184853317,
    0.45116294287783887, 0.45033019364764881, 0.44947603960080845,
    0.44860041169442416, 0.447703257476545, 0.446784542495214,
    0.44584425196241539, 0.44488239256907658, 0.4438989943252743,
    0.44289411228570347, 0.44186782801818608, 0.44082025068558911,
    0.43975151763975395, 0.43866179446775982, 0.43755127448105624,
    0.43642017768990116, 0.43526874935179261, 0.43409725821729683,
    0.43290599461654555, 0.43169526853356915, 0.43046540780417003,
    0.42921675654853764, 0.42794967391608923, 0.42666453318165543,
    0.42536172119367022, 0.42404163814044227, 0.42270469757263157,
    0.42135132660028629, 0.41998196617138722, 0.41859707133547691,
    0.41719711139981697, 0.41578256989570983, 0.41435394428793459,
    0.4129117453792211, 0.41145649638252813, 0.40998873165461919,
    0.40850899510318589, 0.4070178382950963, 0.4055158183042209,
    0.40400349534318825, 0.40248143022414634, 0.40095018168941787,
    0.39941030364463886, 0.39786234231620327, 0.39630683334386013,
    0.39474429881042056, 0.3931752442052095, 0.39160015531639641,
    0.39001949504890226, 0.38843370016835294, 0.38684317797716505,
    0.38524830293640927, 0.38364941325660062, 0.38204680749123332,
    0.38044074117650734, 0.3788314235662093, 0.37721901450990464,
    0.37560362151651322, 0.37398529704014688, 0.37236403602842383,
    0.37073977378845746, 0.36911238424970622, 0.36748167873007032,
    0.36584740533550264, 0.36420924913856928, 0.36256683702976505,
    0.36091975266041271, 0.35926754123373672, 0.35760970593850383,
    0.35594570237901613, 0.35427493512498931, 0.35259675852523648,
    0.35091048239916234, 0.3492153821750818, 0.34751071243057596,
    0.34579572251737933, 0.34406967292615664, 0.34233185117936321,
    0.34058158626341656, 0.33881826087181954, 0.33704132099170669,
    0.33525028260388595, 0.33344473546775738, 0.33162434412202219,
    0.32978884634945155, 0.32793804943215804, 0.32607182456785438,
    0.32419009983385488, 0.3222928520807376, 0.32038009811778984,
    0.31845188552260151, 0.31650828337088982, 0.31454937314241305,
    0.31257524001690662, 0.31058596473265815, 0.30858161614152313,
    0.30656224455906422, 0.30452787597752889, 0.30247850718251579,
    0.30041410179107336, 0.29833458766394649, 0.2962398568797362,
    0.2941297662648702, 0.29200413782884443, 0.28986275913742604,
    0.28770538371054938, 0.28553173154828582, 0.28334148988478913,
    0.28113431425828678, 0.27890982997184577, 0.27666763400786537,
    0.27440729744924885, 0.27212836845044641, 0.26983037578981744,
    0.26751283301943507, 0.26517524320905395, 0.26281710425824528,
    0.26043791472573269, 0.2580371800984429, 0.25561441939518686,
    0.2531691719719088, 0.25070100436881343, 0.2482095170172145,
    0.24569435060915418, 0.2431551919276633, 0.24059177893768052,
    0.23800390493869553, 0.23539142156665238, 0.23275424039199832,
    0.23009233278555749, 0.2274057276096694, 0.22469450613404693,
    0.22195879336794369, 0.21919874473506903, 0.21641452668705838,
    0.2136062947017911, 0.21077418801696662, 0.2079183309230172,
    0.20503883480399224, 0.20213580029339306, 0.19920931923450413,
    0.19625947632750296, 0.19328635044806272, 0.19029001566890175,
    0.18727054203152912, 0.18422799611588306, 0.18116244144955621,
    0.17807377861200094, 0.17496140987148781, 0.1718248969404,
    0.1686643989860572, 0.16548072140738249, 0.16227513687338416,
    0.15904909668925427, 0.155803915664057, 0.15254048601223749,
    0.14925905430171332, 0.14595907906146349, 0.14263917447798116,
    0.13929713678912567, 0.13593004356783689, 0.13253441105980174,
    0.1291063902289889, 0.12564197604259769, 0.12213719544552908,
    0.11858826380184252, 0.11499177879773621, 0.11134495695508202,
    0.10764589844341468, 0.10389386387140027, 0.10008954431380902,
    0.096235303509119713, 0.092335369761144162, 0.08839595569942664,
    0.084425288043433022, 0.080433538310138844, 0.076432659493364627,
    0.072436147675105339, 0.068458750429372134, 0.064516140384460754,
    0.06062456821358278, 0.056800506171378259, 0.053060272036416119,
    0.049419616168884774, 0.045893432951095312, 0.042495521584842447,
    0.039238368958761149, 0.036132960615657218, 0.033188625328663839,
    0.03041291776386764, 0.027811542268637534, 0.025388319086030963,
    0.023145192367814028, 0.021082277377933108, 0.0191979423987374,
    0.017488919211947705, 0.015950434711209462, 0.01457635521699352,
    0.013359334105000958, 0.012290951932098009, 0.011361840295229969,
    0.010561793420889254, 0.0098798710922212186, 0.00930449744572778,
    0.0088235620659573577, 0.0084245308788938218, 0.0080945744721756217,
    0.0078207206183469758, 0.007590035998464216, 0.0073898396193943774,
    0.0072079476252743559, 0.007032946725962318, 0.0068544913499713157,
    0.0066636167537239008, 0.0064530568027024874, 0.0062175515673528617,
    0.0059541266368651263, 0.005662098749222258, 0.0053421553721399381,
    0.0049960168560910971, 0.0046263573567944761, 0.0042367085596890577,
    0.0038313442129884923, 0.0034151434687225545, 0.0029934312705428997,
    0.0025717948777467751, 0.0021558775084711337, 0.0017511534191224822,
    0.0013626937358794423, 0.00099493886059951429, 0.00065150037168500846,
    0.00033502081486251443, 4.711981440050799E-5, -0.00021155928415054492,
    -0.00044123236075963224, -0.00064286245776512367, -0.00081804465335508366,
    -0.00096889062622499474, -0.0010979261485984384, -0.0012080090913774892,
    -0.0013022677289427319, -0.0013840513676956644, -0.0014568804070993324,
    -0.0015243892169002878, -0.0015902605193413796, -0.0016581125377775018,
    -0.0017313571381795219, -0.0018130633254111992, -0.0019065151323366082,
    -0.002016787632436129, -0.0021488404665941582, -0.0023058083378351504,
    -0.002488264895845384, -0.0026941601334220843, -0.0029191947796719997,
    -0.0031574485226489907, -0.0034021235091385013, -0.0036463016279197004,
    -0.0038836445931316296, -0.0041089906464167195, -0.0043188214893768494,
    -0.0045115884508554263, -0.0046878984550704963, -0.0048505686369230711,
    -0.0050045640027205854, -0.0051568359056860308, -0.0053160807973467216,
    -0.0054924391664286131, -0.0056971541497609062, -0.005942208266555218,
    -0.00623995528232271, -0.0066027624927823322, -0.0070426768152826221,
    -0.0075711260260396948, -0.0081986643065597824, -0.00893476896810592,
    -0.0097876927877451, -0.010764373786807297, -0.011870402240352814,
    -0.013110042625821473, -0.014486299096858573, -0.016001013949628214,
    -0.017654989734428469, -0.019448206289599042, -0.021380261491913431,
    -0.023450473942207655, -0.025657858266605823, -0.028001072995207186,
    -0.030478343664643547, -0.033087366015684044, -0.035825196008588515,
    -0.03868813459463738, -0.041671615669381004, -0.044770105504638419,
    -0.047977021464343482, -0.051284677239338411, -0.054684261407702293,
    -0.058165855883638574, -0.061718500579236536, -0.065330310064161165,
    -0.068988646843329018, -0.072680353794020408, -0.076392045098825079,
    -0.080110450592613486, -0.083822802977266408, -0.087517251398608123,
    -0.091183279235925119, -0.09481209941546824, -0.0983969976168557,
    -0.10193359240916484, -0.10541998126582772, -0.10885674205436388,
    -0.1122467605288625, -0.11559486343422556, -0.11890725773036612,
    -0.12219070667045069, -0.1254513733191685, -0.12869327715901327,
    -0.13191724764686008, -0.13512329458926078, -0.13831142868081972,
    -0.14148166168354298, -0.1446340066115242, -0.14776847791478429,
    -0.15088509165603428, -0.15398386567438166, -0.1570648197306104,
    -0.16012797562961392, -0.16317335731676008, -0.16620099094621443,
    -0.16921090492032967, -0.17220312989992761, -0.17517769878574185,
    -0.17813464667137005, -0.18107401076777757, -0.18399583029862157,
    -0.18690014636423843, -0.18978700176968974, -0.19265644080820038,
    -0.19550850898481573, -0.19834325265515657, -0.20116071853993,
    -0.20396095305746378, -0.20674400139653998, -0.20950990623766497,
    -0.21225870675138547, -0.21499043901818501, -0.2177051345481083,
    -0.22040281711850954, -0.22308349893596827, -0.22574717685847107,
    -0.22839382918636375, -0.23102341334172319, -0.2336358646019942,
    -0.23623109593132993, -0.23880899885846466, -0.24136944527971538,
    -0.24391229001690634, -0.24643737393199097, -0.24894452739305223,
    -0.25143357389380966, -0.25390433364591281, -0.25635662698786427,
    -0.25879027748520667, -0.26120511463267493, -0.26360097610849154,
    -0.26597770957040479, -0.26833517401813944, -0.27067324077458516,
    -0.27299179415718333, -0.27529073192224823, -0.27756996557007235,
    -0.279829420599378, -0.28206903679697914, -0.28428876864229052,
    -0.28648858589575038, -0.28866847442433013, -0.290828437295635,
    -0.29296849614488596, -0.29508869278781213, -0.29718909110697789,
    -0.29926977937608568, -0.30133087262952174, -0.30337251488050032,
    -0.30539488108957258, -0.30739817879283948, -0.30938264931110682,
    -0.31134856847721931, -0.31329624683893409, -0.31522602931904292,
    -0.31713829434233037, -0.31903345246796194, -0.32091194459288536,
    -0.32277423981379527, -0.32462083304885958, -0.32645224252239874,
    -0.32826900720659929, -0.33007168429789663, -0.33186084678480632,
    -0.33363708113967061, -0.33540098513940897, -0.3371531657914289,
    -0.33889423731384843, -0.34062481909768405, -0.3423455335642257,
    -0.34405700382305826, -0.34575985103427087, -0.34745469138254143,
    -0.34914213258213656, -0.35082276985093219, -0.35249718131549634,
    -0.354165922829076, -0.35582952218167957, -0.35748847262759109,
    -0.35914322551446942, -0.36079418254066009, -0.36244169115691482,
    -0.36408604176048692, -0.36572746593869632, -0.367366135757744,
    -0.36900216404499558, -0.37063560557018332, -0.3722664589972931,
    -0.37389466945783112, -0.37552013158949371, -0.37714269289116342,
    -0.37876215726165524, -0.38037828860949774, -0.38199081443957683,
    -0.38359942934163654, -0.38520379832425511, -0.38680355995459459,
    -0.3883983292787514, -0.38998770051015125, -0.39157124948473765,
    -0.39314853589303561, -0.39471910531113874, -0.39628249106430069,
    -0.39783821596596836, -0.39938579397913904, -0.40092473184404548,
    -0.40245453070607812, -0.40397468776211487, -0.40548469792500885,
    -0.40698405548816952, -0.40847225575768481, -0.40994879661001143,
    -0.41141317992983439, -0.41286491288561883, -0.41430350900938373,
    -0.41572848906145327, -0.41713938167890424, -0.41853572382641985,
    -0.41991706108848337, -0.42128294786045029, -0.4226329475109053,
    -0.42396663259624229, -0.42528358520803589, -0.42658339752280233,
    -0.42786567260233854, -0.42913002546349355, -0.43037608440249125,
    -0.43160349252510805, -0.43281190940486058, -0.43400101277013647,
    -0.43517050010759734, -0.43632009006250905, -0.4374495235184605,
    -0.43855856425130124, -0.43964699907508575, -0.44071463742838196,
    -0.44176131038269351, -0.44278686908745352, -0.44379118269714923,
    -0.44477413585617515, -0.44573562584613491, -0.446675559527476,
    -0.44759385023042952, -0.44849041476675144, -0.44936517074121379,
    -0.45021803433790969, -0.45104891873986447, -0.451857733311313,
    -0.4526443836327827, -0.45340877243366851, -0.45415080141929226,
    -0.45487037394255925, -0.455567398427084, -0.45624179241126706,
    -0.45689348705324118, -0.45752243191636405, -0.4581285998449609,
    -0.45871199174023658, -0.45927264105595522, -0.45981061785192318,
    -0.46032603226991037, -0.46081903733036667, -0.46128983098689841,
    -0.46173865741523762, -0.46216580755015924, -0.46257161891381138,
    -0.46295647479977869, -0.46332080288806, -0.46366507336758261,
    -0.46398979663642193, -0.4642955206378907, -0.4645828278759519,
    -0.4648523321389047, -0.46510467494847818, -0.46534052174381491,
    -0.46556055780685573, -0.46576548393713807, -0.465956011889242,
    -0.46613285959418138, -0.46629674619629707, -0.46644838694921037,
    -0.46658848802770303, -0.46671774132634991, -0.46683681932955073,
    -0.46694637015017493, -0.46704701284408279, -0.46713933311389705,
    -0.46722387951619304, -0.46730116028057295, -0.46737164083627086,
    -0.46743574212198291, -0.46749383972833458, -0.46754626389115589,
    -0.46759330031935259, -0.46763519180576812, -0.46767214053528394,
    -0.46770431097398124, -0.46773183319885636, -0.46775480651131462,
    -0.46777330317063465, -0.46778737208584142, -0.46779704231513464,
    -0.46780232623967644, -0.46780322230141597, -0.46779971722107078,
    -0.46779178764103863, -0.46777940116798367, -0.46776251682024161,
    -0.46774108491494687, -0.46771504645761031, -0.4676843321209832,
    -0.46764886091827312, -0.46760853868551921, -0.46756325648727548,
    -0.46751288904806826, -0.46745729329129071, -0.46739630704136809,
    -0.46732974791952658, -0.46725741244324109, -0.46717907532755332,
    -0.46709448898345712, -0.46700338321285317, -0.4669054651082209,
    -0.46680041917448895, -0.46668790769713214, -0.46656757138202004,
    -0.46643903028848693, -0.46630188506844755, -0.46615571851271143,
    -0.46600009739283826, -0.4658345745747054, -0.46565869136979987,
    -0.46547198008278656, -0.46527396670898946, -0.46506417373308734,
    -0.46484212298058569, -0.46460733847653857, -0.46435934927108413,
    -0.46409769219790442, -0.46382191453891158, -0.46353157657569727,
    -0.46322625401536821, -0.46290554028548087, -0.46256904870015847,
    -0.46221641450709217, -0.46184729683239012, -0.46146138054612418,
    -0.46105837807431921, -0.46063803118112756, -0.4602001127360017,
    -0.45974442846379804, -0.45927081865237468, -0.45877915976721528,
    -0.45826936027038812, -0.45774134139943, -0.4571950305135577,
    -0.45663036823846886, -0.45604732342873522, -0.4554459109761313,
    -0.45482620862475542, -0.45418837010438751, -0.45353263296337787,
    -0.45285932040267429, -0.45216883714805844, -0.45146165994044529,
    -0.45073832358535526, -0.44999940370475133, -0.44924549740511305,
    -0.44847720304422284, -0.44769510017387293, -0.44689973058198268,
    -0.44609158117700071, -0.44527106926742549, -0.44443853060306571,
    -0.4435942103716653, -0.44273825719070847, -0.44187072000307565,
    -0.44099154767841131, -0.4401005910401653, -0.439197606981279,
    -0.43828226429912154, -0.43735415087181045, -0.43641278181141885,
    -0.435457608260903, -0.43448802654505136, -0.43350338743440403,
    -0.43250300532867458, -0.43148616720844607, -0.43045214055545827,
    -0.42940017819206033, -0.42832952240580546, -0.42723940935977706,
    -0.4261290740238472, -0.42499775578343812, -0.42384470480553377,
    -0.42266918917090096, -0.42147050271741454, -0.42024797348128462,
    -0.41900097257008195, -0.41772892325351713, -0.41643131001553912,
    -0.41510768727562736, -0.41375768745931257, -0.41238102807894983,
    -0.41097751747653555, -0.40954705888214427, -0.40808965245581891,
    -0.40660539500895609, -0.40509447714473157, -0.4035571776170781,
    -0.40199385478536459, -0.40040493513881675, -0.39879089898349979,
    -0.397152263529693, -0.39548956379497041, -0.39380333195624873,
    -0.39209407605209751, -0.3903622592653922, -0.38860828141686604,
    -0.38683246478201694, -0.38503504691450607, -0.38321618382441863,
    -0.38137596762679249, -0.3795144557547323, -0.37763168348385556,
    -0.3757276691870966, -0.37380241822476279, -0.37185592574490045,
    -0.36988817867040819, -0.36789915710633153, -0.36588883534668143,
    -0.36385718261064481, -0.36180416359848921, -0.35972973892819293,
    -0.35763386549315862, -0.355516496767283, -0.353377583074261,
    -0.3512170718318634, -0.34903484522853973, -0.34683060651437714,
    -0.34460419775680828, -0.34235578644144105, -0.34008584805714548,
    -0.337796807278406, -0.33548846308839586, -0.33315863910226928,
    -0.3308058490237521, -0.32842933329424107, -0.32602874932208126,
    -0.32360396278984671, -0.32115494022844537, -0.31868169686573955,
    -0.31618427101825364, -0.31366271097539078, -0.31111706791028204,
    -0.30854739184663438, -0.30595372928000836, -0.30333612176145575,
    -0.30069460508003937, -0.29802920883845585, -0.29533995629520748,
    -0.2926268643889311, -0.28988994388443756, -0.28712919959461281,
    -0.28434463064180143, -0.28153623072873107, -0.27870398839354737,
    -0.27584788722663611, -0.27296790602897814, -0.27006401889296477,
    -0.26713619518698939, -0.26418439942478805, -0.26120859099937555,
    -0.25820872147304608, -0.25518472625662725, -0.25213653044598816,
    -0.24906406014952182, -0.24446888924746479, -0.2412335553663657,
    -0.23755136117746142, -0.23671864115200839, -0.23952766073409815,
    -0.24555039358655492, -0.25377501498925031, -0.26296572648584121,
    -0.27140694531993026, -0.27765177146557457, -0.28190975188315492,
    -0.28643359856064154, -0.29284951877198229, -0.29932762780236027,
    -0.30322486681951527, -0.301959671711999, -0.29418420123621442,
    -0.27933153570311731, -0.25615647583608236, -0.22172969587489449,
    -0.17648481068551364, -0.13189267856549955, -0.08651121581756234,
    -0.03936618582701671, 0.009618951131527876 },

  // Variable: ModelParam_pu_kD
  //  Referenced by: '<S170>/aerodynamic coefficients'

  20.0,

  // Variable: ModelParam_pu_kL
  //  Referenced by: '<S170>/aerodynamic coefficients'

  7.8,

  // Variable: ModelParam_rDeltamax
  //  Referenced by: '<S286>/Constant'

  0.3490658503988659,

  // Variable: ModelParam_rDeltamin
  //  Referenced by: '<S286>/Constant1'

  -0.3490658503988659,

  // Variable: ModelParam_rotorCm
  //  Referenced by: '<S173>/Propeller Model'

  5.2E-7,

  // Variable: ModelParam_rotorCt
  //  Referenced by: '<S173>/Propeller Model'

  2.2E-5,

  // Variable: ModelParam_rotorEta
  //  Referenced by: '<S173>/Propeller Model'

  0.0,

  // Variable: ModelParam_rotordx
  //  Referenced by: '<S173>/Propeller Model'

  0.2,

  // Variable: ModelParam_rotordy
  //  Referenced by: '<S173>/Propeller Model'

  0.2,

  // Variable: ModelParam_servoT
  //  Referenced by:
  //    '<S282>/motorT'
  //    '<S283>/motorT'

  0.02,

  // Variable: ModelParam_temperature
  //  Referenced by: '<S181>/Constant2'

  25.0,

  // Variable: ModelParam_uavCCm
  //  Referenced by: '<S173>/Aerodynamics and torque'

  { 0.0035, 0.0039, 0.0034 },

  // Variable: ModelParam_uavCd
  //  Referenced by: '<S173>/Aerodynamics and torque'

  { 0.055, 0.055, 0.055 },

  // Variable: ModelParam_uavJ
  //  Referenced by: '<S299>/Constant1'

  { 0.05, 0.0, 0.0, 0.0, 0.05, 0.0, 0.0, 0.0, 0.07 },

  // Variable: ModelParam_uavMass
  //  Referenced by:
  //    '<Root>/uavMass'
  //    '<S173>/Mass'
  //    '<S299>/Constant'

  2.0,

  // Variable: ModelFailEnable
  //  Referenced by: '<S12>/ModelFailEnable'

  false,

  // Variable: ModelFailWind_isConstWind
  //  Referenced by: '<S180>/Constant4'

  false,

  // Variable: ModelFailWind_isEnable
  //  Referenced by: '<S180>/Constant2'

  true,

  // Variable: ModelFailWind_isGustWind
  //  Referenced by: '<S180>/Constant5'

  false,

  // Variable: ModelFailWind_isSheerWind
  //  Referenced by: '<S180>/Constant1'

  false,

  // Variable: ModelFailWind_isTurbWind
  //  Referenced by: '<S180>/Constant3'

  false,

  // Variable: ModelParam_use_CoesaAtmosphereModel_density
  //  Referenced by: '<S181>/airDensity1'

  false,

  // Variable: ModelParam_use_CoesaAtmosphereModel_temperature
  //  Referenced by: '<S181>/Constant1'

  true,

  // Variable: USE_AeroCoefficient
  //  Referenced by: '<S173>/Aerodynamics and torque'

  true,

  // Variable: USE_PROPELLER_MODEL1
  //  Referenced by: '<S173>/Propeller Model'

  true,

  // Variable: AERO_COEFFICIENT
  //  Referenced by: '<S170>/aerodynamic coefficients'

  1,

  // Variable: ModelParam_uavType
  //  Referenced by: '<S16>/UAVType'

  3,

  // Mask Parameter: DrydenWindTurbulenceModelContin
  //  Referenced by: '<S259>/Medium//High Altitude'

  533.4,

  // Mask Parameter: DrydenWindTurbulenceModelCont_a
  //  Referenced by: '<S233>/White Noise'

  { 23341.0, 23342.0, 23343.0, 23344.0 },

  // Mask Parameter: DrydenWindTurbulenceModelCont_b
  //  Referenced by:
  //    '<S223>/Constant1'
  //    '<S223>/Constant2'
  //    '<S223>/Constant3'
  //    '<S224>/Constant'

  1.0,

  // Mask Parameter: WhiteNoise_Ts
  //  Referenced by: '<S233>/Constant1'

  0.001,

  // Mask Parameter: DrydenWindTurbulenceModelCont_p
  //  Referenced by: '<S240>/Probability of  Exceedance'

  3.0,

  // Mask Parameter: DrydenWindTurbulenceModelCont_c
  //  Referenced by: '<S216>/Windspeed at 20ft (6m)'

  10.0,

  // Mask Parameter: WindShearModel_W_20
  //  Referenced by: '<S217>/Wind speed at reference height'

  15.0,

  // Mask Parameter: DrydenWindTurbulenceModelCont_l
  //  Referenced by: '<S216>/Wind direction'

  0.0,

  // Mask Parameter: WindShearModel_Wdeg
  //  Referenced by: '<S217>/Wind Direction'

  0.0,

  // Mask Parameter: DrydenWindTurbulenceModelCont_g
  //  Referenced by: '<S216>/Wingspan'

  1.0,

  // Mask Parameter: ThreeaxisAccelerometer0_a_bias
  //  Referenced by: '<S94>/Measurement bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisAccelerometer1_a_bias
  //  Referenced by: '<S95>/Measurement bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisAccelerometer0_a_sf_cc
  //  Referenced by: '<S94>/Scale factors & Cross-coupling  errors'

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Mask Parameter: ThreeaxisAccelerometer1_a_sf_cc
  //  Referenced by: '<S95>/Scale factors & Cross-coupling  errors'

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Mask Parameter: ThreeaxisAccelerometer0_acc
  //  Referenced by: '<S94>/wl_ins'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisAccelerometer1_acc
  //  Referenced by: '<S95>/wl_ins'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: COESAAtmosphereModel_action
  //  Referenced by: '<S263>/S-Function'

  2.0,

  // Mask Parameter: CompareToConstant_const
  //  Referenced by: '<S202>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_l
  //  Referenced by: '<S197>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_f
  //  Referenced by: '<S203>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_h
  //  Referenced by: '<S193>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_j
  //  Referenced by: '<S188>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_d
  //  Referenced by: '<S194>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_b
  //  Referenced by: '<S39>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_c
  //  Referenced by: '<S34>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_e
  //  Referenced by: '<S40>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_p
  //  Referenced by: '<S30>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_o
  //  Referenced by: '<S25>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_h3
  //  Referenced by: '<S31>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_i
  //  Referenced by: '<S148>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_lb
  //  Referenced by: '<S143>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_jt
  //  Referenced by: '<S149>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_hj
  //  Referenced by: '<S139>/Constant'

  180.0,

  // Mask Parameter: CompareToConstant_const_fd
  //  Referenced by: '<S134>/Constant'

  90.0,

  // Mask Parameter: CompareToConstant_const_hi
  //  Referenced by: '<S140>/Constant'

  180.0,

  // Mask Parameter: Distanceintogustx_d_m
  //  Referenced by: '<S218>/Distance into Gust (x) (Limited to gust length d)'

  120.0,

  // Mask Parameter: Distanceintogusty_d_m
  //  Referenced by: '<S215>/Distance into gust (y)'

  120.0,

  // Mask Parameter: Distanceintogustz_d_m
  //  Referenced by: '<S215>/Distance into gust (z)'

  80.0,

  // Mask Parameter: DiscreteWindGustModel_d_m
  //  Referenced by: '<S215>/pi//Gust length'

  { 120.0, 120.0, 80.0 },

  // Mask Parameter: ThreeaxisGyroscope1_g_bias
  //  Referenced by: '<S160>/Measurement bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisGyroscope0_g_bias
  //  Referenced by: '<S159>/Measurement bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisGyroscope1_g_sen
  //  Referenced by: '<S160>/g-sensitive bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisGyroscope0_g_sen
  //  Referenced by: '<S159>/g-sensitive bias'

  { 0.0, 0.0, 0.0 },

  // Mask Parameter: ThreeaxisGyroscope1_g_sf_cc
  //  Referenced by: '<S160>/Scale factors & Cross-coupling  errors '

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Mask Parameter: ThreeaxisGyroscope0_g_sf_cc
  //  Referenced by: '<S159>/Scale factors & Cross-coupling  errors '

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Mask Parameter: uDOFQuaternion_k_quat
  //  Referenced by: '<S308>/High Gain Quaternion Normalization'

  1.0,

  // Mask Parameter: FlatEarthtoLLA_psi
  //  Referenced by: '<S177>/ref_rotation'

  0.0,

  // Mask Parameter: FlatEarthtoLLA_psi_a
  //  Referenced by: '<S18>/ref_rotation'

  0.0,

  // Mask Parameter: FlatEarthtoLLA_psi_m
  //  Referenced by: '<S125>/ref_rotation'

  0.0,

  // Mask Parameter: WhiteNoise_pwr
  //  Referenced by: '<S233>/Constant'

  { 3.1415926535897931, 3.1415926535897931, 3.1415926535897931,
    3.1415926535897931 },

  // Mask Parameter: DirectionCosineMatrixtoQuaterni
  //  Referenced by: '<S50>/If Warning//Error'

  4.4408920985006262E-16,

  // Mask Parameter: DirectionCosineMatrixtoQuater_f
  //  Referenced by: '<S339>/If Warning//Error'

  4.4408920985006262E-16,

  // Mask Parameter: ThreeaxisAccelerometer0_w_a
  //  Referenced by:
  //    '<S100>/2*zeta * wn'
  //    '<S100>/wn^2'

  190.0,

  // Mask Parameter: ThreeaxisAccelerometer1_w_a
  //  Referenced by:
  //    '<S113>/2*zeta * wn'
  //    '<S113>/wn^2'

  190.0,

  // Mask Parameter: ThreeaxisGyroscope0_w_g
  //  Referenced by:
  //    '<S163>/2*zeta * wn'
  //    '<S163>/wn^2'

  190.0,

  // Mask Parameter: ThreeaxisGyroscope1_w_g
  //  Referenced by:
  //    '<S166>/2*zeta * wn'
  //    '<S166>/wn^2'

  190.0,

  // Mask Parameter: ThreeaxisAccelerometer0_z_a
  //  Referenced by: '<S100>/2*zeta * wn'

  0.707,

  // Mask Parameter: ThreeaxisAccelerometer1_z_a
  //  Referenced by: '<S113>/2*zeta * wn'

  0.707,

  // Mask Parameter: ThreeaxisGyroscope0_z_g
  //  Referenced by: '<S163>/2*zeta * wn'

  0.707,

  // Mask Parameter: ThreeaxisGyroscope1_z_g
  //  Referenced by: '<S166>/2*zeta * wn'

  0.707,

  // Mask Parameter: DiscreteWindGustModel_Gx
  //  Referenced by: '<S215>/Constant'

  true,

  // Mask Parameter: DiscreteWindGustModel_Gy
  //  Referenced by: '<S215>/Constant1'

  true,

  // Mask Parameter: DiscreteWindGustModel_Gz
  //  Referenced by: '<S215>/Constant2'

  true,

  // Mask Parameter: CompareToConstant_const_a
  //  Referenced by: '<S210>/Constant'

  true,

  // Mask Parameter: CompareToConstant1_const
  //  Referenced by: '<S211>/Constant'

  true,

  // Mask Parameter: CompareToConstant2_const
  //  Referenced by: '<S212>/Constant'

  true,

  // Mask Parameter: CompareToConstant3_const
  //  Referenced by: '<S213>/Constant'

  true,

  // Mask Parameter: CompareToConstant4_const
  //  Referenced by: '<S214>/Constant'

  true,

  // Mask Parameter: DirectionCosineMatrixtoQuater_a
  //  Referenced by:
  //    '<S50>/If Warning//Error'
  //    '<S50>/Constant'

  1U,

  // Mask Parameter: DirectionCosineMatrixtoQuater_n
  //  Referenced by:
  //    '<S339>/If Warning//Error'
  //    '<S339>/Constant'

  1U,

  // Expression: -90
  //  Referenced by: '<S23>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S23>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S23>/Bias1'

  90.0,

  // Expression: 180
  //  Referenced by: '<S27>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S27>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S24>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S24>/Bias1'

  -180.0,

  // Expression: -90
  //  Referenced by: '<S32>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S32>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S32>/Bias1'

  90.0,

  // Expression: 360
  //  Referenced by: '<S36>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S36>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S36>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S20>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S20>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S33>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S33>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S33>/Bias1'

  -180.0,

  // Expression: -90
  //  Referenced by: '<S132>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S132>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S132>/Bias1'

  90.0,

  // Expression: 180
  //  Referenced by: '<S136>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S136>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S133>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S133>/Bias1'

  -180.0,

  // Expression: -90
  //  Referenced by: '<S141>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S141>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S141>/Bias1'

  90.0,

  // Expression: 360
  //  Referenced by: '<S145>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S145>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S145>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S129>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S129>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S142>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S142>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S142>/Bias1'

  -180.0,

  // Expression: -90
  //  Referenced by: '<S186>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S186>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S186>/Bias1'

  90.0,

  // Expression: 180
  //  Referenced by: '<S190>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S190>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S187>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S187>/Bias1'

  -180.0,

  // Expression: -90
  //  Referenced by: '<S195>/Bias'

  -90.0,

  // Expression: -1
  //  Referenced by: '<S195>/Gain'

  -1.0,

  // Expression: +90
  //  Referenced by: '<S195>/Bias1'

  90.0,

  // Expression: 360
  //  Referenced by: '<S199>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S199>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S199>/Bias1'

  -180.0,

  // Expression: 180
  //  Referenced by: '<S183>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S183>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S196>/Constant2'

  360.0,

  // Expression: 180
  //  Referenced by: '<S196>/Bias'

  180.0,

  // Expression: -180
  //  Referenced by: '<S196>/Bias1'

  -180.0,

  // Expression: [0]
  //  Referenced by: '<S218>/x'

  0.0,

  // Expression: 0
  //  Referenced by: '<S218>/Distance into Gust (x) (Limited to gust length d)'

  0.0,

  // Expression: 0
  //  Referenced by: '<S218>/Distance into Gust (x) (Limited to gust length d)'

  0.0,

  // Expression: 0
  //  Referenced by: '<S234>/pgw'

  0.0,

  // Expression: 1/3
  //  Referenced by: '<S234>/Constant1'

  0.33333333333333331,

  // Expression: 1/6
  //  Referenced by: '<S234>/Constant2'

  0.16666666666666666,

  // Expression: pi/4
  //  Referenced by: '<S234>/Constant3'

  0.78539816339744828,

  // Expression: 0
  //  Referenced by: '<S234>/pgw_p'

  0.0,

  // Expression: 0
  //  Referenced by: '<S235>/qgw'

  0.0,

  // Expression: 0
  //  Referenced by: '<S235>/qgw_p'

  0.0,

  // Expression: pi/4
  //  Referenced by: '<S235>/pi//4'

  0.78539816339744828,

  // Expression: 0
  //  Referenced by: '<S236>/rgw'

  0.0,

  // Expression: 0
  //  Referenced by: '<S236>/rgw_p'

  0.0,

  // Expression: pi/3
  //  Referenced by: '<S236>/pi//3'

  1.0471975511965976,

  // Expression: 0
  //  Referenced by: '<S237>/ugw'

  0.0,

  // Expression: 2/pi
  //  Referenced by: '<S237>/(2//pi)'

  0.63661977236758138,

  // Expression: 0
  //  Referenced by: '<S237>/ug_p'

  0.0,

  // Expression: 0
  //  Referenced by: '<S238>/vgw'

  0.0,

  // Expression: 1/pi
  //  Referenced by: '<S238>/(1//pi)'

  0.31830988618379069,

  // Expression: 0
  //  Referenced by: '<S238>/vg_p1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S238>/vgw_p2'

  0.0,

  // Expression: sqrt(3)
  //  Referenced by: '<S238>/sqrt(3)'

  1.7320508075688772,

  // Expression: 0
  //  Referenced by: '<S239>/wgw'

  0.0,

  // Expression: 1/pi
  //  Referenced by: '<S239>/1//pi'

  0.31830988618379069,

  // Expression: 3
  //  Referenced by: '<S239>/Constant'

  3.0,

  // Expression: 0
  //  Referenced by: '<S239>/wg_p1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S239>/wg_p2'

  0.0,

  // Expression: 1
  //  Referenced by: '<S244>/Gain'

  1.0,

  // Expression: max_height_low
  //  Referenced by: '<S242>/max_height_low'

  1000.0,

  // Expression: min_height_high
  //  Referenced by: '<S242>/min_height_high'

  2000.0,

  // Expression: 1
  //  Referenced by: '<S252>/Gain'

  1.0,

  // Expression: max_height_low
  //  Referenced by: '<S250>/max_height_low'

  1000.0,

  // Expression: min_height_high
  //  Referenced by: '<S250>/min_height_high'

  2000.0,

  // Expression: 10
  //  Referenced by: '<S180>/Constant'

  10.0,

  // Expression: eye(3)
  //  Referenced by: '<S180>/Constant_DCM'

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Expression: 1.0
  //  Referenced by: '<S215>/2'

  1.0,

  // Expression: max_height_low
  //  Referenced by: '<S258>/Limit Function 10ft to 1000ft'

  1000.0,

  // Expression: 10
  //  Referenced by: '<S258>/Limit Function 10ft to 1000ft'

  10.0,

  // Expression: 1
  //  Referenced by: '<S230>/Lw'

  1.0,

  // Expression: 0.1
  //  Referenced by: '<S241>/sigma_wg '

  0.1,

  // Expression: h_vec
  //  Referenced by: '<S240>/PreLook-Up Index Search  (altitude)'

  { 500.0, 1750.0, 3750.0, 7500.0, 15000.0, 25000.0, 35000.0, 45000.0, 55000.0,
    65000.0, 75000.0, 80000.0 },

  // Expression: [1:7]
  //  Referenced by: '<S240>/PreLook-Up Index Search  (prob of exceed)'

  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 },

  // Expression: sigma_vec'
  //  Referenced by: '<S240>/Medium//High Altitude Intensity'

  { 3.2, 2.2, 1.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.2, 3.6, 3.3,
    1.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.6, 6.9, 7.4, 6.7, 4.6, 2.7,
    0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 8.6, 9.6, 10.6, 10.1, 8.0, 6.6, 5.0, 4.2, 2.7,
    0.0, 0.0, 0.0, 11.8, 13.0, 16.0, 15.1, 11.6, 9.7, 8.1, 8.2, 7.9, 4.9, 3.2,
    2.1, 15.6, 17.6, 23.0, 23.6, 22.1, 20.0, 16.0, 15.1, 12.1, 7.9, 6.2, 5.1,
    18.7, 21.5, 28.4, 30.2, 30.7, 31.0, 25.2, 23.1, 17.5, 10.7, 8.4, 7.2 },

  // Expression: 0
  //  Referenced by: '<S233>/White Noise'

  0.0,

  // Computed Parameter: WhiteNoise_StdDev
  //  Referenced by: '<S233>/White Noise'

  1.0,

  // Expression: max_height_low
  //  Referenced by: '<S241>/Limit Height h<1000ft'

  1000.0,

  // Expression: 0
  //  Referenced by: '<S241>/Limit Height h<1000ft'

  0.0,

  // Expression: 1
  //  Referenced by: '<S230>/Lv'

  1.0,

  // Expression: inf
  //  Referenced by: '<S217>/3ft-->inf'

  rtInf,

  // Expression: 3
  //  Referenced by: '<S217>/3ft-->inf'

  3.0,

  // Expression: 1/z0
  //  Referenced by: '<S217>/h//z0'

  6.666666666666667,

  // Expression: 20/z0
  //  Referenced by: '<S217>/ref_height//z0'

  133.33333333333334,

  // Expression: 0
  //  Referenced by: '<S217>/Wdeg1'

  0.0,

  // Expression: 1
  //  Referenced by: '<S325>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S326>/Constant'

  1.0,

  // Expression: 1E6
  //  Referenced by: '<S5>/Gain_clock'

  1.0E+6,

  // Expression: 0
  //  Referenced by: '<S100>/Integrator, Second-Order Limited'

  0.0,

  // Expression: 0
  //  Referenced by: '<S100>/Integrator, Second-Order Limited'

  0.0,

  // Expression: dtype_a
  //  Referenced by: '<S96>/Constant'

  1.0,

  // Computed Parameter: DiscreteTimeIntegrator_gainval
  //  Referenced by: '<S277>/Discrete-Time Integrator'

  0.001,

  // Computed Parameter: DiscreteTimeIntegrator_gainva_i
  //  Referenced by: '<S278>/Discrete-Time Integrator'

  0.001,

  // Computed Parameter: DiscreteTimeIntegrator_gainva_g
  //  Referenced by: '<S279>/Discrete-Time Integrator'

  0.001,

  // Computed Parameter: DiscreteTimeIntegrator_gainva_o
  //  Referenced by: '<S280>/Discrete-Time Integrator'

  0.001,

  // Expression: 0.5
  //  Referenced by: '<S307>/1//2'

  0.5,

  // Expression: 2
  //  Referenced by: '<S312>/Gain'

  2.0,

  // Expression: 2
  //  Referenced by: '<S315>/Gain'

  2.0,

  // Expression: 2
  //  Referenced by: '<S310>/Gain'

  2.0,

  // Expression: 2
  //  Referenced by: '<S316>/Gain'

  2.0,

  // Expression: 2
  //  Referenced by: '<S311>/Gain'

  2.0,

  // Expression: 2
  //  Referenced by: '<S314>/Gain'

  2.0,

  // Expression: [27666.94 -3533.48 47325.16]
  //  Referenced by: '<S181>/Constant3'

  { 27666.94, -3533.48, 47325.16 },

  // Expression: 1e-5
  //  Referenced by: '<S172>/nT2Gauss'

  1.0E-5,

  // Expression: -7.28
  //  Referenced by: '<S181>/Constant4'

  -7.28,

  // Expression: R
  //  Referenced by: '<S204>/Constant1'

  6.378137E+6,

  // Expression: 1
  //  Referenced by: '<S207>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S209>/Constant'

  1.0,

  // Expression: F
  //  Referenced by: '<S208>/Constant'

  0.0033528106647474805,

  // Expression: 1
  //  Referenced by: '<S208>/f'

  1.0,

  // Expression: 1
  //  Referenced by: '<S198>/Merge'

  1.0,

  // Expression: 1
  //  Referenced by: '<S204>/Constant'

  1.0,

  // Expression: 360
  //  Referenced by: '<S190>/Constant2'

  360.0,

  // Expression: 1
  //  Referenced by: '<S189>/Merge'

  1.0,

  // Expression: 180
  //  Referenced by: '<S182>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S182>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S187>/Constant2'

  360.0,

  // Expression: 10000
  //  Referenced by: '<S172>/Saturation'

  10000.0,

  // Expression: 0
  //  Referenced by: '<S172>/Saturation'

  0.0,

  // Expression: [1 0 0 0]
  //  Referenced by: '<S296>/Merge'

  { 1.0, 0.0, 0.0, 0.0 },

  // Computed Parameter: DiscreteTimeIntegrator_gainva_j
  //  Referenced by: '<S282>/Discrete-Time Integrator'

  0.001,

  // Expression: 0
  //  Referenced by: '<S284>/Unit Delay'

  0.0,

  // Computed Parameter: DiscreteTimeIntegrator_gainva_p
  //  Referenced by: '<S283>/Discrete-Time Integrator'

  0.001,

  // Expression: 0
  //  Referenced by: '<S285>/Unit Delay'

  0.0,

  // Computed Parameter: TransferFcn_A
  //  Referenced by: '<S272>/Transfer Fcn'

  -10.0,

  // Computed Parameter: TransferFcn_C
  //  Referenced by: '<S272>/Transfer Fcn'

  10.0,

  // Computed Parameter: TransferFcn1_A
  //  Referenced by: '<S272>/Transfer Fcn1'

  -10.0,

  // Computed Parameter: TransferFcn1_C
  //  Referenced by: '<S272>/Transfer Fcn1'

  10.0,

  // Computed Parameter: TransferFcn2_A
  //  Referenced by: '<S272>/Transfer Fcn2'

  -10.0,

  // Computed Parameter: TransferFcn2_C
  //  Referenced by: '<S272>/Transfer Fcn2'

  10.0,

  // Expression: 1
  //  Referenced by: '<S94>/Zero-Order Hold1'

  1.0,

  // Expression: 1
  //  Referenced by: '<S94>/Zero-Order Hold2'

  1.0,

  // Expression: 1
  //  Referenced by: '<S94>/Zero-Order Hold'

  1.0,

  // Expression: [0 0 0]
  //  Referenced by: '<S89>/CG_Acc0'

  { 0.0, 0.0, 0.0 },

  // Expression: 1
  //  Referenced by: '<S94>/Zero-Order Hold4'

  1.0,

  // Expression: [1 -1 1]
  //  Referenced by: '<S94>/Gain'

  { 1.0, -1.0, 1.0 },

  // Computed Parameter: TransferFcn3_A
  //  Referenced by: '<S273>/Transfer Fcn3'

  -10.0,

  // Computed Parameter: TransferFcn3_C
  //  Referenced by: '<S273>/Transfer Fcn3'

  10.0,

  // Computed Parameter: TransferFcn4_A
  //  Referenced by: '<S273>/Transfer Fcn4'

  -10.0,

  // Computed Parameter: TransferFcn4_C
  //  Referenced by: '<S273>/Transfer Fcn4'

  10.0,

  // Computed Parameter: TransferFcn5_A
  //  Referenced by: '<S273>/Transfer Fcn5'

  -10.0,

  // Computed Parameter: TransferFcn5_C
  //  Referenced by: '<S273>/Transfer Fcn5'

  10.0,

  // Expression: zeros(3)
  //  Referenced by: '<S299>/Constant2'

  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },

  // Expression: 1
  //  Referenced by: '<S94>/Zero-Order Hold3'

  1.0,

  // Expression: 0.5
  //  Referenced by: '<S96>/Switch'

  0.5,

  // Expression: a_sath
  //  Referenced by: '<S94>/Saturation'

  { rtInf, rtInf, rtInf },

  // Expression: a_satl
  //  Referenced by: '<S94>/Saturation'

  { rtMinusInf, rtMinusInf, rtMinusInf },

  // Expression: 0
  //  Referenced by: '<S89>/Random Number'

  0.0,

  // Expression: 0
  //  Referenced by: '<S89>/Integrator'

  0.0,

  // Expression: 0
  //  Referenced by: '<S89>/DelayLength0'

  0.0,

  // Expression: 1
  //  Referenced by: '<S89>/Enable0'

  1.0,

  // Expression: 0.0
  //  Referenced by: '<S89>/Delay'

  0.0,

  // Expression: 0
  //  Referenced by: '<S166>/Integrator, Second-Order Limited'

  0.0,

  // Expression: 0
  //  Referenced by: '<S166>/Integrator, Second-Order Limited'

  0.0,

  // Expression: dtype_g
  //  Referenced by: '<S164>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S160>/Zero-Order Hold'

  1.0,

  // Expression: 1
  //  Referenced by: '<S160>/Zero-Order Hold1'

  1.0,

  // Expression: 0.5
  //  Referenced by: '<S164>/Switch'

  0.5,

  // Expression: g_sath
  //  Referenced by: '<S160>/Saturation'

  { rtInf, rtInf, rtInf },

  // Expression: g_satl
  //  Referenced by: '<S160>/Saturation'

  { rtMinusInf, rtMinusInf, rtMinusInf },

  // Expression: 0
  //  Referenced by: '<S92>/DelayLength1'

  0.0,

  // Expression: 1
  //  Referenced by: '<S92>/Enable1'

  1.0,

  // Expression: 0.0
  //  Referenced by: '<S92>/Delay1'

  0.0,

  // Expression: [1 0 0;0 1 0;0 0 1]
  //  Referenced by: '<S93>/K_pulse1'

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Expression: 0
  //  Referenced by: '<S93>/Integrator1'

  0.0,

  // Expression: [0 0 0]
  //  Referenced by: '<S93>/Measurement bias1'

  { 0.0, 0.0, 0.0 },

  // Expression: [0 0 0]
  //  Referenced by: '<S93>/Random Number2'

  { 0.0, 0.0, 0.0 },

  // Computed Parameter: RandomNumber2_StdDev
  //  Referenced by: '<S93>/Random Number2'

  { 1.0E-5, 1.0E-5, 1.0E-5 },

  // Expression: [666 588 477]
  //  Referenced by: '<S93>/Random Number2'

  { 666.0, 588.0, 477.0 },

  // Expression: [1 0 0; 0 1 0; 0 0 1]
  //  Referenced by: '<S93>/K_m1'

  { 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 },

  // Expression: 0
  //  Referenced by: '<S93>/DelayLength1'

  0.0,

  // Expression: 1
  //  Referenced by: '<S93>/Enable1'

  1.0,

  // Expression: 0.0
  //  Referenced by: '<S93>/Delay1'

  0.0,

  // Expression: T0
  //  Referenced by: '<S123>/Sea Level  Temperature'

  288.15,

  // Expression: 1
  //  Referenced by: '<S90>/K_pulse0'

  1.0,

  // Expression: 0
  //  Referenced by: '<S90>/Random Number1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S90>/Integrator1'

  0.0,

  // Expression: h_trop
  //  Referenced by: '<S123>/Limit  altitude  to troposhere'

  11000.0,

  // Expression: h0
  //  Referenced by: '<S123>/Limit  altitude  to troposhere'

  0.0,

  // Expression: L
  //  Referenced by: '<S123>/Lapse Rate'

  0.0065,

  // Expression: 1/T0
  //  Referenced by: '<S123>/1//T0'

  0.00347041471455839,

  // Expression: g/(L*R)
  //  Referenced by: '<S123>/Constant'

  5.2558756014667134,

  // Expression: P0
  //  Referenced by: '<S123>/P0'

  101325.0,

  // Expression: h_trop
  //  Referenced by: '<S123>/Altitude of Troposphere'

  11000.0,

  // Expression: 0
  //  Referenced by: '<S123>/Limit  altitude  to Stratosphere'

  0.0,

  // Expression: h_trop-h_strat
  //  Referenced by: '<S123>/Limit  altitude  to Stratosphere'

  -9000.0,

  // Expression: g/R
  //  Referenced by: '<S123>/g//R'

  0.034163191409533639,

  // Expression: 0.01
  //  Referenced by: '<S90>/Gain3'

  0.01,

  // Expression: 0.01
  //  Referenced by: '<S90>/Gain'

  0.01,

  // Expression: 8191
  //  Referenced by: '<S6>/Constant'

  8191.0,

  // Expression: R
  //  Referenced by: '<S41>/Constant1'

  6.378137E+6,

  // Expression: 1
  //  Referenced by: '<S44>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S46>/Constant'

  1.0,

  // Expression: F
  //  Referenced by: '<S45>/Constant'

  0.0033528106647474805,

  // Expression: 1
  //  Referenced by: '<S45>/f'

  1.0,

  // Expression: 1
  //  Referenced by: '<S35>/Merge'

  1.0,

  // Expression: 1
  //  Referenced by: '<S41>/Constant'

  1.0,

  // Expression: 360
  //  Referenced by: '<S27>/Constant2'

  360.0,

  // Expression: 1
  //  Referenced by: '<S26>/Merge'

  1.0,

  // Expression: 1E7
  //  Referenced by: '<S14>/Gain'

  1.0E+7,

  // Expression: 180
  //  Referenced by: '<S19>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S19>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S24>/Constant2'

  360.0,

  // Expression: 1E7
  //  Referenced by: '<S14>/Gain1'

  1.0E+7,

  // Expression: 100000
  //  Referenced by: '<S14>/Saturation'

  100000.0,

  // Expression: 0
  //  Referenced by: '<S14>/Saturation'

  0.0,

  // Expression: 1E3
  //  Referenced by: '<S14>/Gain3'

  1000.0,

  // Expression: 100
  //  Referenced by: '<S14>/Gain4'

  100.0,

  // Expression: 2/1.225*100
  //  Referenced by: '<S14>/Gain2'

  163.26530612244895,

  // Expression: 100
  //  Referenced by: '<S14>/Gain7'

  100.0,

  // Expression: 1000.0/9.80665
  //  Referenced by: '<S14>/Gain5'

  101.97162129779284,

  // Expression: [-1,-1,-2]*1e-5
  //  Referenced by: '<S91>/Uniform Random Number1'

  { -1.0E-5, -1.0E-5, -2.0E-5 },

  // Expression: [1,1,2]*1e-5
  //  Referenced by: '<S91>/Uniform Random Number1'

  { 1.0E-5, 1.0E-5, 2.0E-5 },

  // Expression: [1452,787,69]
  //  Referenced by: '<S91>/Uniform Random Number1'

  { 1452.0, 787.0, 69.0 },

  // Expression: 0.2*0.58
  //  Referenced by: '<S91>/Gain1'

  0.11599999999999999,

  // Expression: R
  //  Referenced by: '<S150>/Constant1'

  6.378137E+6,

  // Expression: 1
  //  Referenced by: '<S153>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S155>/Constant'

  1.0,

  // Expression: F
  //  Referenced by: '<S154>/Constant'

  0.0033528106647474805,

  // Expression: 1
  //  Referenced by: '<S154>/f'

  1.0,

  // Expression: 1
  //  Referenced by: '<S144>/Merge'

  1.0,

  // Expression: 1
  //  Referenced by: '<S150>/Constant'

  1.0,

  // Expression: 360
  //  Referenced by: '<S136>/Constant2'

  360.0,

  // Expression: 1
  //  Referenced by: '<S135>/Merge'

  1.0,

  // Expression: 1E7
  //  Referenced by: '<S13>/Gain'

  1.0E+7,

  // Expression: 180
  //  Referenced by: '<S128>/Constant'

  180.0,

  // Expression: 0
  //  Referenced by: '<S128>/Constant1'

  0.0,

  // Expression: 360
  //  Referenced by: '<S133>/Constant2'

  360.0,

  // Expression: 1E7
  //  Referenced by: '<S13>/Gain1'

  1.0E+7,

  // Expression: 100000
  //  Referenced by: '<S91>/Saturation'

  100000.0,

  // Expression: 0
  //  Referenced by: '<S91>/Saturation'

  0.0,

  // Expression: 1E3
  //  Referenced by: '<S13>/Gain3'

  1000.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain6'

  100.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain8'

  100.0,

  // Computed Parameter: TransferFcn4_A_j
  //  Referenced by: '<S127>/Transfer Fcn4'

  -20.0,

  // Computed Parameter: TransferFcn4_C_b
  //  Referenced by: '<S127>/Transfer Fcn4'

  20.0,

  // Computed Parameter: TransferFcn1_A_k
  //  Referenced by: '<S127>/Transfer Fcn1'

  -20.0,

  // Computed Parameter: TransferFcn1_C_j
  //  Referenced by: '<S127>/Transfer Fcn1'

  20.0,

  // Computed Parameter: TransferFcn2_A_b
  //  Referenced by: '<S127>/Transfer Fcn2'

  -20.0,

  // Computed Parameter: TransferFcn2_C_o
  //  Referenced by: '<S127>/Transfer Fcn2'

  20.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain9'

  100.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain4'

  100.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain10'

  100.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain11'

  100.0,

  // Expression: 100
  //  Referenced by: '<S13>/Gain2'

  100.0,

  // Expression: 1E3
  //  Referenced by: '<S13>/Gain5'

  1000.0,

  // Expression: 1E3
  //  Referenced by: '<S13>/Gain7'

  1000.0,

  // Expression: 1000
  //  Referenced by: '<S13>/Gain12'

  1000.0,

  // Expression: 1000
  //  Referenced by: '<S13>/Gain13'

  1000.0,

  // Expression: 1000
  //  Referenced by: '<S13>/Gain14'

  1000.0,

  // Expression: 1000
  //  Referenced by: '<S13>/Gain15'

  1000.0,

  // Expression: 1e5
  //  Referenced by: '<S13>/Gain16'

  100000.0,

  // Expression: 1e5
  //  Referenced by: '<S13>/Gain17'

  100000.0,

  // Expression: 1
  //  Referenced by: '<S16>/CopterID'

  1.0,

  // Expression: [1 0 0 0]
  //  Referenced by: '<S47>/Merge'

  { 1.0, 0.0, 0.0, 0.0 },

  // Expression: 60/2/pi
  //  Referenced by: '<S16>/Gain'

  9.5492965855137211,

  // Expression: [0 0]
  //  Referenced by: '<S7>/Constant'

  { 0.0, 0.0 },

  // Expression: 180/pi
  //  Referenced by: '<S16>/Gain1'

  57.295779513082323,

  // Expression: 1
  //  Referenced by: '<Root>/Saturation'

  1.0,

  // Expression: 0
  //  Referenced by: '<Root>/Saturation'

  0.0,

  // Expression: [0 0 0]
  //  Referenced by: '<S89>/CG_Acc1'

  { 0.0, 0.0, 0.0 },

  // Expression: 0
  //  Referenced by: '<S89>/Random Number1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S113>/Integrator, Second-Order Limited'

  0.0,

  // Expression: 0
  //  Referenced by: '<S113>/Integrator, Second-Order Limited'

  0.0,

  // Expression: 1
  //  Referenced by: '<S95>/Zero-Order Hold1'

  1.0,

  // Expression: 1
  //  Referenced by: '<S95>/Zero-Order Hold2'

  1.0,

  // Expression: 1
  //  Referenced by: '<S95>/Zero-Order Hold'

  1.0,

  // Expression: 1
  //  Referenced by: '<S95>/Zero-Order Hold4'

  1.0,

  // Expression: [1 -1 1]
  //  Referenced by: '<S95>/Gain'

  { 1.0, -1.0, 1.0 },

  // Expression: 1
  //  Referenced by: '<S95>/Zero-Order Hold3'

  1.0,

  // Expression: 0
  //  Referenced by: '<S89>/Integrator1'

  0.0,

  // Expression: [0 0 0]
  //  Referenced by: '<S89>/Random Number3'

  { 0.0, 0.0, 0.0 },

  // Computed Parameter: RandomNumber3_StdDev
  //  Referenced by: '<S89>/Random Number3'

  { 0.31622776601683794, 0.31622776601683794, 0.31622776601683794 },

  // Expression: [3341 365 597]
  //  Referenced by: '<S89>/Random Number3'

  { 3341.0, 365.0, 597.0 },

  // Expression: 0
  //  Referenced by: '<S90>/Random Number2'

  0.0,

  // Expression: [-1,-1,-2]*1e-5
  //  Referenced by: '<S91>/Uniform Random Number4'

  { -1.0E-5, -1.0E-5, -2.0E-5 },

  // Expression: [1,1,2]*1e-5
  //  Referenced by: '<S91>/Uniform Random Number4'

  { 1.0E-5, 1.0E-5, 2.0E-5 },

  // Expression: [5445,45433,33433]
  //  Referenced by: '<S91>/Uniform Random Number4'

  { 5445.0, 45433.0, 33433.0 },

  // Expression: 0.1
  //  Referenced by: '<S91>/BiasGain1'

  0.1,

  // Expression: 0
  //  Referenced by: '<S92>/Random Number'

  0.0,

  // Expression: 0
  //  Referenced by: '<S92>/Integrator'

  0.0,

  // Expression: ones(3,1)
  //  Referenced by: '<S92>/Constant'

  { 1.0, 1.0, 1.0 },

  // Expression: 0
  //  Referenced by: '<S163>/Integrator, Second-Order Limited'

  0.0,

  // Expression: 0
  //  Referenced by: '<S163>/Integrator, Second-Order Limited'

  0.0,

  // Expression: dtype_g
  //  Referenced by: '<S161>/Constant'

  1.0,

  // Expression: 1
  //  Referenced by: '<S159>/Zero-Order Hold'

  1.0,

  // Expression: 1
  //  Referenced by: '<S159>/Zero-Order Hold1'

  1.0,

  // Expression: 0.5
  //  Referenced by: '<S161>/Switch'

  0.5,

  // Expression: g_sath
  //  Referenced by: '<S159>/Saturation'

  { rtInf, rtInf, rtInf },

  // Expression: g_satl
  //  Referenced by: '<S159>/Saturation'

  { rtMinusInf, rtMinusInf, rtMinusInf },

  // Expression: 0
  //  Referenced by: '<S92>/Random Number1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S92>/Integrator1'

  0.0,

  // Expression: [0 0 0]
  //  Referenced by: '<S92>/Random Number3'

  { 0.0, 0.0, 0.0 },

  // Computed Parameter: RandomNumber3_StdDev_e
  //  Referenced by: '<S92>/Random Number3'

  { 0.31622776601683794, 0.31622776601683794, 0.31622776601683794 },

  // Expression: [691 147 369]
  //  Referenced by: '<S92>/Random Number3'

  { 691.0, 147.0, 369.0 },

  // Expression: 0
  //  Referenced by: '<S93>/Integrator'

  0.0,

  // Expression: 0
  //  Referenced by: '<S93>/Random Number'

  0.0,

  // Expression: 0
  //  Referenced by: '<S93>/Random Number1'

  0.0,

  // Expression: [45465,454534,1234232]
  //  Referenced by: '<S93>/Random Number1'

  { 45465.0, 454534.0, 1.234232E+6 },

  // Expression: [0 0 0]
  //  Referenced by: '<S93>/Random Number3'

  { 0.0, 0.0, 0.0 },

  // Computed Parameter: RandomNumber3_StdDev_d
  //  Referenced by: '<S93>/Random Number3'

  { 1.0E-5, 1.0E-5, 1.0E-5 },

  // Expression: [111 222 333]
  //  Referenced by: '<S93>/Random Number3'

  { 111.0, 222.0, 333.0 },

  // Expression: 16
  //  Referenced by: '<S171>/BatteryVol'

  16.0,

  // Expression: 0
  //  Referenced by: '<S272>/Random Number'

  0.0,

  // Expression: 0
  //  Referenced by: '<S272>/Integrator'

  0.0,

  // Expression: 0
  //  Referenced by: '<S272>/Random Number1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S273>/Random Number2'

  0.0,

  // Expression: 0
  //  Referenced by: '<S273>/Integrator1'

  0.0,

  // Expression: 0
  //  Referenced by: '<S273>/Random Number3'

  0.0,

  // Expression: 1000
  //  Referenced by: '<S9>/Gain3'

  1000.0,

  // Expression: [1000,1000,1000,1000]
  //  Referenced by: '<S9>/Constant2'

  { 1000.0, 1000.0, 1000.0, 1000.0 },

  // Expression: 1000
  //  Referenced by: '<S9>/Gain1'

  1000.0,

  // Expression: [1000 1000]
  //  Referenced by: '<S9>/Constant1'

  { 1000.0, 1000.0 },

  // Expression: 2000
  //  Referenced by: '<S174>/Signal_Saturation_7'

  2000.0,

  // Expression: 1000
  //  Referenced by: '<S174>/Signal_Saturation_7'

  1000.0,

  // Expression: [1000,1000,1000,1000]
  //  Referenced by: '<S281>/Constant2'

  { 1000.0, 1000.0, 1000.0, 1000.0 },

  // Expression: 1/1000
  //  Referenced by: '<S281>/Gain1'

  0.001,

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_1'

  1.0,

  // Expression: 0
  //  Referenced by: '<S174>/Signal_Saturation_1'

  0.0,

  // Expression: 9000
  //  Referenced by: '<S174>/motorSpeed'

  9000.0,

  // Expression: 0
  //  Referenced by: '<S174>/motorSpeed'

  0.0,

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_2'

  1.0,

  // Expression: 0
  //  Referenced by: '<S174>/Signal_Saturation_2'

  0.0,

  // Expression: 9000
  //  Referenced by: '<S174>/motorSpeed1'

  9000.0,

  // Expression: 0
  //  Referenced by: '<S174>/motorSpeed1'

  0.0,

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_3'

  1.0,

  // Expression: 0
  //  Referenced by: '<S174>/Signal_Saturation_3'

  0.0,

  // Expression: 9000
  //  Referenced by: '<S174>/motorSpeed2'

  9000.0,

  // Expression: 0
  //  Referenced by: '<S174>/motorSpeed2'

  0.0,

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_4'

  1.0,

  // Expression: 0
  //  Referenced by: '<S174>/Signal_Saturation_4'

  0.0,

  // Expression: 9000
  //  Referenced by: '<S174>/motorSpeed3'

  9000.0,

  // Expression: 0
  //  Referenced by: '<S174>/motorSpeed3'

  0.0,

  // Expression: [1000 1000]
  //  Referenced by: '<S281>/Constant1'

  { 1000.0, 1000.0 },

  // Expression: 1/1000*2
  //  Referenced by: '<S281>/Gain2'

  0.002,

  // Expression: [1 1]
  //  Referenced by: '<S281>/Constant'

  { 1.0, 1.0 },

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_5'

  1.0,

  // Expression: -1
  //  Referenced by: '<S174>/Signal_Saturation_5'

  -1.0,

  // Expression: 0
  //  Referenced by: '<S286>/Switch'

  0.0,

  // Expression: 1
  //  Referenced by: '<S174>/Signal_Saturation_6'

  1.0,

  // Expression: -1
  //  Referenced by: '<S174>/Signal_Saturation_6'

  -1.0,

  // Expression: 0
  //  Referenced by: '<S287>/Switch'

  0.0,

  // Expression: 1
  //  Referenced by: '<S308>/Constant'

  1.0,

  // Computed Parameter: Gain_Gain_j
  //  Referenced by: '<S173>/Gain'

  0.0F,

  // Computed Parameter: MediumHighAltitudeIntensity_max
  //  Referenced by: '<S240>/Medium//High Altitude Intensity'

  { 11U, 6U },

  // Computed Parameter: Constant_Value_nn
  //  Referenced by: '<S385>/Constant'

  { 0U, 0U, 0U, 0U },

  // Start of '<S339>/If Warning//Error'
  {
    // Expression: 0
    //  Referenced by: '<S366>/Constant1'

    0.0,

    // Expression: 0
    //  Referenced by: '<S364>/Constant1'

    0.0,

    // Expression: -1
    //  Referenced by: '<S368>/Bias'

    -1.0,

    // Expression: -eye(3)
    //  Referenced by: '<S367>/Bias1'

    { -1.0, -0.0, -0.0, -0.0, -1.0, -0.0, -0.0, -0.0, -1.0 },

    // Computed Parameter: Assertion_Enabled
    //  Referenced by: '<S374>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_e
    //  Referenced by: '<S372>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_a
    //  Referenced by: '<S371>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_ak
    //  Referenced by: '<S369>/Assertion'

    true
  }
  ,

  // End of '<S339>/If Warning//Error'

  // Start of '<S296>/Negative Trace'
  {
    // Expression: 0.5
    //  Referenced by: '<S353>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S354>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S353>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S353>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S342>/Gain'

    0.5,

    // Expression: 0.5
    //  Referenced by: '<S358>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S359>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S358>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S358>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S343>/Gain'

    0.5,

    // Expression: 0.5
    //  Referenced by: '<S348>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S349>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S348>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S348>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S341>/Gain'

    0.5
  }
  ,

  // End of '<S296>/Negative Trace'

  // Start of '<S296>/Positive Trace'
  {
    // Expression: 1
    //  Referenced by: '<S338>/Constant'

    1.0,

    // Expression: 0.5
    //  Referenced by: '<S338>/Gain'

    0.5,

    // Expression: 2
    //  Referenced by: '<S338>/Gain1'

    2.0
  }
  ,

  // End of '<S296>/Positive Trace'

  // Start of '<S215>/Distance into gust (z)'
  {
    // Expression: [0]
    //  Referenced by: '<S220>/x'

    0.0,

    // Expression: 0
    //  Referenced by: '<S220>/Distance into Gust (x) (Limited to gust length d) '

    0.0,

    // Expression: 0
    //  Referenced by: '<S220>/Distance into Gust (x) (Limited to gust length d) '

    0.0
  }
  ,

  // End of '<S215>/Distance into gust (z)'

  // Start of '<S215>/Distance into gust (y)'
  {
    // Expression: [0]
    //  Referenced by: '<S219>/x'

    0.0,

    // Expression: 0
    //  Referenced by: '<S219>/Distance into Gust (x) (Limited to gust length d) '

    0.0,

    // Expression: 0
    //  Referenced by: '<S219>/Distance into Gust (x) (Limited to gust length d) '

    0.0
  }
  ,

  // End of '<S215>/Distance into gust (y)'

  // Start of '<S198>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S201>/Constant'

    0.0
  }
  ,

  // End of '<S198>/If Action Subsystem1'

  // Start of '<S189>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S192>/Constant'

    0.0
  }
  ,

  // End of '<S189>/If Action Subsystem1'

  // Start of '<S144>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S147>/Constant'

    0.0
  }
  ,

  // End of '<S144>/If Action Subsystem1'

  // Start of '<S135>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S138>/Constant'

    0.0
  }
  ,

  // End of '<S135>/If Action Subsystem1'

  // Start of '<S50>/If Warning//Error'
  {
    // Expression: 0
    //  Referenced by: '<S77>/Constant1'

    0.0,

    // Expression: 0
    //  Referenced by: '<S75>/Constant1'

    0.0,

    // Expression: -1
    //  Referenced by: '<S79>/Bias'

    -1.0,

    // Expression: -eye(3)
    //  Referenced by: '<S78>/Bias1'

    { -1.0, -0.0, -0.0, -0.0, -1.0, -0.0, -0.0, -0.0, -1.0 },

    // Computed Parameter: Assertion_Enabled
    //  Referenced by: '<S85>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_e
    //  Referenced by: '<S83>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_a
    //  Referenced by: '<S82>/Assertion'

    true,

    // Computed Parameter: Assertion_Enabled_ak
    //  Referenced by: '<S80>/Assertion'

    true
  }
  ,

  // End of '<S50>/If Warning//Error'

  // Start of '<S47>/Negative Trace'
  {
    // Expression: 0.5
    //  Referenced by: '<S64>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S65>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S64>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S64>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S53>/Gain'

    0.5,

    // Expression: 0.5
    //  Referenced by: '<S69>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S70>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S69>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S69>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S54>/Gain'

    0.5,

    // Expression: 0.5
    //  Referenced by: '<S59>/Constant1'

    0.5,

    // Expression: 1
    //  Referenced by: '<S60>/Constant'

    1.0,

    // Expression: [0 1]
    //  Referenced by: '<S59>/Constant2'

    { 0.0, 1.0 },

    // Expression: 0
    //  Referenced by: '<S59>/Switch'

    0.0,

    // Expression: 0.5
    //  Referenced by: '<S52>/Gain'

    0.5
  }
  ,

  // End of '<S47>/Negative Trace'

  // Start of '<S47>/Positive Trace'
  {
    // Expression: 1
    //  Referenced by: '<S49>/Constant'

    1.0,

    // Expression: 0.5
    //  Referenced by: '<S49>/Gain'

    0.5,

    // Expression: 2
    //  Referenced by: '<S49>/Gain1'

    2.0
  }
  ,

  // End of '<S47>/Positive Trace'

  // Start of '<S35>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S38>/Constant'

    0.0
  }
  ,

  // End of '<S35>/If Action Subsystem1'

  // Start of '<S26>/If Action Subsystem1'
  {
    // Expression: 0
    //  Referenced by: '<S29>/Constant'

    0.0
  }
  // End of '<S26>/If Action Subsystem1'
};

extern real_T rt_modd_snf(real_T u0, real_T u1);
extern real_T rt_powd_snf(real_T u0, real_T u1);
extern real_T rt_atan2d_snf(real_T u0, real_T u1);
extern void rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1
  [9], real_T y[3]);
extern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);
extern real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);
void InitCalcAtmosCOESA(real_T *temperature76, real_T *pressureRatio76);
void CalcAtmosCOESA(const real_T *altitude, real_T *temp, real_T *pressure,
                    real_T *density, real_T *speedofsound, real_T *temperature76,
                    real_T *pressureRatio76, int_T numPoints);
static uint32_T plook_bincpa(real_T u, const real_T bp[], uint32_T maxIndex,
  real_T *fraction, uint32_T *prevIndex);
static real_T intrp2d_la_pw(const uint32_T bpIndex[], const real_T frac[], const
  real_T table[], const uint32_T stride, const uint32_T maxIndex[]);
static uint32_T binsearch_u32d_prevIdx(real_T u, const real_T bp[], uint32_T
  startIndex, uint32_T maxIndex);

// private model entry point functions
extern void Lifting_wing_HIL_model_dll_derivatives();
static void rate_scheduler(MulticopterModelClass::
  RT_MODEL_Lifting_wing_HIL_mod_T *const Lifting_wing_HIL_model_dll_M);

//===========*
//  Constants *
// ===========
#define RT_PI                          3.14159265358979323846
#define RT_PIF                         3.1415927F
#define RT_LN_10                       2.30258509299404568402
#define RT_LN_10F                      2.3025851F
#define RT_LOG10E                      0.43429448190325182765
#define RT_LOG10EF                     0.43429449F
#define RT_E                           2.7182818284590452354
#define RT_EF                          2.7182817F

//
//  UNUSED_PARAMETER(x)
//    Used to specify that a function parameter (argument) is required but not
//    accessed by the function body.

#ifndef UNUSED_PARAMETER
#if defined(__LCC__)
#define UNUSED_PARAMETER(x)                                      // do nothing
#else

//
//  This is the semi-ANSI standard way of indicating that an
//  unused function parameter is required.

#define UNUSED_PARAMETER(x)            (void) (x)
#endif
#endif

extern "C"
{
  real_T rtNaN { -std::numeric_limits<real_T>::quiet_NaN() };

  real_T rtInf { std::numeric_limits<real_T>::infinity() };

  real_T rtMinusInf { -std::numeric_limits<real_T>::infinity() };

  real32_T rtNaNF { -std::numeric_limits<real32_T>::quiet_NaN() };

  real32_T rtInfF { std::numeric_limits<real32_T>::infinity() };

  real32_T rtMinusInfF { -std::numeric_limits<real32_T>::infinity() };
}

//=========*
//  Asserts *
// =========
#ifndef utAssert
#if defined(DOASSERTS)
#if !defined(PRINT_ASSERTS)
#include <assert.h>
#define utAssert(exp)                  assert(exp)
#else
#include <stdio.h>

static void _assert(char_T *statement, char_T *file, int line)
{
  printf("%s in %s on line %d\n", statement, file, line);
}

#define utAssert(_EX)                  ((_EX) ? (void)0 : _assert(#_EX, __FILE__, __LINE__))
#endif

#else
#define utAssert(exp)                                            // do nothing
#endif
#endif

extern "C"
{
  // Return rtInf needed by the generated code.
  static real_T rtGetInf(void)
  {
    return rtInf;
  }

  // Get rtInfF needed by the generated code.
  static real32_T rtGetInfF(void)
  {
    return rtInfF;
  }

  // Return rtMinusInf needed by the generated code.
  static real_T rtGetMinusInf(void)
  {
    return rtMinusInf;
  }

  // Return rtMinusInfF needed by the generated code.
  static real32_T rtGetMinusInfF(void)
  {
    return rtMinusInfF;
  }
}

extern "C"
{
  // Return rtNaN needed by the generated code.
  static real_T rtGetNaN(void)
  {
    return rtNaN;
  }

  // Return rtNaNF needed by the generated code.
  static real32_T rtGetNaNF(void)
  {
    return rtNaNF;
  }
}

extern "C"
{
  // Test if value is infinite
  static boolean_T rtIsInf(real_T value)
  {
    return std::isinf(value);
  }

  // Test if single-precision value is infinite
  static boolean_T rtIsInfF(real32_T value)
  {
    return std::isinf(value);
  }

  // Test if value is not a number
  static boolean_T rtIsNaN(real_T value)
  {
    return std::isnan(value);
  }

  // Test if single-precision value is not a number
  static boolean_T rtIsNaNF(real32_T value)
  {
    return std::isnan(value);
  }
}

//         Initialize pressure and temperature tables.
void InitCalcAtmosCOESA(real_T *temperature76, real_T *pressureRatio76)
{
  if (temperature76[0] != TEMPERATURE0 ) {
    int_T k;
    temperature76[0] = TEMPERATURE0;
    pressureRatio76[0] = 1.0;

    // set up the data at the 1976 altitude breakpoints
    for (k=0; k<(NUM1976PTS-1); k++) {
      if (tempGradient76[k] != 0.0) {
        temperature76[k+1] = temperature76[k] +
          tempGradient76[k]*(altitude76[k+1] - altitude76[k]);
        pressureRatio76[k+1] = pressureRatio76[k] *
          std::exp(std::log(temperature76[k]/temperature76[k+1]) * GMR/
                   tempGradient76[k]);
      } else {
        temperature76[k+1] = temperature76[k];
        pressureRatio76[k+1] = pressureRatio76[k] *
          std::exp((-GMR)*(altitude76[k+1] - altitude76[k])/temperature76[k]);
      }
    }
  }
}

//
//         Using cached pressure and temperature tables, find the
//         working interval and perform logarithmic interpolation.
//
void CalcAtmosCOESA(const real_T *altitude, real_T *temp, real_T *pressure,
                    real_T *density, real_T *speedofsound, real_T *temperature76,
                    real_T *pressureRatio76, int_T numPoints)
{
  int_T i;
  for (i=0; i < numPoints; i++) {
    int_T bottom = 0;
    int_T top = NUM1976PTS-1;
    int_T idx;

    // Find altitude interval using binary search
    //
    //  Deal with the extreme cases first:
    //    if altitude <= altitude76[bottom] then return idx = bottom
    //    if altitude >= altitude76[top]    then return idx = top

    if (altitude[i] <= altitude76[bottom]) {
      idx = bottom;
    } else if (altitude[i] >= altitude76[top]) {
      idx = NUM1976PTS-2;
    } else {
      for (;;) {
        idx = (bottom + top)/2;
        if (altitude[i] < altitude76[idx]) {
          top = idx - 1;
        } else if (altitude[i] >= altitude76[idx+1]) {
          bottom = idx + 1;
        } else {
          // we have altitude76[idx] <= altitude[i] < altitude76[idx+1],
          //  so break and just use idx

          break;
        }
      }
    }

    // Interval has been obtained, now do linear temperature
    //  interpolation and log pressure interpolation.

    if (tempGradient76[idx] != 0.0 ) {
      temp[i] = temperature76[idx] +
        tempGradient76[idx] * (altitude[i] - altitude76[idx]);
      pressure[i] = PRESSURE0 * pressureRatio76[idx] *
        (rt_powd_snf(temperature76[idx]/temp[i], GMR/tempGradient76[idx]));
    } else {
      temp[i] = temperature76[idx];
      pressure[i] = PRESSURE0 * pressureRatio76[idx] *
        std::exp((-GMR)*(altitude[i] - altitude76[idx]) / temperature76[idx]);
    }

    density[i] = pressure[i] / ((R_HAT/MOL_WT)*temp[i]);
    speedofsound[i] = std::sqrt(GAMMA*temp[i]*(R_HAT/MOL_WT));
  }
}

static uint32_T plook_bincpa(real_T u, const real_T bp[], uint32_T maxIndex,
  real_T *fraction, uint32_T *prevIndex)
{
  uint32_T bpIndex;

  // Prelookup - Index and Fraction
  // Index Search method: 'binary'
  // Extrapolation method: 'Clip'
  // Use previous index: 'on'
  // Use last breakpoint for index at or above upper limit: 'on'
  // Remove protection against out-of-range input in generated code: 'off'

  if (u <= bp[0U]) {
    bpIndex = 0U;
    *fraction = 0.0;
  } else if (u < bp[maxIndex]) {
    bpIndex = binsearch_u32d_prevIdx(u, bp, *prevIndex, maxIndex);
    *fraction = (u - bp[bpIndex]) / (bp[bpIndex + 1U] - bp[bpIndex]);
  } else {
    bpIndex = maxIndex;
    *fraction = 0.0;
  }

  *prevIndex = bpIndex;
  return bpIndex;
}

static real_T intrp2d_la_pw(const uint32_T bpIndex[], const real_T frac[], const
  real_T table[], const uint32_T stride, const uint32_T maxIndex[])
{
  real_T y;
  real_T yL_0d0;
  uint32_T offset_1d;

  // Column-major Interpolation 2-D
  // Interpolation method: 'Linear point-slope'
  // Use last breakpoint for index at or above upper limit: 'on'
  // Overflow mode: 'portable wrapping'

  offset_1d = bpIndex[1U] * stride + bpIndex[0U];
  if (bpIndex[0U] == maxIndex[0U]) {
    y = table[offset_1d];
  } else {
    yL_0d0 = table[offset_1d];
    y = (table[offset_1d + 1U] - yL_0d0) * frac[0U] + yL_0d0;
  }

  if (bpIndex[1U] == maxIndex[1U]) {
  } else {
    offset_1d += stride;
    if (bpIndex[0U] == maxIndex[0U]) {
      yL_0d0 = table[offset_1d];
    } else {
      yL_0d0 = table[offset_1d];
      yL_0d0 += (table[offset_1d + 1U] - yL_0d0) * frac[0U];
    }

    y += (yL_0d0 - y) * frac[1U];
  }

  return y;
}

static uint32_T binsearch_u32d_prevIdx(real_T u, const real_T bp[], uint32_T
  startIndex, uint32_T maxIndex)
{
  uint32_T bpIndex;
  uint32_T found;
  uint32_T iLeft;
  uint32_T iRght;

  // Binary Search using Previous Index
  bpIndex = startIndex;
  iLeft = 0U;
  iRght = maxIndex;
  found = 0U;
  while (found == 0U) {
    if (u < bp[bpIndex]) {
      iRght = bpIndex - 1U;
      bpIndex = ((bpIndex + iLeft) - 1U) >> 1U;
    } else if (u < bp[bpIndex + 1U]) {
      found = 1U;
    } else {
      iLeft = bpIndex + 1U;
      bpIndex = ((bpIndex + iRght) + 1U) >> 1U;
    }
  }

  return bpIndex;
}

//
//         This function updates active task flag for each subrate.
//         The function is called at model base rate, hence the
//         generated code self-manages all its subrates.
//
static void rate_scheduler(MulticopterModelClass::
  RT_MODEL_Lifting_wing_HIL_mod_T *const Lifting_wing_HIL_model_dll_M)
{
  // Compute which subrates run during the next base time step.  Subrates
  //  are an integer multiple of the base rate counter.  Therefore, the subtask
  //  counter is reset when it reaches its limit (zero means run).

  (Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[2])++;
  if ((Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[2]) > 3) {// Sample time: [0.004s, 0.0s] 
    Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[2] = 0;
  }

  (Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[3])++;
  if ((Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[3]) > 19) {// Sample time: [0.02s, 0.0s] 
    Lifting_wing_HIL_model_dll_M->Timing.TaskCounters.TID[3] = 0;
  }
}

//
// This function updates continuous states using the ODE4 fixed-step
// solver algorithm
//
void MulticopterModelClass::rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )
{
  time_T t { rtsiGetT(si) };

  time_T tnew { rtsiGetSolverStopTime(si) };

  time_T h { rtsiGetStepSize(si) };

  real_T *x { rtsiGetContStates(si) };

  ODE4_IntgData *id { static_cast<ODE4_IntgData *>(rtsiGetSolverData(si)) };

  real_T *y { id->y };

  real_T *f0 { id->f[0] };

  real_T *f1 { id->f[1] };

  real_T *f2 { id->f[2] };

  real_T *f3 { id->f[3] };

  real_T temp;
  int_T i;
  int_T nXc { 90 };

  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);

  // Save the state values at time t in y, we'll use x as ynew.
  (void) std::memcpy(y, x,
                     static_cast<uint_T>(nXc)*sizeof(real_T));

  // Assumes that rtsiSetT and ModelOutputs are up-to-date
  // f0 = f(t,y)
  rtsiSetdX(si, f0);
  Lifting_wing_HIL_model_dll_derivatives();

  // f1 = f(t + (h/2), y + (h/2)*f0)
  temp = 0.5 * h;
  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (temp*f0[i]);
  }

  rtsiSetT(si, t + temp);
  rtsiSetdX(si, f1);
  this->step();
  Lifting_wing_HIL_model_dll_derivatives();

  // f2 = f(t + (h/2), y + (h/2)*f1)
  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (temp*f1[i]);
  }

  rtsiSetdX(si, f2);
  this->step();
  Lifting_wing_HIL_model_dll_derivatives();

  // f3 = f(t + h, y + h*f2)
  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + (h*f2[i]);
  }

  rtsiSetT(si, tnew);
  rtsiSetdX(si, f3);
  this->step();
  Lifting_wing_HIL_model_dll_derivatives();

  // tnew = t + h
  // ynew = y + (h/6)*(f0 + 2*f1 + 2*f2 + 2*f3)
  temp = h / 6.0;
  for (i = 0; i < nXc; i++) {
    x[i] = y[i] + temp*(f0[i] + 2.0*f1[i] + 2.0*f2[i] + f3[i]);
  }

  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);
}

//
// Output and update for action system:
//    '<S26>/If Action Subsystem'
//    '<S35>/If Action Subsystem'
//    '<S135>/If Action Subsystem'
//    '<S144>/If Action Subsystem'
//    '<S189>/If Action Subsystem'
//    '<S198>/If Action Subsystem'
//
void MulticopterModelClass::Lifting_wing__IfActionSubsystem(real_T rtu_u, real_T
  rtu_absu, real_T *rty_signu)
{
  // Product: '<S28>/Divide'
  *rty_signu = rtu_u / rtu_absu;
}

//
// Output and update for action system:
//    '<S26>/If Action Subsystem1'
//    '<S135>/If Action Subsystem1'
//    '<S189>/If Action Subsystem1'
//
void MulticopterModelClass::Lifting_wing_IfActionSubsystem1(real_T *rty_zero,
  P_IfActionSubsystem1_Lifting__T *localP)
{
  if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
      (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
    // SignalConversion generated from: '<S29>/zero' incorporates:
    //   Constant: '<S29>/Constant'

    *rty_zero = localP->Constant_Value;
  }
}

//
// Output and update for action system:
//    '<S35>/If Action Subsystem1'
//    '<S144>/If Action Subsystem1'
//    '<S198>/If Action Subsystem1'
//
void MulticopterModelClass::Lifting_wi_IfActionSubsystem1_g(real_T *rty_zero,
  P_IfActionSubsystem1_Liftin_b_T *localP)
{
  // SignalConversion generated from: '<S38>/zero' incorporates:
  //   Constant: '<S38>/Constant'

  *rty_zero = localP->Constant_Value;
}

//
// Output and update for action system:
//    '<S47>/Positive Trace'
//    '<S296>/Positive Trace'
//
void MulticopterModelClass::Lifting_wing_HIL__PositiveTrace(real_T rtu_traceDCM,
  const real_T rtu_DCM[9], real_T rty_qwqxqyqz[4],
  P_PositiveTrace_Lifting_wing__T *localP)
{
  real_T rtb_sqrt;

  // Sqrt: '<S49>/sqrt' incorporates:
  //   Constant: '<S49>/Constant'
  //   Sum: '<S49>/Sum'

  rtb_sqrt = std::sqrt(rtu_traceDCM + localP->Constant_Value);

  // Gain: '<S49>/Gain'
  rty_qwqxqyqz[0] = localP->Gain_Gain * rtb_sqrt;

  // Gain: '<S49>/Gain1'
  rtb_sqrt *= localP->Gain1_Gain;

  // Product: '<S49>/Product' incorporates:
  //   Sum: '<S71>/Add'
  //   Sum: '<S72>/Add'
  //   Sum: '<S73>/Add'

  rty_qwqxqyqz[1] = (rtu_DCM[7] - rtu_DCM[5]) / rtb_sqrt;
  rty_qwqxqyqz[2] = (rtu_DCM[2] - rtu_DCM[6]) / rtb_sqrt;
  rty_qwqxqyqz[3] = (rtu_DCM[3] - rtu_DCM[1]) / rtb_sqrt;
}

//
// System initialize for action system:
//    '<S47>/Negative Trace'
//    '<S296>/Negative Trace'
//
void MulticopterModelClass::Lifting_wing_NegativeTrace_Init
  (DW_NegativeTrace_Lifting_wing_T *localDW)
{
  // Start for If: '<S48>/Find Maximum Diagonal Value'
  localDW->FindMaximumDiagonalValue_Active = -1;
}

//
// Output and update for action system:
//    '<S47>/Negative Trace'
//    '<S296>/Negative Trace'
//
void MulticopterModelClass::Lifting_wing_HIL__NegativeTrace(const real_T
  rtu_DCM[9], real_T rty_qwqxqyqz[4], DW_NegativeTrace_Lifting_wing_T *localDW,
  P_NegativeTrace_Lifting_wing__T *localP)
{
  real_T rtb_Product_p_idx_0;
  real_T rtb_Product_p_idx_1;
  real_T rtb_Product_p_idx_2;
  real_T rtb_Switch_l_idx_0;
  real_T rtb_Switch_l_idx_1;
  real_T rtb_sqrt;
  int8_T rtAction;
  int8_T rtPrevAction;

  // If: '<S48>/Find Maximum Diagonal Value'
  rtPrevAction = localDW->FindMaximumDiagonalValue_Active;
  if (rtsiIsModeUpdateTimeStep(&(&Lifting_wing_HIL_model_dll_M)->solverInfo)) {
    if ((rtu_DCM[4] > rtu_DCM[0]) && (rtu_DCM[4] > rtu_DCM[8])) {
      rtAction = 0;
    } else if (rtu_DCM[8] > rtu_DCM[0]) {
      rtAction = 1;
    } else {
      rtAction = 2;
    }

    localDW->FindMaximumDiagonalValue_Active = rtAction;
  } else {
    rtAction = localDW->FindMaximumDiagonalValue_Active;
  }

  if (rtPrevAction != rtAction) {
    rtsiSetBlockStateForSolverChangedAtMajorStep(&(&Lifting_wing_HIL_model_dll_M)
      ->solverInfo, true);
  }

  switch (rtAction) {
   case 0:
    // Outputs for IfAction SubSystem: '<S48>/Maximum Value at DCM(2,2)' incorporates:
    //   ActionPort: '<S53>/Action Port'

    // Sum: '<S63>/Add'
    rtb_Product_p_idx_0 = rtu_DCM[1] + rtu_DCM[3];

    // Sum: '<S62>/Add'
    rtb_Product_p_idx_1 = rtu_DCM[5] + rtu_DCM[7];

    // Sum: '<S61>/Add'
    rtb_Product_p_idx_2 = rtu_DCM[2] - rtu_DCM[6];

    // Sum: '<S65>/Add' incorporates:
    //   Constant: '<S65>/Constant'

    rtb_sqrt = ((rtu_DCM[4] - rtu_DCM[0]) - rtu_DCM[8]) + localP->Constant_Value;

    // Sqrt: '<S53>/sqrt'
    rtb_sqrt = std::sqrt(rtb_sqrt);

    // Switch: '<S64>/Switch' incorporates:
    //   Abs: '<S64>/Abs'
    //   Constant: '<S64>/Constant1'
    //   Constant: '<S64>/Constant2'

    if (rtb_sqrt > localP->Switch_Threshold) {
      rtb_Switch_l_idx_0 = localP->Constant1_Value;
      rtb_Switch_l_idx_1 = rtb_sqrt;
    } else {
      rtb_Switch_l_idx_0 = localP->Constant2_Value[0];
      rtb_Switch_l_idx_1 = localP->Constant2_Value[1];
    }

    // End of Switch: '<S64>/Switch'

    // Product: '<S64>/Product'
    rtb_Switch_l_idx_0 /= rtb_Switch_l_idx_1;

    // SignalConversion generated from: '<S53>/Vector Concatenate1' incorporates:
    //   Product: '<S53>/Product'

    rty_qwqxqyqz[0] = rtb_Product_p_idx_2 * rtb_Switch_l_idx_0;

    // SignalConversion generated from: '<S53>/Vector Concatenate1' incorporates:
    //   Product: '<S53>/Product'

    rty_qwqxqyqz[1] = rtb_Product_p_idx_0 * rtb_Switch_l_idx_0;

    // SignalConversion generated from: '<S53>/Vector Concatenate1' incorporates:
    //   Product: '<S53>/Product'

    rty_qwqxqyqz[3] = rtb_Product_p_idx_1 * rtb_Switch_l_idx_0;

    // Gain: '<S53>/Gain'
    rty_qwqxqyqz[2] = localP->Gain_Gain * rtb_sqrt;

    // End of Outputs for SubSystem: '<S48>/Maximum Value at DCM(2,2)'
    break;

   case 1:
    // Outputs for IfAction SubSystem: '<S48>/Maximum Value at DCM(3,3)' incorporates:
    //   ActionPort: '<S54>/Action Port'

    // Sum: '<S66>/Add'
    rtb_Product_p_idx_0 = rtu_DCM[2] + rtu_DCM[6];

    // Sum: '<S67>/Add'
    rtb_Product_p_idx_1 = rtu_DCM[5] + rtu_DCM[7];

    // Sum: '<S68>/Add'
    rtb_Product_p_idx_2 = rtu_DCM[3] - rtu_DCM[1];

    // Sum: '<S70>/Add' incorporates:
    //   Constant: '<S70>/Constant'

    rtb_sqrt = ((rtu_DCM[8] - rtu_DCM[0]) - rtu_DCM[4]) +
      localP->Constant_Value_n;

    // Sqrt: '<S54>/sqrt'
    rtb_sqrt = std::sqrt(rtb_sqrt);

    // Switch: '<S69>/Switch' incorporates:
    //   Abs: '<S69>/Abs'
    //   Constant: '<S69>/Constant1'
    //   Constant: '<S69>/Constant2'

    if (rtb_sqrt > localP->Switch_Threshold_a) {
      rtb_Switch_l_idx_0 = localP->Constant1_Value_e;
      rtb_Switch_l_idx_1 = rtb_sqrt;
    } else {
      rtb_Switch_l_idx_0 = localP->Constant2_Value_o[0];
      rtb_Switch_l_idx_1 = localP->Constant2_Value_o[1];
    }

    // End of Switch: '<S69>/Switch'

    // Product: '<S69>/Product'
    rtb_Switch_l_idx_0 /= rtb_Switch_l_idx_1;

    // SignalConversion generated from: '<S54>/Vector Concatenate1' incorporates:
    //   Product: '<S54>/Product'

    rty_qwqxqyqz[0] = rtb_Product_p_idx_2 * rtb_Switch_l_idx_0;

    // SignalConversion generated from: '<S54>/Vector Concatenate1' incorporates:
    //   Product: '<S54>/Product'

    rty_qwqxqyqz[1] = rtb_Product_p_idx_0 * rtb_Switch_l_idx_0;

    // SignalConversion generated from: '<S54>/Vector Concatenate1' incorporates:
    //   Product: '<S54>/Product'

    rty_qwqxqyqz[2] = rtb_Product_p_idx_1 * rtb_Switch_l_idx_0;

    // Gain: '<S54>/Gain'
    rty_qwqxqyqz[3] = localP->Gain_Gain_i * rtb_sqrt;

    // End of Outputs for SubSystem: '<S48>/Maximum Value at DCM(3,3)'
    break;

   default:
    // Outputs for IfAction SubSystem: '<S48>/Maximum Value at DCM(1,1)' incorporates:
    //   ActionPort: '<S52>/Action Port'

    // Sum: '<S60>/Add' incorporates:
    //   Constant: '<S60>/Constant'

    rtb_sqrt = ((rtu_DCM[0] - rtu_DCM[4]) - rtu_DCM[8]) +
      localP->Constant_Value_i;

    // Sqrt: '<S52>/sqrt'
    rtb_sqrt = std::sqrt(rtb_sqrt);

    // Switch: '<S59>/Switch' incorporates:
    //   Abs: '<S59>/Abs'
    //   Constant: '<S59>/Constant1'
    //   Constant: '<S59>/Constant2'

    if (rtb_sqrt > localP->Switch_Threshold_k) {
      rtb_Switch_l_idx_0 = localP->Constant1_Value_f;
      rtb_Switch_l_idx_1 = rtb_sqrt;
    } else {
      rtb_Switch_l_idx_0 = localP->Constant2_Value_j[0];
      rtb_Switch_l_idx_1 = localP->Constant2_Value_j[1];
    }

    // End of Switch: '<S59>/Switch'

    // Product: '<S59>/Product'
    rtb_Switch_l_idx_0 /= rtb_Switch_l_idx_1;

    // Sum: '<S58>/Add'
    rtb_Product_p_idx_0 = rtu_DCM[1] + rtu_DCM[3];

    // Sum: '<S56>/Add'
    rtb_Product_p_idx_1 = rtu_DCM[2] + rtu_DCM[6];

    // Sum: '<S57>/Add'
    rtb_Product_p_idx_2 = rtu_DCM[7] - rtu_DCM[5];

    // SignalConversion generated from: '<S52>/Vector Concatenate1' incorporates:
    //   Product: '<S52>/Product'

    rty_qwqxqyqz[0] = rtb_Switch_l_idx_0 * rtb_Product_p_idx_2;

    // SignalConversion generated from: '<S52>/Vector Concatenate1' incorporates:
    //   Product: '<S52>/Product'

    rty_qwqxqyqz[2] = rtb_Switch_l_idx_0 * rtb_Product_p_idx_0;

    // SignalConversion generated from: '<S52>/Vector Concatenate1' incorporates:
    //   Product: '<S52>/Product'

    rty_qwqxqyqz[3] = rtb_Switch_l_idx_0 * rtb_Product_p_idx_1;

    // Gain: '<S52>/Gain'
    rty_qwqxqyqz[1] = localP->Gain_Gain_a * rtb_sqrt;

    // End of Outputs for SubSystem: '<S48>/Maximum Value at DCM(1,1)'
    break;
  }

  // End of If: '<S48>/Find Maximum Diagonal Value'
}

//
// Output and update for action system:
//    '<S50>/If Warning//Error'
//    '<S339>/If Warning//Error'
//
void MulticopterModelClass::Lifting_wing_HIL_IfWarningError(const real_T
  rtu_dcm[9], uint8_T rtp_action, real_T rtp_tolerance,
  P_IfWarningError_Lifting_wing_T *localP)
{
  real_T rtu_dcm_0[9];
  boolean_T rtb_Compare_n[9];
  boolean_T tmp;

  // Bias: '<S78>/Bias1' incorporates:
  //   Math: '<S78>/Math Function'
  //   Product: '<S78>/Product'

  for (int32_T i{0}; i < 3; i++) {
    for (int32_T i_0{0}; i_0 < 3; i_0++) {
      int32_T rtu_dcm_tmp;
      rtu_dcm_tmp = 3 * i_0 + i;
      rtu_dcm_0[rtu_dcm_tmp] = ((rtu_dcm[3 * i + 1] * rtu_dcm[3 * i_0 + 1] +
        rtu_dcm[3 * i] * rtu_dcm[3 * i_0]) + rtu_dcm[3 * i + 2] * rtu_dcm[3 *
        i_0 + 2]) + localP->Bias1_Bias[rtu_dcm_tmp];
    }
  }

  // End of Bias: '<S78>/Bias1'

  // RelationalOperator: '<S86>/Compare' incorporates:
  //   Abs: '<S78>/Abs2'
  //   Constant: '<S86>/Constant'

  for (int32_T i{0}; i < 9; i++) {
    rtb_Compare_n[i] = (std::abs(rtu_dcm_0[i]) > rtp_tolerance);
  }

  // End of RelationalOperator: '<S86>/Compare'

  // Logic: '<S78>/Logical Operator1' incorporates:
  //   RelationalOperator: '<S86>/Compare'

  tmp = rtb_Compare_n[0];
  for (int32_T i{0}; i < 8; i++) {
    tmp = (tmp || rtb_Compare_n[i + 1]);
  }

  // If: '<S74>/If' incorporates:
  //   Abs: '<S79>/Abs1'
  //   Bias: '<S79>/Bias'
  //   Constant: '<S88>/Constant'
  //   Logic: '<S78>/Logical Operator1'
  //   Product: '<S87>/Product'
  //   Product: '<S87>/Product1'
  //   Product: '<S87>/Product2'
  //   Product: '<S87>/Product3'
  //   Product: '<S87>/Product4'
  //   Product: '<S87>/Product5'
  //   RelationalOperator: '<S88>/Compare'
  //   Reshape: '<S87>/Reshape'
  //   Sum: '<S87>/Sum'

  if (std::abs((((((rtu_dcm[0] * rtu_dcm[4] * rtu_dcm[8] - rtu_dcm[0] * rtu_dcm
                    [5] * rtu_dcm[7]) - rtu_dcm[1] * rtu_dcm[3] * rtu_dcm[8]) +
                  rtu_dcm[2] * rtu_dcm[3] * rtu_dcm[7]) + rtu_dcm[1] * rtu_dcm[5]
                 * rtu_dcm[6]) - rtu_dcm[2] * rtu_dcm[4] * rtu_dcm[6]) +
               localP->Bias_Bias) > rtp_tolerance) {
    // Outputs for IfAction SubSystem: '<S74>/If Not Proper' incorporates:
    //   ActionPort: '<S77>/Action Port'

    // If: '<S77>/If' incorporates:
    //   Constant: '<S77>/Constant'

    if (rtp_action == 2) {
      // Outputs for IfAction SubSystem: '<S77>/Warning' incorporates:
      //   ActionPort: '<S85>/Action Port'

      // Assertion: '<S85>/Assertion' incorporates:
      //   Constant: '<S77>/Constant1'

      utAssert(localP->Constant1_Value != 0.0);

      // End of Outputs for SubSystem: '<S77>/Warning'
    } else if (rtp_action == 3) {
      // Outputs for IfAction SubSystem: '<S77>/Error' incorporates:
      //   ActionPort: '<S83>/Action Port'

      // Assertion: '<S83>/Assertion' incorporates:
      //   Constant: '<S77>/Constant1'

      utAssert(localP->Constant1_Value != 0.0);

      // End of Outputs for SubSystem: '<S77>/Error'
    }

    // End of If: '<S77>/If'
    // End of Outputs for SubSystem: '<S74>/If Not Proper'
  } else if (tmp) {
    // Outputs for IfAction SubSystem: '<S74>/Else If Not Orthogonal' incorporates:
    //   ActionPort: '<S75>/Action Port'

    // If: '<S75>/If' incorporates:
    //   Constant: '<S75>/Constant'

    if (rtp_action == 2) {
      // Outputs for IfAction SubSystem: '<S75>/Warning' incorporates:
      //   ActionPort: '<S82>/Action Port'

      // Assertion: '<S82>/Assertion' incorporates:
      //   Constant: '<S75>/Constant1'

      utAssert(localP->Constant1_Value_i != 0.0);

      // End of Outputs for SubSystem: '<S75>/Warning'
    } else if (rtp_action == 3) {
      // Outputs for IfAction SubSystem: '<S75>/Error' incorporates:
      //   ActionPort: '<S80>/Action Port'

      // Assertion: '<S80>/Assertion' incorporates:
      //   Constant: '<S75>/Constant1'

      utAssert(localP->Constant1_Value_i != 0.0);

      // End of Outputs for SubSystem: '<S75>/Error'
    }

    // End of If: '<S75>/If'
    // End of Outputs for SubSystem: '<S74>/Else If Not Orthogonal'
  }

  // End of If: '<S74>/If'
}

//
// System initialize for enable system:
//    '<S215>/Distance into gust (y)'
//    '<S215>/Distance into gust (z)'
//
void MulticopterModelClass::Lifting__Distanceintogusty_Init
  (B_Distanceintogusty_Lifting_w_T *localB, P_Distanceintogusty_Lifting_w_T
   *localP, X_Distanceintogusty_Lifting_w_T *localX)
{
  // InitializeConditions for Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) ' 
  localX->DistanceintoGustxLimitedtogustl =
    localP->DistanceintoGustxLimitedtogustl;

  // SystemInitialize for Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) ' incorporates:
  //   Outport: '<S219>/x'

  localB->DistanceintoGustxLimitedtogustl = localP->x_Y0;
}

//
// System reset for enable system:
//    '<S215>/Distance into gust (y)'
//    '<S215>/Distance into gust (z)'
//
void MulticopterModelClass::Lifting_Distanceintogusty_Reset
  (P_Distanceintogusty_Lifting_w_T *localP, X_Distanceintogusty_Lifting_w_T
   *localX)
{
  // InitializeConditions for Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) ' 
  localX->DistanceintoGustxLimitedtogustl =
    localP->DistanceintoGustxLimitedtogustl;
}

//
// Disable for enable system:
//    '<S215>/Distance into gust (y)'
//    '<S215>/Distance into gust (z)'
//
void MulticopterModelClass::Lifti_Distanceintogusty_Disable
  (DW_Distanceintogusty_Lifting__T *localDW)
{
  localDW->Distanceintogusty_MODE = false;
}

//
// Outputs for enable system:
//    '<S215>/Distance into gust (y)'
//    '<S215>/Distance into gust (z)'
//
void MulticopterModelClass::Lifting_wing__Distanceintogusty(boolean_T rtu_Enable,
  real_T rtp_d_m, B_Distanceintogusty_Lifting_w_T *localB,
  DW_Distanceintogusty_Lifting__T *localDW, P_Distanceintogusty_Lifting_w_T
  *localP, X_Distanceintogusty_Lifting_w_T *localX,
  XDis_Distanceintogusty_Liftin_T *localXdis)
{
  // Outputs for Enabled SubSystem: '<S215>/Distance into gust (y)' incorporates:
  //   EnablePort: '<S219>/Enable'

  if (((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
       (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) &&
      rtsiIsModeUpdateTimeStep(&(&Lifting_wing_HIL_model_dll_M)->solverInfo)) {
    if (rtu_Enable) {
      if (!localDW->Distanceintogusty_MODE) {
        (void) std::memset(&(localXdis->DistanceintoGustxLimitedtogustl), 0,
                           1*sizeof(boolean_T));
        Lifting_Distanceintogusty_Reset(localP, localX);
        localDW->Distanceintogusty_MODE = true;
      }
    } else {
      // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
      //   EnablePort: '<S218>/Enable'

      if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) ==
          ((&Lifting_wing_HIL_model_dll_M)->getTStart())) {
        (void) std::memset(&(localXdis->DistanceintoGustxLimitedtogustl), 1,
                           1*sizeof(boolean_T));
      }

      // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
      if (localDW->Distanceintogusty_MODE) {
        (void) std::memset(&(localXdis->DistanceintoGustxLimitedtogustl), 1,
                           1*sizeof(boolean_T));
        Lifti_Distanceintogusty_Disable(localDW);
      }
    }
  }

  if (localDW->Distanceintogusty_MODE) {
    // Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) '
    // Limited  Integrator
    if (localX->DistanceintoGustxLimitedtogustl >= rtp_d_m) {
      localX->DistanceintoGustxLimitedtogustl = rtp_d_m;
    } else if (localX->DistanceintoGustxLimitedtogustl <=
               localP->DistanceintoGustxLimitedtogus_g) {
      localX->DistanceintoGustxLimitedtogustl =
        localP->DistanceintoGustxLimitedtogus_g;
    }

    // Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) '
    localB->DistanceintoGustxLimitedtogustl =
      localX->DistanceintoGustxLimitedtogustl;
  }

  // End of Outputs for SubSystem: '<S215>/Distance into gust (y)'
}

//
// Derivatives for enable system:
//    '<S215>/Distance into gust (y)'
//    '<S215>/Distance into gust (z)'
//
void MulticopterModelClass::Lifting_Distanceintogusty_Deriv(real_T rtu_V, real_T
  rtp_d_m, DW_Distanceintogusty_Lifting__T *localDW,
  P_Distanceintogusty_Lifting_w_T *localP, X_Distanceintogusty_Lifting_w_T
  *localX, XDot_Distanceintogusty_Liftin_T *localXdot)
{
  boolean_T lsat;
  boolean_T usat;
  if (localDW->Distanceintogusty_MODE) {
    // Derivatives for Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) ' 
    lsat = (localX->DistanceintoGustxLimitedtogustl <=
            localP->DistanceintoGustxLimitedtogus_g);
    usat = (localX->DistanceintoGustxLimitedtogustl >= rtp_d_m);
    if (((!lsat) && (!usat)) || (lsat && (rtu_V > 0.0)) || (usat && (rtu_V < 0.0)))
    {
      localXdot->DistanceintoGustxLimitedtogustl = rtu_V;
    } else {
      // in saturation
      localXdot->DistanceintoGustxLimitedtogustl = 0.0;
    }

    // End of Derivatives for Integrator: '<S219>/Distance into Gust (x) (Limited to gust length d) ' 
  } else {
    localXdot->DistanceintoGustxLimitedtogustl = 0.0;
  }
}

//
// Output and update for atomic system:
//    '<S284>/MATLAB Function'
//    '<S285>/MATLAB Function'
//
void MulticopterModelClass::Lifting_wing_HIL_MATLABFunction(real_T rtu_Ad,
  real_T rtu_dt, real_T rtu_rate_max, B_MATLABFunction_Lifting_wing_T *localB,
  DW_MATLABFunction_Lifting_win_T *localDW)
{
  real_T Ad_rate_ref;

  // MATLAB Function 'Subsystem Reference/Motor and Servo Model/Subsystem/MATLAB Function': '<S292>:1' 
  // '<S292>:1:3' if isempty(Ad_last)
  // '<S292>:1:7' Ad_rate_ref = (Ad - Ad_last) / dt;
  Ad_rate_ref = (rtu_Ad - localDW->Ad_last) / rtu_dt;

  // '<S292>:1:8' Aa = Ad;
  localB->Aa = rtu_Ad;

  // '<S292>:1:9' if Ad_rate_ref > rate_max
  if (Ad_rate_ref > rtu_rate_max) {
    // '<S292>:1:10' Aa = Ad_last + rate_max * dt;
    localB->Aa = rtu_rate_max * rtu_dt + localDW->Ad_last;
  } else if (Ad_rate_ref < -rtu_rate_max) {
    // '<S292>:1:11' elseif Ad_rate_ref < -rate_max
    // '<S292>:1:12' Aa = Ad_last - rate_max * dt;
    localB->Aa = localDW->Ad_last - rtu_rate_max * rtu_dt;
  }

  // '<S292>:1:15' Ad_last = Aa;
  localDW->Ad_last = localB->Aa;
}

//
// Output and update for atomic system:
//    '<S174>/throttle2rads2'
//    '<S174>/throttle2rads3'
//
void MulticopterModelClass::Lifting_wing_HIL_throttle2rads2(real_T rtu_throttle,
  B_throttle2rads2_Lifting_wing_T *localB) const
{
  real_T throttle;

  // MATLAB Function 'Subsystem Reference/Motor and Servo Model/throttle2rads2': '<S290>:1' 
  // '<S290>:1:3' throttle = throttle*ModelParam_efficiency;
  throttle = rtu_throttle * Lifting_wing_HIL_model_dll_P.ModelParam_efficiency;

  // '<S290>:1:4' y = ModelParam_motorp1*throttle^2 + ModelParam_motorp2*throttle + ModelParam_motorp3; 
  localB->y = (throttle * throttle *
               Lifting_wing_HIL_model_dll_P.ModelParam_motorp1 +
               Lifting_wing_HIL_model_dll_P.ModelParam_motorp2 * throttle) +
    Lifting_wing_HIL_model_dll_P.ModelParam_motorp3;
}

real_T rt_modd_snf(real_T u0, real_T u1)
{
  real_T y;
  y = u0;
  if (u1 == 0.0) {
    if (u0 == 0.0) {
      y = u1;
    }
  } else if (std::isnan(u0) || std::isnan(u1) || std::isinf(u0)) {
    y = (rtNaN);
  } else if (u0 == 0.0) {
    y = 0.0 / u1;
  } else if (std::isinf(u1)) {
    if ((u1 < 0.0) != (u0 < 0.0)) {
      y = u1;
    }
  } else {
    boolean_T yEq;
    y = std::fmod(u0, u1);
    yEq = (y == 0.0);
    if ((!yEq) && (u1 > std::floor(u1))) {
      real_T q;
      q = std::abs(u0 / u1);
      yEq = !(std::abs(q - std::floor(q + 0.5)) > DBL_EPSILON * q);
    }

    if (yEq) {
      y = u1 * 0.0;
    } else if ((u0 < 0.0) != (u1 < 0.0)) {
      y += u1;
    }
  }

  return y;
}

real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = (rtNaN);
  } else {
    real_T tmp;
    real_T tmp_0;
    tmp = std::abs(u0);
    tmp_0 = std::abs(u1);
    if (std::isinf(u1)) {
      if (tmp == 1.0) {
        y = 1.0;
      } else if (tmp > 1.0) {
        if (u1 > 0.0) {
          y = (rtInf);
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = (rtInf);
      }
    } else if (tmp_0 == 0.0) {
      y = 1.0;
    } else if (tmp_0 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = std::sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > std::floor(u1))) {
      y = (rtNaN);
    } else {
      y = std::pow(u0, u1);
    }
  }

  return y;
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  if (std::isnan(u0) || std::isnan(u1)) {
    y = (rtNaN);
  } else if (std::isinf(u0) && std::isinf(u1)) {
    int32_T tmp;
    int32_T tmp_0;
    if (u0 > 0.0) {
      tmp = 1;
    } else {
      tmp = -1;
    }

    if (u1 > 0.0) {
      tmp_0 = 1;
    } else {
      tmp_0 = -1;
    }

    y = std::atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = std::atan2(u0, u1);
  }

  return y;
}

// Function for MATLAB Function: '<S170>/aerodynamic coefficients'
real_T MulticopterModelClass::Lifting_wing_HIL_model_dl_ppval(const real_T
  pp_breaks[1000], const real_T pp_coefs[3996], real_T x)
{
  real_T v;
  if (std::isnan(x)) {
    v = (rtNaN);
  } else {
    int32_T high_i;
    int32_T low_i;
    int32_T low_ip1;
    high_i = 1000;
    low_i = 0;
    low_ip1 = 2;
    while (high_i > low_ip1) {
      int32_T mid_i;
      mid_i = ((low_i + high_i) + 1) >> 1;
      if (x >= pp_breaks[mid_i - 1]) {
        low_i = mid_i - 1;
        low_ip1 = mid_i + 1;
      } else {
        high_i = mid_i;
      }
    }

    real_T xloc;
    xloc = x - pp_breaks[low_i];
    v = ((xloc * pp_coefs[low_i] + pp_coefs[low_i + 999]) * xloc +
         pp_coefs[low_i + 1998]) * xloc + pp_coefs[low_i + 2997];
  }

  return v;
}

void rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(const real_T u0[3], const real_T u1[9],
  real_T y[3])
{
  real_T A[9];
  real_T a21;
  real_T maxval;
  int32_T r1;
  int32_T r2;
  int32_T r3;
  std::memcpy(&A[0], &u1[0], 9U * sizeof(real_T));
  r1 = 0;
  r2 = 1;
  r3 = 2;
  maxval = std::abs(u1[0]);
  a21 = std::abs(u1[1]);
  if (a21 > maxval) {
    maxval = a21;
    r1 = 1;
    r2 = 0;
  }

  if (std::abs(u1[2]) > maxval) {
    r1 = 2;
    r2 = 1;
    r3 = 0;
  }

  A[r2] = u1[r2] / u1[r1];
  A[r3] /= A[r1];
  A[r2 + 3] -= A[r1 + 3] * A[r2];
  A[r3 + 3] -= A[r1 + 3] * A[r3];
  A[r2 + 6] -= A[r1 + 6] * A[r2];
  A[r3 + 6] -= A[r1 + 6] * A[r3];
  if (std::abs(A[r3 + 3]) > std::abs(A[r2 + 3])) {
    int32_T rtemp;
    rtemp = r2 + 1;
    r2 = r3;
    r3 = rtemp - 1;
  }

  A[r3 + 3] /= A[r2 + 3];
  A[r3 + 6] -= A[r3 + 3] * A[r2 + 6];
  y[r1] = u0[0] / A[r1];
  y[r2] = u0[1] - A[r1 + 3] * y[r1];
  y[r3] = u0[2] - A[r1 + 6] * y[r1];
  y[r2] /= A[r2 + 3];
  y[r3] -= A[r2 + 6] * y[r2];
  y[r3] /= A[r3 + 6];
  y[r2] -= A[r3 + 3] * y[r3];
  y[r1] -= y[r3] * A[r3];
  y[r1] -= y[r2] * A[r2];
}

// Function for MATLAB Function: '<Root>/CollisionDetection'
real_T MulticopterModelClass::Lifting_wing_eml_rand_mt19937ar(uint32_T state[625])
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = state[624] + 1U;
      if (state[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (state[kk + 1] & 2147483647U) | (state[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          state[kk] = state[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (state[kk + 227] & 2147483648U) | (state[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          state[kk + 227] = state[kk] ^ mti;
        }

        mti = (state[623] & 2147483648U) | (state[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        state[623] = state[396] ^ mti;
        mti = 1U;
      }

      y = state[static_cast<int32_T>(mti) - 1];
      state[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((state[624] >= 1U) && (state[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (state[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        mti = 5489U;
        state[0] = 5489U;
        for (k = 0; k < 623; k++) {
          mti = ((mti >> 30U ^ mti) * 1812433253U + static_cast<uint32_T>(k)) +
            1U;
          state[k + 1] = mti;
        }

        state[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<Root>/CollisionDetection'
real_T MulticopterModelClass::Lifting_wing__eml_rand_mcg16807(uint32_T *state)
{
  real_T r;
  int32_T hi;
  uint32_T a;
  uint32_T b;
  hi = static_cast<int32_T>(*state / 127773U);
  a = (*state - static_cast<uint32_T>(hi) * 127773U) * 16807U;
  b = 2836U * static_cast<uint32_T>(hi);
  if (a < b) {
    a = ~(b - a) & 2147483647U;
  } else {
    a -= b;
  }

  r = static_cast<real_T>(a) * 4.6566128752457969E-10;
  *state = a;
  return r;
}

// Function for MATLAB Function: '<Root>/CollisionDetection'
real_T MulticopterModelClass::Lifting_wing_HIL_model_dll_rand(void)
{
  real_T r;
  uint32_T b;
  uint32_T c;
  switch (Lifting_wing_HIL_model_dll_DW.method) {
   case 4U:
    r = Lifting_wing__eml_rand_mcg16807(&Lifting_wing_HIL_model_dll_DW.state_gk);
    break;

   case 5U:
    b = 69069U * Lifting_wing_HIL_model_dll_DW.state_as[0] + 1234567U;
    c = Lifting_wing_HIL_model_dll_DW.state_as[1] << 13 ^
      Lifting_wing_HIL_model_dll_DW.state_as[1];
    c ^= c >> 17;
    c ^= c << 5;
    Lifting_wing_HIL_model_dll_DW.state_as[0] = b;
    Lifting_wing_HIL_model_dll_DW.state_as[1] = c;
    r = static_cast<real_T>(b + c) * 2.328306436538696E-10;
    break;

   default:
    r = Lifting_wing_eml_rand_mt19937ar(Lifting_wing_HIL_model_dll_DW.state_bm);
    break;
  }

  return r;
}

// Function for MATLAB Function: '<Root>/CollisionDetection'
void MulticopterModelClass::Lifting_wing_HIL_model_d_rand_o(real_T r[3])
{
  uint32_T b;
  uint32_T c;
  switch (Lifting_wing_HIL_model_dll_DW.method) {
   case 4U:
    r[0] = Lifting_wing__eml_rand_mcg16807
      (&Lifting_wing_HIL_model_dll_DW.state_gk);
    r[1] = Lifting_wing__eml_rand_mcg16807
      (&Lifting_wing_HIL_model_dll_DW.state_gk);
    r[2] = Lifting_wing__eml_rand_mcg16807
      (&Lifting_wing_HIL_model_dll_DW.state_gk);
    break;

   case 5U:
    b = 69069U * Lifting_wing_HIL_model_dll_DW.state_as[0] + 1234567U;
    c = Lifting_wing_HIL_model_dll_DW.state_as[1] << 13 ^
      Lifting_wing_HIL_model_dll_DW.state_as[1];
    c ^= c >> 17;
    c ^= c << 5;
    Lifting_wing_HIL_model_dll_DW.state_as[0] = b;
    Lifting_wing_HIL_model_dll_DW.state_as[1] = c;
    r[0] = static_cast<real_T>(b + c) * 2.328306436538696E-10;
    b = 69069U * Lifting_wing_HIL_model_dll_DW.state_as[0] + 1234567U;
    c = Lifting_wing_HIL_model_dll_DW.state_as[1] << 13 ^
      Lifting_wing_HIL_model_dll_DW.state_as[1];
    c ^= c >> 17;
    c ^= c << 5;
    Lifting_wing_HIL_model_dll_DW.state_as[0] = b;
    Lifting_wing_HIL_model_dll_DW.state_as[1] = c;
    r[1] = static_cast<real_T>(b + c) * 2.328306436538696E-10;
    b = 69069U * Lifting_wing_HIL_model_dll_DW.state_as[0] + 1234567U;
    c = Lifting_wing_HIL_model_dll_DW.state_as[1] << 13 ^
      Lifting_wing_HIL_model_dll_DW.state_as[1];
    c ^= c >> 17;
    c ^= c << 5;
    Lifting_wing_HIL_model_dll_DW.state_as[0] = b;
    Lifting_wing_HIL_model_dll_DW.state_as[1] = c;
    r[2] = static_cast<real_T>(b + c) * 2.328306436538696E-10;
    break;

   default:
    r[0] = Lifting_wing_eml_rand_mt19937ar
      (Lifting_wing_HIL_model_dll_DW.state_bm);
    r[1] = Lifting_wing_eml_rand_mt19937ar
      (Lifting_wing_HIL_model_dll_DW.state_bm);
    r[2] = Lifting_wing_eml_rand_mt19937ar
      (Lifting_wing_HIL_model_dll_DW.state_bm);
    break;
  }
}

// Function for MATLAB Function: '<S12>/Model Fail Assessment'
real_T MulticopterModelClass::Lifting_wing_HIL_model_dll_norm(const real_T x[3])
{
  real_T absxk;
  real_T scale;
  real_T t;
  real_T y;
  scale = 3.3121686421112381E-170;
  absxk = std::abs(x[0]);
  if (absxk > 3.3121686421112381E-170) {
    y = 1.0;
    scale = absxk;
  } else {
    t = absxk / 3.3121686421112381E-170;
    y = t * t;
  }

  absxk = std::abs(x[1]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  absxk = std::abs(x[2]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  return scale * std::sqrt(y);
}

// Function for MATLAB Function: '<S381>/failture_gyro_ng_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_a(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_nk[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_nk[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_nk[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_nk[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_nk[kk] =
            Lifting_wing_HIL_model_dll_DW.state_nk[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_nk[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_nk[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_nk[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_nk[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_nk[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_nk[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_nk[623] =
          Lifting_wing_HIL_model_dll_DW.state_nk[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_nk[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_nk[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_nk[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_nk[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_nk[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_nk[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_nk[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

//
// Function for MATLAB Function: '<S381>/failture_gyro_nbg_var'
// function y = param_gen(runtime, x, x_init, Ti, v, dt)
// timestamp:
// x: 
// x_init: 
// Ti: 
// v
// dt: 
//
void MulticopterModelClass::Lifting_wing_HIL_mo_param_gen_a(real_T runtime,
  const real_T x_init_data[], const int32_T x_init_size[1], const real_T
  Ti_data[], const int32_T Ti_size[1], const real_T dt_data[], real_T y_data[],
  int32_T y_size[1])
{
  int32_T b_ii;
  int32_T idx;
  int32_T ii_size_idx_0;
  int32_T k;
  int32_T x_size_idx_0;
  int8_T ii_data_idx_0;
  boolean_T x_data[20];
  boolean_T b_x_data_idx_0;
  boolean_T b_y;
  boolean_T exitg1;

  // %%%%%%%%%%%%%%%%
  // '<S394>:1:83' N = length(x_init);
  // '<S394>:1:85' n = find(runtime <=Ti,1,'first');
  idx = Ti_size[0];
  x_size_idx_0 = Ti_size[0];
  for (k = 0; k < idx; k++) {
    x_data[k] = (runtime <= Ti_data[k]);
  }

  k = (Ti_size[0] >= 1);
  idx = 0;
  ii_size_idx_0 = k;
  b_ii = 0;
  exitg1 = false;
  while ((!exitg1) && (b_ii <= x_size_idx_0 - 1)) {
    if (x_data[b_ii]) {
      idx = 1;
      ii_data_idx_0 = static_cast<int8_T>(b_ii + 1);
      exitg1 = true;
    } else {
      b_ii++;
    }
  }

  if (k == 1) {
    if (idx == 0) {
      ii_size_idx_0 = 0;
    }
  } else {
    ii_size_idx_0 = (idx >= 1);
  }

  // '<S394>:1:86' if n ==1
  if (ii_size_idx_0 - 1 >= 0) {
    b_x_data_idx_0 = (ii_data_idx_0 == 1);
  }

  b_y = (ii_size_idx_0 != 0);
  if (b_y) {
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k <= ii_size_idx_0 - 1)) {
      if (!b_x_data_idx_0) {
        b_y = false;
        exitg1 = true;
      } else {
        k = 1;
      }
    }
  }

  if (b_y) {
    // first one
    // '<S394>:1:87' y = x;
    y_size[0] = 1;
    y_data[0] = 1.0;
  } else if (ii_size_idx_0 == 0) {
    real_T b_x_tmp;

    // '<S394>:1:88' elseif isempty(n)
    // last one
    // '<S394>:1:89' if runtime <= Ti(N) +dt(N)
    b_x_tmp = Ti_data[x_init_size[0] - 1];
    if (runtime <= dt_data[x_init_size[0] - 1] + b_x_tmp) {
      // '<S394>:1:90' y = x_init(N) + (runtime - Ti(N))*v(N);
      y_size[0] = 1;
      y_data[0] = (runtime - b_x_tmp) * 0.0 + x_init_data[x_init_size[0] - 1];
    } else {
      // '<S394>:1:91' else
      // '<S394>:1:92' y = x;
      y_size[0] = 1;
      y_data[0] = 1.0;
    }
  } else {
    real_T b_x_tmp;

    // '<S394>:1:94' else
    // '<S394>:1:95' if runtime > Ti(n -1) +dt(n -1)
    b_x_tmp = Ti_data[static_cast<int8_T>(ii_data_idx_0 - 1) - 1];
    if (!(runtime > dt_data[static_cast<int8_T>(ii_data_idx_0 - 1) - 1] +
          b_x_tmp)) {
      // '<S394>:1:97' else
      // '<S394>:1:98' y = x_init(n -1) + (runtime - Ti(n -1))*v(n - 1);
      y_size[0] = 1;
      y_data[0] = (runtime - b_x_tmp) * 0.0 + x_init_data[static_cast<int8_T>
        (ii_data_idx_0 - 1) - 1];
    } else {
      // '<S394>:1:96' y = x;
      y_size[0] = 1;
      y_data[0] = 1.0;
    }
  }
}

// Function for MATLAB Function: '<S381>/failture_gyro_kgp'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_c(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_bu[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_bu[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_bu[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_bu[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_bu[kk] =
            Lifting_wing_HIL_model_dll_DW.state_bu[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_bu[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_bu[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_bu[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_bu[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_bu[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_bu[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_bu[623] =
          Lifting_wing_HIL_model_dll_DW.state_bu[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_bu[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_bu[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_bu[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_bu[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_bu[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_bu[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_bu[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S381>/failture_gyro_kg_cg'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_p(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_c0[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_c0[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_c0[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_c0[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_c0[kk] =
            Lifting_wing_HIL_model_dll_DW.state_c0[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_c0[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_c0[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_c0[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_c0[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_c0[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_c0[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_c0[623] =
          Lifting_wing_HIL_model_dll_DW.state_c0[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_c0[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_c0[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_c0[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_c0[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_c0[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_c0[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_c0[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S381>/failture_gyro_nbg_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_i(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_ke[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_ke[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_ke[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_ke[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_ke[kk] =
            Lifting_wing_HIL_model_dll_DW.state_ke[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_ke[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_ke[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_ke[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_ke[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_ke[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_ke[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_ke[623] =
          Lifting_wing_HIL_model_dll_DW.state_ke[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_ke[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_ke[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_ke[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_ke[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_ke[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_ke[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_ke[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S382>/failture_magl_km_cm'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_iv(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_kv[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_kv[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_kv[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_kv[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_kv[kk] =
            Lifting_wing_HIL_model_dll_DW.state_kv[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_kv[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_kv[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_kv[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_kv[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_kv[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_kv[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_kv[623] =
          Lifting_wing_HIL_model_dll_DW.state_kv[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_kv[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_kv[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_kv[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_kv[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_kv[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_kv[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_kv[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S382>/failture_mag_nm_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_az(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_m2[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_m2[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_m2[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_m2[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_m2[kk] =
            Lifting_wing_HIL_model_dll_DW.state_m2[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_m2[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_m2[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_m2[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_m2[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_m2[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_m2[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_m2[623] =
          Lifting_wing_HIL_model_dll_DW.state_m2[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_m2[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_m2[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_m2[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_m2[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_m2[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_m2[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_m2[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S382>/failture_mag_nbm_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_d3(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_c[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_c[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_c[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_c[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_c[kk] =
            Lifting_wing_HIL_model_dll_DW.state_c[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_c[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_c[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_c[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_c[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_c[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_c[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_c[623] =
          Lifting_wing_HIL_model_dll_DW.state_c[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_c[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_c[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_c[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_c[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_c[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_c[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_c[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S379>/failture_baro_nb_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_d(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_e3[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_e3[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e3[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_e3[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e3[kk] =
            Lifting_wing_HIL_model_dll_DW.state_e3[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e3[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_e3[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e3[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_e3[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_e3[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_e3[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_e3[623] =
          Lifting_wing_HIL_model_dll_DW.state_e3[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_e3[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_e3[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_e3[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_e3[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_e3[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_e3[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_e3[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S379>/failture_baro_nbb_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_dm(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_k4[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_k4[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_k4[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_k4[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_k4[kk] =
            Lifting_wing_HIL_model_dll_DW.state_k4[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_k4[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_k4[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_k4[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_k4[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_k4[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_k4[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_k4[623] =
          Lifting_wing_HIL_model_dll_DW.state_k4[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_k4[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_k4[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_k4[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_k4[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_k4[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_k4[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_k4[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S380>/failture_accel_ka_ca'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_b(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_nk2[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_nk2[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_nk2[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_nk2[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_nk2[kk] =
            Lifting_wing_HIL_model_dll_DW.state_nk2[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_nk2[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_nk2[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_nk2[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_nk2[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_nk2[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_nk2[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_nk2[623] =
          Lifting_wing_HIL_model_dll_DW.state_nk2[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_nk2[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_nk2[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_nk2[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_nk2[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_nk2[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_nk2[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_nk2[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S380>/failture_accel_kap'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_k(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_a[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_a[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_a[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_a[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_a[kk] =
            Lifting_wing_HIL_model_dll_DW.state_a[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_a[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_a[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_a[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_a[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_a[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_a[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_a[623] =
          Lifting_wing_HIL_model_dll_DW.state_a[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_a[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_a[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_a[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_a[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_a[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_a[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_a[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S380>/failture_accel_na_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_h(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_i5[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_i5[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_i5[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_i5[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_i5[kk] =
            Lifting_wing_HIL_model_dll_DW.state_i5[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_i5[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_i5[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_i5[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_i5[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_i5[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_i5[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_i5[623] =
          Lifting_wing_HIL_model_dll_DW.state_i5[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_i5[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_i5[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_i5[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_i5[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_i5[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_i5[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_i5[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S380>/failture_accel_nba_var'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_g(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_oa[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_oa[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_oa[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_oa[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_oa[kk] =
            Lifting_wing_HIL_model_dll_DW.state_oa[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_oa[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_oa[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_oa[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_oa[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_oa[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_oa[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_oa[623] =
          Lifting_wing_HIL_model_dll_DW.state_oa[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_oa[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_oa[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_oa[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_oa[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_oa[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_oa[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_oa[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S382>/failture_mag_dm'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_j(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_e5[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_e5[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e5[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_e5[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e5[kk] =
            Lifting_wing_HIL_model_dll_DW.state_e5[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e5[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_e5[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e5[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_e5[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_e5[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_e5[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_e5[623] =
          Lifting_wing_HIL_model_dll_DW.state_e5[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_e5[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_e5[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_e5[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_e5[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_e5[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_e5[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_e5[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor1'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_l(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_no[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_no[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_no[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_no[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_no[kk] =
            Lifting_wing_HIL_model_dll_DW.state_no[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_no[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_no[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_no[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_no[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_no[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_no[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_no[623] =
          Lifting_wing_HIL_model_dll_DW.state_no[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_no[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_no[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_no[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_no[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_no[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_no[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_no[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor2'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_lh(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_lo[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_lo[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_lo[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_lo[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_lo[kk] =
            Lifting_wing_HIL_model_dll_DW.state_lo[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_lo[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_lo[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_lo[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_lo[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_lo[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_lo[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_lo[623] =
          Lifting_wing_HIL_model_dll_DW.state_lo[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_lo[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_lo[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_lo[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_lo[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_lo[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_lo[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_lo[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor3'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_kb(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_o[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_o[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_o[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_o[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_o[kk] =
            Lifting_wing_HIL_model_dll_DW.state_o[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_o[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_o[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_o[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_o[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_o[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_o[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_o[623] =
          Lifting_wing_HIL_model_dll_DW.state_o[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_o[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_o[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_o[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_o[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_o[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_o[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_o[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor4'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_p0(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_b[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_b[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_b[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_b[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_b[kk] =
            Lifting_wing_HIL_model_dll_DW.state_b[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_b[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_b[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_b[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_b[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_b[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_b[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_b[623] =
          Lifting_wing_HIL_model_dll_DW.state_b[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_b[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_b[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_b[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_b[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_b[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_b[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_b[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor5'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_n(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_p[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_p[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_p[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_p[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_p[kk] =
            Lifting_wing_HIL_model_dll_DW.state_p[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_p[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_p[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_p[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_p[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_p[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_p[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_p[623] =
          Lifting_wing_HIL_model_dll_DW.state_p[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_p[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_p[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_p[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_p[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_p[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_p[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_p[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor6'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_ig(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_dy[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_dy[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dy[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_dy[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dy[kk] =
            Lifting_wing_HIL_model_dll_DW.state_dy[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dy[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_dy[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dy[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_dy[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_dy[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_dy[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_dy[623] =
          Lifting_wing_HIL_model_dll_DW.state_dy[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_dy[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_dy[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_dy[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_dy[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_dy[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_dy[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_dy[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor7'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_f(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_gz[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_gz[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_gz[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_gz[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_gz[kk] =
            Lifting_wing_HIL_model_dll_DW.state_gz[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_gz[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_gz[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_gz[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_gz[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_gz[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_gz[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_gz[623] =
          Lifting_wing_HIL_model_dll_DW.state_gz[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_gz[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_gz[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_gz[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_gz[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_gz[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_gz[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_gz[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor8'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_bt(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_dmq[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_dmq[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dmq[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_dmq[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dmq[kk] =
            Lifting_wing_HIL_model_dll_DW.state_dmq[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dmq[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_dmq[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dmq[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_dmq[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_dmq[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_dmq[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_dmq[623] =
          Lifting_wing_HIL_model_dll_DW.state_dmq[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_dmq[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_dmq[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_dmq[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_dmq[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_dmq[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_dmq[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_dmq[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc1'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_fv(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_n5[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_n5[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_n5[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_n5[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_n5[kk] =
            Lifting_wing_HIL_model_dll_DW.state_n5[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_n5[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_n5[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_n5[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_n5[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_n5[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_n5[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_n5[623] =
          Lifting_wing_HIL_model_dll_DW.state_n5[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_n5[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_n5[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_n5[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_n5[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_n5[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_n5[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_n5[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc2'
real_T MulticopterModelClass::Lifting_wing_HIL_model_d_rand_m(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_g[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_g[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_g[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_g[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_g[kk] =
            Lifting_wing_HIL_model_dll_DW.state_g[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_g[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_g[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_g[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_g[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_g[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_g[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_g[623] =
          Lifting_wing_HIL_model_dll_DW.state_g[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_g[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_g[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_g[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_g[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_g[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_g[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_g[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc3'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_ir(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_m[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_m[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_m[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_m[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_m[kk] =
            Lifting_wing_HIL_model_dll_DW.state_m[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_m[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_m[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_m[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_m[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_m[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_m[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_m[623] =
          Lifting_wing_HIL_model_dll_DW.state_m[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_m[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_m[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_m[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_m[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_m[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_m[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_m[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc4'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_gk(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_i[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_i[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_i[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_i[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_i[kk] =
            Lifting_wing_HIL_model_dll_DW.state_i[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_i[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_i[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_i[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_i[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_i[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_i[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_i[623] =
          Lifting_wing_HIL_model_dll_DW.state_i[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_i[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_i[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_i[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_i[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_i[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_i[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_i[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc5'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_os(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_el[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_el[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_el[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_el[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_el[kk] =
            Lifting_wing_HIL_model_dll_DW.state_el[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_el[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_el[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_el[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_el[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_el[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_el[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_el[623] =
          Lifting_wing_HIL_model_dll_DW.state_el[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_el[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_el[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_el[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_el[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_el[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_el[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_el[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc6'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_fi(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_f[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_f[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_f[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_f[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_f[kk] =
            Lifting_wing_HIL_model_dll_DW.state_f[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_f[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_f[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_f[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_f[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_f[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_f[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_f[623] =
          Lifting_wing_HIL_model_dll_DW.state_f[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_f[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_f[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_f[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_f[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_f[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_f[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_f[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc7'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_o0(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_ns[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_ns[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_ns[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_ns[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_ns[kk] =
            Lifting_wing_HIL_model_dll_DW.state_ns[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_ns[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_ns[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_ns[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_ns[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_ns[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_ns[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_ns[623] =
          Lifting_wing_HIL_model_dll_DW.state_ns[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_ns[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_ns[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_ns[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_ns[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_ns[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_ns[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_ns[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S383>/failture_motor_ktc8'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_ly(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_e[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_e[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_e[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e[kk] =
            Lifting_wing_HIL_model_dll_DW.state_e[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_e[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_e[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_e[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_e[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_e[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_e[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_e[623] =
          Lifting_wing_HIL_model_dll_DW.state_e[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_e[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_e[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_e[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_e[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_e[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_e[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_e[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller1'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_p4(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_n[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_n[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_n[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_n[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_n[kk] =
            Lifting_wing_HIL_model_dll_DW.state_n[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_n[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_n[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_n[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_n[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_n[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_n[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_n[623] =
          Lifting_wing_HIL_model_dll_DW.state_n[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_n[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_n[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_n[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_n[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_n[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_n[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_n[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller2'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_jc(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_dm[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_dm[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dm[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_dm[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dm[kk] =
            Lifting_wing_HIL_model_dll_DW.state_dm[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_dm[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_dm[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_dm[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_dm[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_dm[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_dm[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_dm[623] =
          Lifting_wing_HIL_model_dll_DW.state_dm[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_dm[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_dm[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_dm[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_dm[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_dm[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_dm[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_dm[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller3'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_fl(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_kf[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_kf[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_kf[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_kf[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_kf[kk] =
            Lifting_wing_HIL_model_dll_DW.state_kf[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_kf[kk + 227] & 2147483648U)
            | (Lifting_wing_HIL_model_dll_DW.state_kf[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_kf[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_kf[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_kf[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_kf[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_kf[623] =
          Lifting_wing_HIL_model_dll_DW.state_kf[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_kf[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_kf[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_kf[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_kf[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_kf[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_kf[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_kf[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller4'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_oi(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_l[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_l[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_l[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_l[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_l[kk] =
            Lifting_wing_HIL_model_dll_DW.state_l[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_l[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_l[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_l[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_l[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_l[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_l[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_l[623] =
          Lifting_wing_HIL_model_dll_DW.state_l[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_l[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_l[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_l[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_l[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_l[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_l[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_l[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller5'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_jg(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_k[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_k[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_k[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_k[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_k[kk] =
            Lifting_wing_HIL_model_dll_DW.state_k[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_k[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_k[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_k[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_k[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_k[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_k[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_k[623] =
          Lifting_wing_HIL_model_dll_DW.state_k[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_k[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_k[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_k[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_k[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_k[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_k[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_k[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller6'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_c5(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_j[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_j[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_j[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_j[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_j[kk] =
            Lifting_wing_HIL_model_dll_DW.state_j[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_j[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_j[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_j[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_j[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_j[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_j[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_j[623] =
          Lifting_wing_HIL_model_dll_DW.state_j[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_j[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_j[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_j[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_j[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_j[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_j[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_j[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller7'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_nm(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state_d[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state_d[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_d[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state_d[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_d[kk] =
            Lifting_wing_HIL_model_dll_DW.state_d[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state_d[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state_d[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state_d[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state_d[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state_d[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state_d[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state_d[623] =
          Lifting_wing_HIL_model_dll_DW.state_d[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state_d[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state_d[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state_d[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state_d[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state_d[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state_d[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state_d[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

// Function for MATLAB Function: '<S384>/failture_propeller8'
real_T MulticopterModelClass::Lifting_wing_HIL_model__rand_nb(void)
{
  uint32_T b_u[2];
  uint32_T mti;
  uint32_T y;

  // ========================= COPYRIGHT NOTICE ============================
  //  This is a uniform (0,1) pseudorandom number generator based on:
  //
  //  A C-program for MT19937, with initialization improved 2002/1/26.
  //  Coded by Takuji Nishimura and Makoto Matsumoto.
  //
  //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
  //  All rights reserved.
  //
  //  Redistribution and use in source and binary forms, with or without
  //  modification, are permitted provided that the following conditions
  //  are met:
  //
  //    1. Redistributions of source code must retain the above copyright
  //       notice, this list of conditions and the following disclaimer.
  //
  //    2. Redistributions in binary form must reproduce the above copyright
  //       notice, this list of conditions and the following disclaimer
  //       in the documentation and/or other materials provided with the
  //       distribution.
  //
  //    3. The names of its contributors may not be used to endorse or
  //       promote products derived from this software without specific
  //       prior written permission.
  //
  //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
  //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // =============================   END   =================================
  int32_T exitg1;
  do {
    int32_T k;
    exitg1 = 0;
    for (k = 0; k < 2; k++) {
      mti = Lifting_wing_HIL_model_dll_DW.state[624] + 1U;
      if (Lifting_wing_HIL_model_dll_DW.state[624] + 1U >= 625U) {
        for (int32_T kk{0}; kk < 227; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state[kk + 1] & 2147483647U) |
            (Lifting_wing_HIL_model_dll_DW.state[kk] & 2147483648U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state[kk] =
            Lifting_wing_HIL_model_dll_DW.state[kk + 397] ^ mti;
        }

        for (int32_T kk{0}; kk < 396; kk++) {
          mti = (Lifting_wing_HIL_model_dll_DW.state[kk + 227] & 2147483648U) |
            (Lifting_wing_HIL_model_dll_DW.state[kk + 228] & 2147483647U);
          if ((mti & 1U) == 0U) {
            mti >>= 1U;
          } else {
            mti = mti >> 1U ^ 2567483615U;
          }

          Lifting_wing_HIL_model_dll_DW.state[kk + 227] =
            Lifting_wing_HIL_model_dll_DW.state[kk] ^ mti;
        }

        mti = (Lifting_wing_HIL_model_dll_DW.state[623] & 2147483648U) |
          (Lifting_wing_HIL_model_dll_DW.state[0] & 2147483647U);
        if ((mti & 1U) == 0U) {
          mti >>= 1U;
        } else {
          mti = mti >> 1U ^ 2567483615U;
        }

        Lifting_wing_HIL_model_dll_DW.state[623] =
          Lifting_wing_HIL_model_dll_DW.state[396] ^ mti;
        mti = 1U;
      }

      y = Lifting_wing_HIL_model_dll_DW.state[static_cast<int32_T>(mti) - 1];
      Lifting_wing_HIL_model_dll_DW.state[624] = mti;
      y ^= y >> 11U;
      y ^= y << 7U & 2636928640U;
      y ^= y << 15U & 4022730752U;
      b_u[k] = y >> 18U ^ y;
    }

    mti = b_u[0] >> 5U;
    y = b_u[1] >> 6U;
    if ((mti == 0U) && (y == 0U)) {
      boolean_T b_isvalid;
      b_isvalid = ((Lifting_wing_HIL_model_dll_DW.state[624] >= 1U) &&
                   (Lifting_wing_HIL_model_dll_DW.state[624] < 625U));
      if (b_isvalid) {
        boolean_T exitg2;
        b_isvalid = false;
        k = 1;
        exitg2 = false;
        while ((!exitg2) && (k < 625)) {
          if (Lifting_wing_HIL_model_dll_DW.state[k - 1] == 0U) {
            k++;
          } else {
            b_isvalid = true;
            exitg2 = true;
          }
        }
      }

      if (!b_isvalid) {
        Lifting_wing_HIL_model_dll_DW.state[0] = 5489U;
        Lifting_wing_HIL_model_dll_DW.state[624] = 624U;
      }
    } else {
      exitg1 = 1;
    }
  } while (exitg1 == 0);

  return (static_cast<real_T>(mti) * 6.7108864E+7 + static_cast<real_T>(y)) *
    1.1102230246251565E-16;
}

real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)
{
  uint32_T hi;
  uint32_T lo;

  // Uniform random number generator (random number between 0 and 1)

  // #define IA      16807                      magic multiplier = 7^5
  // #define IM      2147483647                 modulus = 2^31-1
  // #define IQ      127773                     IM div IA
  // #define IR      2836                       IM modulo IA
  // #define S       4.656612875245797e-10      reciprocal of 2^31-1
  // test = IA * (seed % IQ) - IR * (seed/IQ)
  // seed = test < 0 ? (test + IM) : test
  // return (seed*S)

  lo = *u % 127773U * 16807U;
  hi = *u / 127773U * 2836U;
  if (lo < hi) {
    *u = 2147483647U - (hi - lo);
  } else {
    *u = lo - hi;
  }

  return static_cast<real_T>(*u) * 4.6566128752457969E-10;
}

real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u)
{
  real_T si;
  real_T sr;
  real_T y;

  // Normal (Gaussian) random number generator
  do {
    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;
    si = sr * sr + si * si;
  } while (si > 1.0);

  y = std::sqrt(-2.0 * std::log(si) / si) * sr;
  return y;
}

// Model step function
void MulticopterModelClass::step()
{
  // local block i/o variables
  real_T rtb_DigitalClock;
  real_T rtb_DigitalClock_e;
  if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep()) {
    // set solver stop time
    rtsiSetSolverStopTime(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                          (((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick0+1)*
      (&Lifting_wing_HIL_model_dll_M)->Timing.stepSize0));
  }                                    // end MajorTimeStep

  // Update absolute time of base rate at minor time step
  if ((&Lifting_wing_HIL_model_dll_M)->isMinorTimeStep()) {
    (&Lifting_wing_HIL_model_dll_M)->Timing.t[0] = rtsiGetT
      (&(&Lifting_wing_HIL_model_dll_M)->solverInfo);
  }

  {
    real_T gyro_ng_var_am_rand_data[60];
    real_T DataTypeConversion1[20];
    real_T tmp_data[20];
    real_T rtb_VectorConcatenate[18];
    real_T rtb_Saturation[16];
    real_T tmp_2[12];
    real_T Comega[9];
    real_T Comega_0[9];
    real_T Comega_1[9];
    real_T Comega_2[9];
    real_T Product_tmp[9];
    real_T R_lb[9];
    real_T VectorConcatenate[9];
    real_T tmp_3[9];
    real_T tmp_4[9];
    real_T rtb_Signal_Saturation_7[6];
    real_T tmp_5[6];
    real_T BusCreator_mag_e[3];
    real_T M_ground[3];
    real_T R_lb_0[3];
    real_T rtb_Fa[3];
    real_T rtb_Fp[3];
    real_T rtb_Fp_0[3];
    real_T rtb_Integrator1_p[3];
    real_T rtb_IntegratorSecondOrderLimi_p[3];
    real_T rtb_IntegratorSecondOrderLimite[3];
    real_T rtb_Ma[3];
    real_T rtb_Mp[3];
    real_T rtb_Product_d[3];
    real_T rtb_Saturation_c[3];
    real_T rtb_Sum4_g[3];
    real_T rtb_Sum4_h[3];
    real_T rtb_TmpSignalConversionAtSFunct[3];
    real_T rtb_sincos_o1[3];
    real_T frac[2];
    real_T AR;
    real_T M_ground_0;
    real_T M_ground_1;
    real_T Merge;
    real_T VectorConcatenate_tmp;
    real_T alt;
    real_T f_a;
    real_T fphi;
    real_T lat;
    real_T q;
    real_T rtb_DataTypeConversion1_tmp_tmp;
    real_T rtb_Divide_idx_0;
    real_T rtb_Gain1_idx_1;
    real_T rtb_Gain1_idx_2;
    real_T rtb_Gain7;
    real_T rtb_IntegratorSecondOrderLimi_0;
    real_T rtb_IntegratorSecondOrderLimi_1;
    real_T rtb_IntegratorSecondOrderLimi_2;
    real_T rtb_IntegratorSecondOrderLimi_a;
    real_T rtb_Lw_idx_0;
    real_T rtb_Lw_idx_1;
    real_T rtb_Sum_o;
    real_T rtb_Switch;
    real_T rtb_VectorConcatenate_a_idx_1;
    real_T rtb_VectorConcatenate_a_idx_2;
    real_T rtb_jxi;
    real_T rtb_q0q1q2q3_idx_0;
    real_T rtb_q0q1q2q3_idx_1;
    real_T rtb_q0q1q2q3_idx_2;
    real_T rtb_q0q1q2q3_idx_3;
    real_T rtb_q3dot;
    real_T sin2beta;
    real_T z;
    int32_T Comega_tmp;
    int32_T Comega_tmp_0;
    int32_T i;
    int32_T rtb_lat;
    int32_T rtb_lon;
    real32_T rtb_y_ho[6];
    real32_T rtb_AngQuatern_idx_1;
    real32_T rtb_AngQuatern_idx_2;
    real32_T rtb_AngQuatern_idx_3;
    real32_T x;
    uint32_T bpIndex[2];
    uint32_T rtb_DataTypeConversion1;
    uint32_T tmp_6;
    int8_T BusCreator_landed;
    int8_T rtAction;
    int8_T rtPrevAction;
    uint8_T rtb_Compare;
    boolean_T rEQ0;
    boolean_T rtb_Compare_a;
    boolean_T rtb_Compare_d;
    boolean_T tmp;
    boolean_T tmp_0;
    boolean_T tmp_1;
    static const int8_T b[3]{ 0, 1, 0 };

    static const int8_T e_a[12]{ 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1 };

    MulticopterModelClass::XDis_Lifting_wing_HIL_model_d_T *_rtXdis;
    real_T rtb_Sum_ag_tmp;
    real_T rtb_q3dot_tmp;
    real_T tmp_data_0;
    int32_T tmp_size[1];
    int32_T tmp_size_0[1];
    _rtXdis = ((XDis_Lifting_wing_HIL_model_d_T *)
               (&Lifting_wing_HIL_model_dll_M)->contStateDisabled);

    // Clock: '<S5>/Clock1' incorporates:
    //   Clock: '<S16>/Clock1'

    rtb_DataTypeConversion1_tmp_tmp = (&Lifting_wing_HIL_model_dll_M)->Timing.t
      [0];

    // DataTypeConversion: '<S5>/Data Type Conversion1' incorporates:
    //   Clock: '<S5>/Clock1'
    //   Gain: '<S5>/Gain_clock'

    rtb_Divide_idx_0 = std::floor(Lifting_wing_HIL_model_dll_P.Gain_clock_Gain *
      rtb_DataTypeConversion1_tmp_tmp);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    rtb_DataTypeConversion1 = rtb_Divide_idx_0 < 0.0 ? static_cast<uint32_T>(-
      static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0))) :
      static_cast<uint32_T>(rtb_Divide_idx_0);

    // End of DataTypeConversion: '<S5>/Data Type Conversion1'

    // SecondOrderIntegrator: '<S100>/Integrator, Second-Order Limited'
    rtb_IntegratorSecondOrderLimite[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[0];
    rtb_IntegratorSecondOrderLimi_2 =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[3];
    rtb_IntegratorSecondOrderLimite[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[1];
    rtb_IntegratorSecondOrderLimi_1 =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[4];
    rtb_IntegratorSecondOrderLimite[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[2];
    rtb_IntegratorSecondOrderLimi_0 =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[5];
    tmp = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
           (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0);
    if (tmp) {
      // DiscreteIntegrator: '<S277>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE;

      // DiscreteIntegrator: '<S278>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_e;

      // DiscreteIntegrator: '<S279>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_o;

      // DiscreteIntegrator: '<S280>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_c;

      // Gain: '<S307>/1//2' incorporates:
      //   Constant: '<S297>/Initial Euler Angles'

      rtb_sincos_o1[0] = Lifting_wing_HIL_model_dll_P.u2_Gain *
        Lifting_wing_HIL_model_dll_P.ModelInit_AngEuler[2];
      rtb_sincos_o1[1] = Lifting_wing_HIL_model_dll_P.u2_Gain *
        Lifting_wing_HIL_model_dll_P.ModelInit_AngEuler[1];
      rtb_sincos_o1[2] = Lifting_wing_HIL_model_dll_P.u2_Gain *
        Lifting_wing_HIL_model_dll_P.ModelInit_AngEuler[0];

      // Trigonometry: '<S307>/sincos'
      rtb_TmpSignalConversionAtSFunct[0] = std::cos(rtb_sincos_o1[0]);
      rtb_q0q1q2q3_idx_2 = std::sin(rtb_sincos_o1[0]);
      rtb_TmpSignalConversionAtSFunct[1] = std::cos(rtb_sincos_o1[1]);
      rtb_q0q1q2q3_idx_1 = std::sin(rtb_sincos_o1[1]);
      rtb_TmpSignalConversionAtSFunct[2] = std::cos(rtb_sincos_o1[2]);
      rtb_q0q1q2q3_idx_0 = std::sin(rtb_sincos_o1[2]);

      // Fcn: '<S307>/q0' incorporates:
      //   Fcn: '<S307>/q1'
      //   Trigonometry: '<S307>/sincos'

      rtb_q0q1q2q3_idx_3 = rtb_TmpSignalConversionAtSFunct[0] *
        rtb_TmpSignalConversionAtSFunct[1];
      rtb_Switch = rtb_q0q1q2q3_idx_2 * rtb_q0q1q2q3_idx_1;

      // Fcn: '<S307>/q0' incorporates:
      //   Trigonometry: '<S307>/sincos'

      Lifting_wing_HIL_model_dll_B.q0 = rtb_q0q1q2q3_idx_3 *
        rtb_TmpSignalConversionAtSFunct[2] + rtb_Switch * rtb_q0q1q2q3_idx_0;

      // Fcn: '<S307>/q1' incorporates:
      //   Trigonometry: '<S307>/sincos'

      Lifting_wing_HIL_model_dll_B.q1 = rtb_q0q1q2q3_idx_3 * rtb_q0q1q2q3_idx_0
        - rtb_Switch * rtb_TmpSignalConversionAtSFunct[2];

      // Fcn: '<S307>/q2' incorporates:
      //   Fcn: '<S307>/q3'
      //   Trigonometry: '<S307>/sincos'

      rtb_q0q1q2q3_idx_2 *= rtb_TmpSignalConversionAtSFunct[1];
      rtb_q0q1q2q3_idx_1 *= rtb_TmpSignalConversionAtSFunct[0];

      // Fcn: '<S307>/q2' incorporates:
      //   Trigonometry: '<S307>/sincos'

      Lifting_wing_HIL_model_dll_B.q2 = rtb_q0q1q2q3_idx_1 *
        rtb_TmpSignalConversionAtSFunct[2] + rtb_q0q1q2q3_idx_2 *
        rtb_q0q1q2q3_idx_0;

      // Fcn: '<S307>/q3' incorporates:
      //   Trigonometry: '<S307>/sincos'

      Lifting_wing_HIL_model_dll_B.q3 = rtb_q0q1q2q3_idx_2 *
        rtb_TmpSignalConversionAtSFunct[2] - rtb_q0q1q2q3_idx_1 *
        rtb_q0q1q2q3_idx_0;
    }

    // Integrator: '<S297>/q0 q1 q2 q3' incorporates:
    //   SignalConversion generated from: '<S297>/q0 q1 q2 q3'

    if (Lifting_wing_HIL_model_dll_DW.q0q1q2q3_DWORK1) {
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0] =
        Lifting_wing_HIL_model_dll_B.q0;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1] =
        Lifting_wing_HIL_model_dll_B.q1;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2] =
        Lifting_wing_HIL_model_dll_B.q2;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3] =
        Lifting_wing_HIL_model_dll_B.q3;
    }

    rtb_q0q1q2q3_idx_0 = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0];
    rtb_q0q1q2q3_idx_1 = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1];
    rtb_q0q1q2q3_idx_2 = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2];
    rtb_q0q1q2q3_idx_3 = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3];

    // Sqrt: '<S320>/sqrt' incorporates:
    //   Integrator: '<S297>/q0 q1 q2 q3'
    //   Product: '<S321>/Product'
    //   Product: '<S321>/Product1'
    //   Product: '<S321>/Product2'
    //   Product: '<S321>/Product3'
    //   Sum: '<S321>/Sum'

    rtb_jxi = std::sqrt(((Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0] *
                          Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0] +
                          Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1] *
                          Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1]) +
                         Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2] *
                         Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2]) +
                        Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3] *
                        Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3]);

    // Product: '<S319>/Product' incorporates:
    //   Integrator: '<S297>/q0 q1 q2 q3'

    rtb_Gain7 = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0] / rtb_jxi;

    // Product: '<S319>/Product1' incorporates:
    //   Integrator: '<S297>/q0 q1 q2 q3'

    rtb_Sum_o = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1] / rtb_jxi;

    // Product: '<S319>/Product2' incorporates:
    //   Integrator: '<S297>/q0 q1 q2 q3'

    rtb_q3dot = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2] / rtb_jxi;

    // Product: '<S319>/Product3' incorporates:
    //   Integrator: '<S297>/q0 q1 q2 q3'

    rtb_jxi = Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3] / rtb_jxi;

    // Product: '<S309>/Product3' incorporates:
    //   Product: '<S313>/Product3'

    rtb_Switch = rtb_Gain7 * rtb_Gain7;

    // Product: '<S309>/Product2' incorporates:
    //   Product: '<S313>/Product2'

    Merge = rtb_Sum_o * rtb_Sum_o;

    // Product: '<S309>/Product1' incorporates:
    //   Product: '<S313>/Product1'
    //   Product: '<S317>/Product1'

    VectorConcatenate_tmp = rtb_q3dot * rtb_q3dot;

    // Product: '<S309>/Product' incorporates:
    //   Product: '<S313>/Product'
    //   Product: '<S317>/Product'

    q = rtb_jxi * rtb_jxi;

    // Sum: '<S309>/Sum' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Product: '<S309>/Product'
    //   Product: '<S309>/Product1'
    //   Product: '<S309>/Product2'
    //   Product: '<S309>/Product3'

    VectorConcatenate[0] = ((rtb_Switch + Merge) - VectorConcatenate_tmp) - q;

    // Product: '<S312>/Product3' incorporates:
    //   Product: '<S310>/Product3'

    lat = rtb_jxi * rtb_Gain7;

    // Product: '<S312>/Product2' incorporates:
    //   Product: '<S310>/Product2'

    rtb_Lw_idx_1 = rtb_Sum_o * rtb_q3dot;

    // Gain: '<S312>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Product: '<S312>/Product2'
    //   Product: '<S312>/Product3'
    //   Sum: '<S312>/Sum'

    VectorConcatenate[1] = (rtb_Lw_idx_1 - lat) *
      Lifting_wing_HIL_model_dll_P.Gain_Gain_h;

    // Product: '<S315>/Product2' incorporates:
    //   Product: '<S311>/Product2'

    rtb_VectorConcatenate_a_idx_1 = rtb_Sum_o * rtb_jxi;

    // Product: '<S315>/Product1' incorporates:
    //   Product: '<S311>/Product1'

    rtb_VectorConcatenate_a_idx_2 = rtb_Gain7 * rtb_q3dot;

    // Gain: '<S315>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Product: '<S315>/Product1'
    //   Product: '<S315>/Product2'
    //   Sum: '<S315>/Sum'

    VectorConcatenate[2] = (rtb_VectorConcatenate_a_idx_2 +
      rtb_VectorConcatenate_a_idx_1) * Lifting_wing_HIL_model_dll_P.Gain_Gain_ka;

    // Gain: '<S310>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Sum: '<S310>/Sum'

    VectorConcatenate[3] = (lat + rtb_Lw_idx_1) *
      Lifting_wing_HIL_model_dll_P.Gain_Gain_b;

    // Sum: '<S313>/Sum' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Sum: '<S317>/Sum'

    rtb_Switch -= Merge;
    VectorConcatenate[4] = (rtb_Switch + VectorConcatenate_tmp) - q;

    // Product: '<S316>/Product1' incorporates:
    //   Product: '<S314>/Product1'

    Merge = rtb_Gain7 * rtb_Sum_o;

    // Product: '<S316>/Product2' incorporates:
    //   Product: '<S314>/Product2'

    lat = rtb_q3dot * rtb_jxi;

    // Gain: '<S316>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Product: '<S316>/Product1'
    //   Product: '<S316>/Product2'
    //   Sum: '<S316>/Sum'

    VectorConcatenate[5] = (lat - Merge) *
      Lifting_wing_HIL_model_dll_P.Gain_Gain_n;

    // Gain: '<S311>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Sum: '<S311>/Sum'

    VectorConcatenate[6] = (rtb_VectorConcatenate_a_idx_1 -
      rtb_VectorConcatenate_a_idx_2) * Lifting_wing_HIL_model_dll_P.Gain_Gain_b3;

    // Gain: '<S314>/Gain' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'
    //   Sum: '<S314>/Sum'

    VectorConcatenate[7] = (Merge + lat) *
      Lifting_wing_HIL_model_dll_P.Gain_Gain_lg;

    // Sum: '<S317>/Sum' incorporates:
    //   Concatenate: '<S318>/Vector Concatenate'

    VectorConcatenate[8] = (rtb_Switch - VectorConcatenate_tmp) + q;
    for (i = 0; i < 3; i++) {
      // Integrator: '<S295>/ub,vb,wb'
      rtb_TmpSignalConversionAtSFunct[i] =
        Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[i];

      // Math: '<S295>/Transpose' incorporates:
      //   Concatenate: '<S318>/Vector Concatenate'
      //   Math: '<S294>/Transpose'

      Product_tmp[3 * i] = VectorConcatenate[i];
      Product_tmp[3 * i + 1] = VectorConcatenate[i + 3];
      Product_tmp[3 * i + 2] = VectorConcatenate[i + 6];
    }

    // Integrator: '<S295>/ub,vb,wb' incorporates:
    //   Math: '<S295>/Transpose'

    rtb_Switch = Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[1];
    Merge = Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[0];
    VectorConcatenate_tmp = Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[2];
    for (i = 0; i < 3; i++) {
      // Product: '<S304>/Product' incorporates:
      //   Integrator: '<S295>/ub,vb,wb'
      //   Math: '<S295>/Transpose'

      Lifting_wing_HIL_model_dll_B.Product[i] = (Product_tmp[i + 3] * rtb_Switch
        + Product_tmp[i] * Merge) + Product_tmp[i + 6] * VectorConcatenate_tmp;

      // Integrator: '<S295>/xe,ye,ze'
      rtb_sincos_o1[i] = Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[i];
    }

    if (tmp) {
      // MATLAB Function: '<S172>/Ground Model' incorporates:
      //   Inport: '<Root>/TerrainZ'
      //   Integrator: '<S295>/xe,ye,ze'

      //  This is a ground model that can provides reaction force and reaction torque 
      // MATLAB Function 'Subsystem Reference/Environment Models/Ground Model': '<S178>:1' 
      // '<S178>:1:5' if isempty(takeoffFlag)
      // '<S178>:1:10' if isempty(landFlag)
      // '<S178>:1:15' z=Xe(3)-terrainZ;
      z = Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[2] -
        Lifting_wing_HIL_model_dll_U.TerrainZ;

      // '<S178>:1:17' if ((z < -0.001) && (Ve(3)<-0.01)|| z < 1.0) && (takeoffFlag < 0.5) 
      if ((((z < -0.001) && (Lifting_wing_HIL_model_dll_B.Product[2] < -0.01)) ||
           (z < 1.0)) && (Lifting_wing_HIL_model_dll_DW.takeoffFlag < 0.5)) {
        // '<S178>:1:18' takeoffFlag = int8(1);
        Lifting_wing_HIL_model_dll_DW.takeoffFlag = 1;

        // '<S178>:1:19' landFlag = int8(0);
        Lifting_wing_HIL_model_dll_DW.landFlag = 0;
      }

      // '<S178>:1:22' if (z>-0.00001)&&(landFlag<0.5)
      if ((z > -1.0E-5) && (Lifting_wing_HIL_model_dll_DW.landFlag < 0.5)) {
        // '<S178>:1:23' landFlag=int8(1);
        Lifting_wing_HIL_model_dll_DW.landFlag = 1;

        // '<S178>:1:24' takeoffFlag=int8(0);
        Lifting_wing_HIL_model_dll_DW.takeoffFlag = 0;

        // z0=terrainZ;
      }

      // '<S178>:1:28' takeoff = takeoffFlag;
      // '<S178>:1:29' landed = landFlag;
      Lifting_wing_HIL_model_dll_B.landed =
        Lifting_wing_HIL_model_dll_DW.landFlag;

      // End of MATLAB Function: '<S172>/Ground Model'

      // Gain: '<S172>/nT2Gauss' incorporates:
      //   Constant: '<S181>/Constant3'

      Lifting_wing_HIL_model_dll_B.mag_e[0] =
        Lifting_wing_HIL_model_dll_P.nT2Gauss_Gain *
        Lifting_wing_HIL_model_dll_P.Constant3_Value_f[0];
      Lifting_wing_HIL_model_dll_B.mag_e[1] =
        Lifting_wing_HIL_model_dll_P.nT2Gauss_Gain *
        Lifting_wing_HIL_model_dll_P.Constant3_Value_f[1];
      Lifting_wing_HIL_model_dll_B.mag_e[2] =
        Lifting_wing_HIL_model_dll_P.nT2Gauss_Gain *
        Lifting_wing_HIL_model_dll_P.Constant3_Value_f[2];

      // UnitConversion: '<S205>/Unit Conversion' incorporates:
      //   Constant: '<S177>/ref_rotation'

      // Unit Conversion - from: deg to: rad
      // Expression: output = (0.0174533*input) + (0)
      rtb_Gain7 = 0.017453292519943295 *
        Lifting_wing_HIL_model_dll_P.FlatEarthtoLLA_psi;

      // Trigonometry: '<S184>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o1 = std::sin(rtb_Gain7);

      // Trigonometry: '<S184>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o2 = std::cos(rtb_Gain7);

      // Sum: '<S208>/Sum' incorporates:
      //   Constant: '<S208>/Constant'
      //   Constant: '<S208>/f'

      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.f_Value -
        Lifting_wing_HIL_model_dll_P.Constant_Value_jl;

      // Sqrt: '<S209>/sqrt' incorporates:
      //   Constant: '<S209>/Constant'
      //   Product: '<S209>/Product1'
      //   Sum: '<S209>/Sum1'

      Lifting_wing_HIL_model_dll_B.sqrt_l = std::sqrt
        (Lifting_wing_HIL_model_dll_P.Constant_Value_fq - rtb_Gain7 * rtb_Gain7);

      // Switch: '<S199>/Switch' incorporates:
      //   Abs: '<S199>/Abs'
      //   Constant: '<S177>/ref_position'
      //   Constant: '<S202>/Constant'
      //   RelationalOperator: '<S202>/Compare'

      if (std::abs(Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0]) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const) {
        // Switch: '<S199>/Switch' incorporates:
        //   Bias: '<S199>/Bias'
        //   Bias: '<S199>/Bias1'
        //   Constant: '<S199>/Constant2'
        //   Math: '<S199>/Math Function1'

        rtb_Switch = rt_modd_snf
          (Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0] +
           Lifting_wing_HIL_model_dll_P.Bias_Bias_bb,
           Lifting_wing_HIL_model_dll_P.Constant2_Value_a) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_e;
      } else {
        // Switch: '<S199>/Switch'
        rtb_Switch = Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0];
      }

      // End of Switch: '<S199>/Switch'

      // Abs: '<S198>/Abs' incorporates:
      //   Abs: '<S195>/Abs1'

      fphi = std::abs(rtb_Switch);

      // If: '<S198>/If' incorporates:
      //   Abs: '<S198>/Abs'

      if (rtsiIsModeUpdateTimeStep(&(&Lifting_wing_HIL_model_dll_M)->solverInfo))
      {
        rtAction = static_cast<int8_T>(!(fphi > 0.0));
        Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem = rtAction;
      } else {
        rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem;
      }

      if (rtAction == 0) {
        // Outputs for IfAction SubSystem: '<S198>/If Action Subsystem' incorporates:
        //   ActionPort: '<S200>/Action Port'

        Lifting_wing__IfActionSubsystem(rtb_Switch, fphi, &Merge);

        // End of Outputs for SubSystem: '<S198>/If Action Subsystem'
      } else {
        // Outputs for IfAction SubSystem: '<S198>/If Action Subsystem1' incorporates:
        //   ActionPort: '<S201>/Action Port'

        Lifting_wi_IfActionSubsystem1_g(&Merge,
          &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1_f);

        // End of Outputs for SubSystem: '<S198>/If Action Subsystem1'
      }

      // End of If: '<S198>/If'

      // RelationalOperator: '<S197>/Compare' incorporates:
      //   Constant: '<S197>/Constant'

      rtb_Compare_a = (fphi >
                       Lifting_wing_HIL_model_dll_P.CompareToConstant_const_l);

      // Switch: '<S195>/Switch'
      if (rtb_Compare_a) {
        // Switch: '<S195>/Switch' incorporates:
        //   Bias: '<S195>/Bias'
        //   Bias: '<S195>/Bias1'
        //   Gain: '<S195>/Gain'
        //   Product: '<S195>/Divide1'

        Lifting_wing_HIL_model_dll_B.Switch = ((fphi +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_gl) *
          Lifting_wing_HIL_model_dll_P.Gain_Gain_p +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_bq) * Merge;
      } else {
        // Switch: '<S195>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch = rtb_Switch;
      }

      // End of Switch: '<S195>/Switch'
    }

    // Trigonometry: '<S207>/Trigonometric Function1' incorporates:
    //   UnitConversion: '<S206>/Unit Conversion'

    // Unit Conversion - from: deg to: rad
    // Expression: output = (0.0174533*input) + (0)
    rtb_Sum_o = std::sin(0.017453292519943295 *
                         Lifting_wing_HIL_model_dll_B.Switch);

    // Product: '<S207>/Product1' incorporates:
    //   Product: '<S204>/Product2'

    rtb_Sum_ag_tmp = Lifting_wing_HIL_model_dll_B.sqrt_l *
      Lifting_wing_HIL_model_dll_B.sqrt_l;

    // Sum: '<S207>/Sum1' incorporates:
    //   Constant: '<S207>/Constant'
    //   Product: '<S207>/Product1'

    rtb_Sum_o = Lifting_wing_HIL_model_dll_P.Constant_Value_d3 - rtb_Sum_ag_tmp *
      rtb_Sum_o * rtb_Sum_o;
    if (tmp) {
      // Sum: '<S204>/Sum1' incorporates:
      //   Constant: '<S204>/Constant'

      Lifting_wing_HIL_model_dll_B.Sum1 =
        Lifting_wing_HIL_model_dll_P.Constant_Value_p - rtb_Sum_ag_tmp;

      // Switch: '<S183>/Switch1' incorporates:
      //   Constant: '<S183>/Constant'
      //   Constant: '<S183>/Constant1'

      if (rtb_Compare_a) {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant_Value_j;
      } else {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant1_Value_l;
      }

      // Sum: '<S183>/Sum' incorporates:
      //   Constant: '<S177>/ref_position'
      //   Switch: '<S183>/Switch1'

      rtb_Switch = rtb_Divide_idx_0 +
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[1];

      // Switch: '<S196>/Switch' incorporates:
      //   Abs: '<S196>/Abs'
      //   Constant: '<S203>/Constant'
      //   RelationalOperator: '<S203>/Compare'

      if (std::abs(rtb_Switch) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const_f) {
        // Switch: '<S196>/Switch' incorporates:
        //   Bias: '<S196>/Bias'
        //   Bias: '<S196>/Bias1'
        //   Constant: '<S196>/Constant2'
        //   Math: '<S196>/Math Function1'

        Lifting_wing_HIL_model_dll_B.Switch_p = rt_modd_snf(rtb_Switch +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_a,
          Lifting_wing_HIL_model_dll_P.Constant2_Value_o) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_kz;
      } else {
        // Switch: '<S196>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch_p = rtb_Switch;
      }

      // End of Switch: '<S196>/Switch'
    }

    // Sum: '<S177>/Sum' incorporates:
    //   Constant: '<S204>/Constant1'
    //   Integrator: '<S295>/xe,ye,ze'
    //   Product: '<S184>/rad lat'
    //   Product: '<S184>/x*cos'
    //   Product: '<S184>/y*sin'
    //   Product: '<S204>/Product1'
    //   Product: '<S204>/Product3'
    //   Sqrt: '<S204>/sqrt'
    //   Sum: '<S184>/Sum'
    //   UnitConversion: '<S185>/Unit Conversion'

    // Unit Conversion - from: rad to: deg
    // Expression: output = (57.2958*input) + (0)
    rtb_Switch = (Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[0] *
                  Lifting_wing_HIL_model_dll_B.SinCos_o2 -
                  Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[1] *
                  Lifting_wing_HIL_model_dll_B.SinCos_o1) /
      (Lifting_wing_HIL_model_dll_P.Constant1_Value_g / std::sqrt(rtb_Sum_o) *
       Lifting_wing_HIL_model_dll_B.Sum1 / rtb_Sum_o) * 57.295779513082323 +
      Lifting_wing_HIL_model_dll_B.Switch;

    // Switch: '<S190>/Switch' incorporates:
    //   Abs: '<S190>/Abs'
    //   Constant: '<S193>/Constant'
    //   RelationalOperator: '<S193>/Compare'

    if (std::abs(rtb_Switch) >
        Lifting_wing_HIL_model_dll_P.CompareToConstant_const_h) {
      // Switch: '<S190>/Switch' incorporates:
      //   Bias: '<S190>/Bias'
      //   Bias: '<S190>/Bias1'
      //   Constant: '<S190>/Constant2'
      //   Math: '<S190>/Math Function1'

      rtb_Gain7 = rt_modd_snf(rtb_Switch +
        Lifting_wing_HIL_model_dll_P.Bias_Bias_b,
        Lifting_wing_HIL_model_dll_P.Constant2_Value_i) +
        Lifting_wing_HIL_model_dll_P.Bias1_Bias_kx;
    } else {
      // Switch: '<S190>/Switch'
      rtb_Gain7 = rtb_Switch;
    }

    // End of Switch: '<S190>/Switch'

    // Abs: '<S189>/Abs' incorporates:
    //   Abs: '<S186>/Abs1'

    rtb_Switch = std::abs(rtb_Gain7);

    // If: '<S189>/If'
    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f;

    // Outputs for Atomic SubSystem: '<S172>/Wind Models'
    // Outputs for Enabled SubSystem: '<S224>/Hugw(s)' incorporates:
    //   EnablePort: '<S237>/Enable'

    // Outputs for Enabled SubSystem: '<S223>/Hrgw' incorporates:
    //   EnablePort: '<S236>/Enable'

    // Outputs for Enabled SubSystem: '<S224>/Hvgw(s)' incorporates:
    //   EnablePort: '<S238>/Enable'

    // Outputs for Enabled SubSystem: '<S223>/Hqgw' incorporates:
    //   EnablePort: '<S235>/Enable'

    // Outputs for Enabled SubSystem: '<S224>/Hwgw(s)' incorporates:
    //   EnablePort: '<S239>/Enable'

    // Outputs for Enabled SubSystem: '<S223>/Hpgw' incorporates:
    //   EnablePort: '<S234>/Enable'

    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
    //   EnablePort: '<S218>/Enable'

    // If: '<S26>/If' incorporates:
    //   If: '<S135>/If'
    //   If: '<S144>/If'
    //   If: '<S189>/If'
    //   If: '<S228>/if Height < Max low altitude  elseif Height > Min isotropic altitude '
    //   If: '<S229>/if Height < Max low altitude  elseif Height > Min isotropic altitude '
    //   If: '<S296>/If'
    //   If: '<S324>/If'
    //   If: '<S339>/If1'
    //   If: '<S35>/If'
    //   If: '<S47>/If'
    //   If: '<S50>/If1'

    tmp_0 = rtsiIsModeUpdateTimeStep(&(&Lifting_wing_HIL_model_dll_M)
      ->solverInfo);

    // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
    // End of Outputs for SubSystem: '<S223>/Hpgw'
    // End of Outputs for SubSystem: '<S224>/Hwgw(s)'
    // End of Outputs for SubSystem: '<S223>/Hqgw'
    // End of Outputs for SubSystem: '<S224>/Hvgw(s)'
    // End of Outputs for SubSystem: '<S223>/Hrgw'
    // End of Outputs for SubSystem: '<S224>/Hugw(s)'
    // End of Outputs for SubSystem: '<S172>/Wind Models'

    // If: '<S189>/If' incorporates:
    //   Abs: '<S189>/Abs'

    if (tmp_0) {
      rtAction = static_cast<int8_T>(!(rtb_Switch > 0.0));
      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    if (rtAction == 0) {
      // Outputs for IfAction SubSystem: '<S189>/If Action Subsystem' incorporates:
      //   ActionPort: '<S191>/Action Port'

      Lifting_wing__IfActionSubsystem(rtb_Gain7, rtb_Switch,
        &Lifting_wing_HIL_model_dll_B.Merge_m);

      // End of Outputs for SubSystem: '<S189>/If Action Subsystem'
    } else {
      // Outputs for IfAction SubSystem: '<S189>/If Action Subsystem1' incorporates:
      //   ActionPort: '<S192>/Action Port'

      Lifting_wing_IfActionSubsystem1(&Lifting_wing_HIL_model_dll_B.Merge_m,
        &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1_j1);

      // End of Outputs for SubSystem: '<S189>/If Action Subsystem1'
    }

    // Switch: '<S186>/Switch' incorporates:
    //   Bias: '<S186>/Bias'
    //   Bias: '<S186>/Bias1'
    //   Constant: '<S188>/Constant'
    //   Gain: '<S186>/Gain'
    //   Product: '<S186>/Divide1'
    //   RelationalOperator: '<S188>/Compare'
    //   Switch: '<S182>/Switch1'

    if (rtb_Switch > Lifting_wing_HIL_model_dll_P.CompareToConstant_const_j) {
      rtb_Gain7 = ((rtb_Switch + Lifting_wing_HIL_model_dll_P.Bias_Bias_c0) *
                   Lifting_wing_HIL_model_dll_P.Gain_Gain_m0 +
                   Lifting_wing_HIL_model_dll_P.Bias1_Bias_i) *
        Lifting_wing_HIL_model_dll_B.Merge_m;
    }

    // End of Switch: '<S186>/Switch'

    // Sum: '<S177>/Sum1' incorporates:
    //   Constant: '<S172>/envAltitude'
    //   UnaryMinus: '<S177>/Ze2height'

    Merge = -rtb_sincos_o1[2] -
      Lifting_wing_HIL_model_dll_P.ModelParam_envAltitude;

    // Saturate: '<S172>/Saturation' incorporates:
    //   Sum: '<S177>/Sum1'

    if (Merge > Lifting_wing_HIL_model_dll_P.Saturation_UpperSat) {
      // Saturate: '<S172>/Saturation'
      Lifting_wing_HIL_model_dll_B.Saturation =
        Lifting_wing_HIL_model_dll_P.Saturation_UpperSat;
    } else if (Merge < Lifting_wing_HIL_model_dll_P.Saturation_LowerSat) {
      // Saturate: '<S172>/Saturation'
      Lifting_wing_HIL_model_dll_B.Saturation =
        Lifting_wing_HIL_model_dll_P.Saturation_LowerSat;
    } else {
      // Saturate: '<S172>/Saturation'
      Lifting_wing_HIL_model_dll_B.Saturation = Merge;
    }

    // End of Saturate: '<S172>/Saturation'

    // GravityWGS84: '<S181>/WGS84 Gravity Model  '
    lat = rtb_Gain7 * 0.017453292519943295;
    fphi = std::abs(lat);
    rtb_Switch = 1.0;
    if (fphi > 3.1415926535897931) {
      if (lat < -3.1415926535897931) {
        rtb_Switch = -1.0;
      }

      if (std::isinf(fphi + 3.1415926535897931)) {
        rtb_Gain7 = (rtNaN);
      } else {
        rtb_Gain7 = std::fmod(fphi + 3.1415926535897931, 6.2831853071795862);
        rEQ0 = (rtb_Gain7 == 0.0);
        if (!rEQ0) {
          q = (fphi + 3.1415926535897931) / 6.2831853071795862;
          rEQ0 = !(std::abs(q - std::floor(q + 0.5)) > 2.2204460492503131E-16 *
                   q);
        }

        if (rEQ0) {
          rtb_Gain7 = 0.0;
        }
      }

      lat = (rtb_Gain7 - 3.1415926535897931) * rtb_Switch;
      fphi = std::abs(lat);
    }

    if (fphi > 1.5707963267948966) {
      if (lat > 1.5707963267948966) {
        lat = 1.5707963267948966 - (fphi - 1.5707963267948966);
      }

      if (lat < -1.5707963267948966) {
        lat = -(1.5707963267948966 - (fphi - 1.5707963267948966));
      }
    }

    rtb_jxi = std::sin(lat);
    rtb_Switch = rtb_jxi * rtb_jxi;
    rtb_Sum4_h[2] = ((1.0 - (1.006802597171564 - 2.0 * rtb_Switch /
      298.257223563) * 2.0 * Lifting_wing_HIL_model_dll_B.Saturation /
                      6.378137E+6) + 3.0 *
                     Lifting_wing_HIL_model_dll_B.Saturation *
                     Lifting_wing_HIL_model_dll_B.Saturation /
                     4.0680631590769E+13) * ((0.00193185265241 * rtb_Switch +
      1.0) * 9.7803253359 / std::sqrt(1.0 - 0.00669437999014 * rtb_Switch));

    // S-Function (saeroatmos): '<S263>/S-Function'
    {
      // S-Function Block: <S263>/S-Function
      real_T *temp_table = (real_T *)
        &Lifting_wing_HIL_model_dll_DW.SFunction_temp_table[0];
      real_T *pres_table = (real_T *)
        &Lifting_wing_HIL_model_dll_DW.SFunction_pres_table[0];

      // COESA
      CalcAtmosCOESA( &Lifting_wing_HIL_model_dll_B.Saturation,
                     &Lifting_wing_HIL_model_dll_B.SFunction_o1,
                     &Lifting_wing_HIL_model_dll_B.SFunction_o3,
                     &Lifting_wing_HIL_model_dll_B.SFunction_o4,
                     &Lifting_wing_HIL_model_dll_B.SFunction_o2, temp_table,
                     pres_table, 1);
    }

    // Switch: '<S181>/Switch1' incorporates:
    //   Constant: '<S181>/Constant1'

    // Unit Conversion - from: K to: degC
    // Expression: output = (1*input) + (-273.15)
    if (Lifting_wing_HIL_model_dll_P.ModelParam_use_CoesaAtmosphereModel_temperature)
    {
      // BusCreator: '<S172>/Bus Creator' incorporates:
      //   UnitConversion: '<S264>/Unit Conversion'

      rtb_Switch = Lifting_wing_HIL_model_dll_B.SFunction_o1 -
        273.15000000000003;
    } else {
      // BusCreator: '<S172>/Bus Creator' incorporates:
      //   Constant: '<S181>/Constant2'

      rtb_Switch = Lifting_wing_HIL_model_dll_P.ModelParam_temperature;
    }

    // End of Switch: '<S181>/Switch1'

    // Switch: '<S181>/Switch' incorporates:
    //   Constant: '<S181>/airDensity1'

    if (Lifting_wing_HIL_model_dll_P.ModelParam_use_CoesaAtmosphereModel_density)
    {
      // Switch: '<S181>/Switch'
      Merge = Lifting_wing_HIL_model_dll_B.SFunction_o4;
    } else {
      // Switch: '<S181>/Switch' incorporates:
      //   Constant: '<S181>/airDensity'

      Merge = Lifting_wing_HIL_model_dll_P.ModelParam_LBRho;
    }

    // End of Switch: '<S181>/Switch'

    // MATLAB Function: '<Root>/MATLAB Function1' incorporates:
    //   Inport: '<Root>/inSILFloats'

    // MATLAB Function 'MATLAB Function1': '<S3>:1'
    // '<S3>:1:4' x = 1 + inSILFloats(3)/100;
    x = Lifting_wing_HIL_model_dll_U.inSILFloats[2] / 100.0F + 1.0F;

    // '<S3>:1:5' if x >= 1.1
    if (x >= 1.1) {
      // '<S3>:1:6' x = single(1.1);
      x = 1.1F;
    } else if (x <= 0.9) {
      // '<S3>:1:7' elseif x <= 0.9
      // '<S3>:1:8' x = single(0.9);
      x = 0.9F;
    }

    // '<S3>:1:12' y = [x;0;0;inSILFloats(4);inSILFloats(5);inSILFloats(6)];
    rtb_y_ho[0] = x;
    rtb_y_ho[1] = 0.0F;
    rtb_y_ho[2] = 0.0F;
    rtb_y_ho[3] = Lifting_wing_HIL_model_dll_U.inSILFloats[3];
    rtb_y_ho[4] = Lifting_wing_HIL_model_dll_U.inSILFloats[4];
    rtb_y_ho[5] = Lifting_wing_HIL_model_dll_U.inSILFloats[5];

    // Outputs for Atomic SubSystem: '<S172>/Wind Models'
    // Outputs for Enabled SubSystem: '<S224>/Hugw(s)' incorporates:
    //   EnablePort: '<S237>/Enable'

    // Outputs for Enabled SubSystem: '<S223>/Hrgw' incorporates:
    //   EnablePort: '<S236>/Enable'

    // Outputs for Enabled SubSystem: '<S224>/Hvgw(s)' incorporates:
    //   EnablePort: '<S238>/Enable'

    // Outputs for Enabled SubSystem: '<S223>/Hqgw' incorporates:
    //   EnablePort: '<S235>/Enable'

    // Outputs for Enabled SubSystem: '<S224>/Hwgw(s)' incorporates:
    //   EnablePort: '<S239>/Enable'

    rEQ0 = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
            (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0);

    // End of Outputs for SubSystem: '<S224>/Hwgw(s)'
    // End of Outputs for SubSystem: '<S223>/Hqgw'
    // End of Outputs for SubSystem: '<S224>/Hvgw(s)'
    // End of Outputs for SubSystem: '<S223>/Hrgw'
    // End of Outputs for SubSystem: '<S224>/Hugw(s)'

    // RelationalOperator: '<S215>/Gust Start' incorporates:
    //   Clock: '<S5>/Clock1'
    //   Constant: '<S215>/Gust start time'

    fphi = (rtb_DataTypeConversion1_tmp_tmp >=
            Lifting_wing_HIL_model_dll_P.ModelFailWind_GustStartTime);
    if (rEQ0) {
      // RelationalOperator: '<S210>/Compare' incorporates:
      //   Constant: '<S180>/Constant1'
      //   Constant: '<S210>/Constant'

      Lifting_wing_HIL_model_dll_B.Compare =
        (Lifting_wing_HIL_model_dll_P.ModelFailWind_isSheerWind ==
         Lifting_wing_HIL_model_dll_P.CompareToConstant_const_a);

      // RelationalOperator: '<S211>/Compare' incorporates:
      //   Constant: '<S180>/Constant3'
      //   Constant: '<S211>/Constant'

      Lifting_wing_HIL_model_dll_B.Compare_g =
        (Lifting_wing_HIL_model_dll_P.ModelFailWind_isTurbWind ==
         Lifting_wing_HIL_model_dll_P.CompareToConstant1_const);

      // RelationalOperator: '<S212>/Compare' incorporates:
      //   Constant: '<S180>/Constant4'
      //   Constant: '<S212>/Constant'

      rtb_Compare = (Lifting_wing_HIL_model_dll_P.ModelFailWind_isConstWind ==
                     Lifting_wing_HIL_model_dll_P.CompareToConstant2_const);

      // RelationalOperator: '<S213>/Compare' incorporates:
      //   Constant: '<S180>/Constant5'
      //   Constant: '<S213>/Constant'

      Lifting_wing_HIL_model_dll_B.Compare_e =
        (Lifting_wing_HIL_model_dll_P.ModelFailWind_isGustWind ==
         Lifting_wing_HIL_model_dll_P.CompareToConstant3_const);

      // RelationalOperator: '<S214>/Compare' incorporates:
      //   Constant: '<S180>/Constant2'
      //   Constant: '<S214>/Constant'

      Lifting_wing_HIL_model_dll_B.Compare_a =
        (Lifting_wing_HIL_model_dll_P.ModelFailWind_isEnable ==
         Lifting_wing_HIL_model_dll_P.CompareToConstant4_const);

      // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
      //   EnablePort: '<S218>/Enable'

      if (tmp_0) {
        // Logic: '<S215>/Logical Operator2' incorporates:
        //   Constant: '<S215>/Constant'

        if ((fphi != 0.0) &&
            Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_Gx) {
          if (!Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE) {
            (void) std::memset
              (&(Lifting_wing_HIL_model_dll_XDis.DistanceintoGustxLimitedtogus_n),
               0,
               1*sizeof(boolean_T));

            // InitializeConditions for Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)' 
            Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n =
              Lifting_wing_HIL_model_dll_P.DistanceintoGustxLimitedtogustl;
            Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE = true;
          }
        } else {
          if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) ==
              ((&Lifting_wing_HIL_model_dll_M)->getTStart())) {
            (void) std::memset
              (&(Lifting_wing_HIL_model_dll_XDis.DistanceintoGustxLimitedtogus_n),
               1,
               1*sizeof(boolean_T));
          }

          if (Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE) {
            (void) std::memset
              (&(Lifting_wing_HIL_model_dll_XDis.DistanceintoGustxLimitedtogus_n),
               1,
               1*sizeof(boolean_T));
            Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE = false;
          }
        }

        // End of Logic: '<S215>/Logical Operator2'
      }

      // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'

      // SignalConversion generated from: '<S219>/Enable' incorporates:
      //   Constant: '<S215>/Constant1'
      //   Logic: '<S215>/Logical Operator1'

      Lifting_wing_HIL_model_dll_B.HiddenBuf_InsertedFor_Distanc_n = ((fphi !=
        0.0) && Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_Gy);
    }

    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
    //   EnablePort: '<S218>/Enable'

    if (Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE) {
      // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)'
      // Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)'
      // Limited  Integrator
      if (Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n >=
          Lifting_wing_HIL_model_dll_P.Distanceintogustx_d_m) {
        Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n =
          Lifting_wing_HIL_model_dll_P.Distanceintogustx_d_m;
      } else if (Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n <=
                 Lifting_wing_HIL_model_dll_P.DistanceintoGustxLimitedtogus_g) {
        Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n =
          Lifting_wing_HIL_model_dll_P.DistanceintoGustxLimitedtogus_g;
      }

      // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'

      // Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)'
      Lifting_wing_HIL_model_dll_B.DistanceintoGustxLimitedtogustl =
        Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n;
    }

    // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'

    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (y)'
    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (y)'
    Lifting_wing__Distanceintogusty
      (Lifting_wing_HIL_model_dll_B.HiddenBuf_InsertedFor_Distanc_n,
       Lifting_wing_HIL_model_dll_P.Distanceintogusty_d_m,
       &Lifting_wing_HIL_model_dll_B.Distanceintogusty,
       &Lifting_wing_HIL_model_dll_DW.Distanceintogusty,
       &Lifting_wing_HIL_model_dll_P.Distanceintogusty,
       &Lifting_wing_HIL_model_dll_X.Distanceintogusty,
       &_rtXdis->Distanceintogusty);

    // End of Outputs for SubSystem: '<S215>/Distance into gust (y)'
    // End of Outputs for SubSystem: '<S215>/Distance into gust (y)'
    if (rEQ0) {
      // SignalConversion generated from: '<S220>/Enable' incorporates:
      //   Constant: '<S215>/Constant2'
      //   Logic: '<S215>/Logical Operator3'

      Lifting_wing_HIL_model_dll_B.HiddenBuf_InsertedFor_Distanc_l = ((fphi !=
        0.0) && Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_Gz);
    }

    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (z)'
    // Outputs for Enabled SubSystem: '<S215>/Distance into gust (z)'
    Lifting_wing__Distanceintogusty
      (Lifting_wing_HIL_model_dll_B.HiddenBuf_InsertedFor_Distanc_l,
       Lifting_wing_HIL_model_dll_P.Distanceintogustz_d_m,
       &Lifting_wing_HIL_model_dll_B.Distanceintogustz,
       &Lifting_wing_HIL_model_dll_DW.Distanceintogustz,
       &Lifting_wing_HIL_model_dll_P.Distanceintogustz,
       &Lifting_wing_HIL_model_dll_X.Distanceintogustz,
       &_rtXdis->Distanceintogustz);

    // End of Outputs for SubSystem: '<S215>/Distance into gust (z)'
    // End of Outputs for SubSystem: '<S215>/Distance into gust (z)'

    // Gain: '<S215>/Gust magnitude//2.0' incorporates:
    //   Constant: '<S215>/2'
    //   Gain: '<S215>/pi//Gust length'
    //   Sum: '<S215>/Sum1'
    //   Trigonometry: '<S215>/cos(pi*x//dm)'

    rtb_Integrator1_p[0] = (Lifting_wing_HIL_model_dll_P.u_Value - std::cos
      (3.1415926535897931 /
       Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_d_m[0] *
       Lifting_wing_HIL_model_dll_B.DistanceintoGustxLimitedtogustl)) *
      (Lifting_wing_HIL_model_dll_P.ModelFailWind_GustWindAmplitude[0] / 2.0);
    rtb_Integrator1_p[1] = (Lifting_wing_HIL_model_dll_P.u_Value - std::cos
      (3.1415926535897931 /
       Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_d_m[1] *
       Lifting_wing_HIL_model_dll_B.Distanceintogusty.DistanceintoGustxLimitedtogustl))
      * (Lifting_wing_HIL_model_dll_P.ModelFailWind_GustWindAmplitude[1] / 2.0);
    rtb_Integrator1_p[2] = (Lifting_wing_HIL_model_dll_P.u_Value - std::cos
      (3.1415926535897931 /
       Lifting_wing_HIL_model_dll_P.DiscreteWindGustModel_d_m[2] *
       Lifting_wing_HIL_model_dll_B.Distanceintogustz.DistanceintoGustxLimitedtogustl))
      * (Lifting_wing_HIL_model_dll_P.ModelFailWind_GustWindAmplitude[2] / 2.0);
    if (rEQ0) {
      // UnitConversion: '<S222>/Unit Conversion' incorporates:
      //   Constant: '<S216>/Wind direction'

      // Unit Conversion - from: deg to: rad
      // Expression: output = (0.0174533*input) + (0)
      Lifting_wing_HIL_model_dll_B.UnitConversion = 0.017453292519943295 *
        Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_l;
    }

    // UnitConversion: '<S225>/Unit Conversion'
    // Unit Conversion - from: m to: ft
    // Expression: output = (3.28084*input) + (0)
    z = 3.280839895013123 * Lifting_wing_HIL_model_dll_B.Saturation;

    // Saturate: '<S258>/Limit Function 10ft to 1000ft' incorporates:
    //   UnitConversion: '<S225>/Unit Conversion'

    if (z > Lifting_wing_HIL_model_dll_P.LimitFunction10ftto1000ft_Upper) {
      fphi = Lifting_wing_HIL_model_dll_P.LimitFunction10ftto1000ft_Upper;
    } else if (z < Lifting_wing_HIL_model_dll_P.LimitFunction10ftto1000ft_Lower)
    {
      fphi = Lifting_wing_HIL_model_dll_P.LimitFunction10ftto1000ft_Lower;
    } else {
      fphi = z;
    }

    // End of Saturate: '<S258>/Limit Function 10ft to 1000ft'
    if (rEQ0) {
      // UnitConversion: '<S260>/Unit Conversion' incorporates:
      //   Constant: '<S259>/Medium//High Altitude'

      // Unit Conversion - from: m to: ft
      // Expression: output = (3.28084*input) + (0)
      Lifting_wing_HIL_model_dll_B.UnitConversion_h = 3.280839895013123 *
        Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelContin;

      // Gain: '<S241>/sigma_wg ' incorporates:
      //   Constant: '<S216>/Windspeed at 20ft (6m)'
      //   UnitConversion: '<S232>/Unit Conversion'

      // Unit Conversion - from: m/s to: ft/s
      // Expression: output = (3.28084*input) + (0)
      Lifting_wing_HIL_model_dll_B.sigma_wg = 3.280839895013123 *
        Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_c *
        Lifting_wing_HIL_model_dll_P.sigma_wg_Gain;
    }

    // Gain: '<S230>/Lw'
    rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.Lw_Gain * fphi;
    rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_P.Lw_Gain *
      Lifting_wing_HIL_model_dll_B.UnitConversion_h;

    // Interpolation_n-D: '<S240>/Medium//High Altitude Intensity' incorporates:
    //   PreLookup: '<S240>/PreLook-Up Index Search  (altitude)'
    //   UnitConversion: '<S225>/Unit Conversion'

    bpIndex[0] = plook_bincpa(z,
      Lifting_wing_HIL_model_dll_P.PreLookUpIndexSearchaltitude_Br, 11U, &frac[0],
      &Lifting_wing_HIL_model_dll_DW.PreLookUpIndexSearchaltitude_DW);
    if (rEQ0) {
      // PreLookup: '<S240>/PreLook-Up Index Search  (prob of exceed)' incorporates:
      //   Constant: '<S240>/Probability of  Exceedance'

      Lifting_wing_HIL_model_dll_B.PreLookUpIndexSearchprobofexc_o =
        plook_bincpa
        (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_p,
         Lifting_wing_HIL_model_dll_P.PreLookUpIndexSearchprobofexcee, 6U,
         &Lifting_wing_HIL_model_dll_B.PreLookUpIndexSearchprobofexcee,
         &Lifting_wing_HIL_model_dll_DW.PreLookUpIndexSearchprobofexcee);
    }

    // Interpolation_n-D: '<S240>/Medium//High Altitude Intensity'
    frac[1] = Lifting_wing_HIL_model_dll_B.PreLookUpIndexSearchprobofexcee;
    bpIndex[1] = Lifting_wing_HIL_model_dll_B.PreLookUpIndexSearchprobofexc_o;
    q = intrp2d_la_pw(bpIndex, frac,
                      Lifting_wing_HIL_model_dll_P.MediumHighAltitudeIntensity_Tab,
                      12U,
                      Lifting_wing_HIL_model_dll_P.MediumHighAltitudeIntensity_max);
    if (rEQ0) {
      // Sqrt: '<S233>/Sqrt1' incorporates:
      //   Constant: '<S233>/Constant1'

      rtb_Gain7 = std::sqrt(Lifting_wing_HIL_model_dll_P.WhiteNoise_Ts);

      // Product: '<S233>/Product' incorporates:
      //   Constant: '<S233>/Constant'
      //   Product: '<S233>/Divide'
      //   RandomNumber: '<S233>/White Noise'
      //   Sqrt: '<S233>/Sqrt'

      Lifting_wing_HIL_model_dll_B.Product_k[0] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.WhiteNoise_pwr[0]) / rtb_Gain7 *
        Lifting_wing_HIL_model_dll_DW.NextOutput_ia[0];
      Lifting_wing_HIL_model_dll_B.Product_k[1] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.WhiteNoise_pwr[1]) / rtb_Gain7 *
        Lifting_wing_HIL_model_dll_DW.NextOutput_ia[1];
      Lifting_wing_HIL_model_dll_B.Product_k[2] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.WhiteNoise_pwr[2]) / rtb_Gain7 *
        Lifting_wing_HIL_model_dll_DW.NextOutput_ia[2];
      Lifting_wing_HIL_model_dll_B.Product_k[3] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.WhiteNoise_pwr[3]) / rtb_Gain7 *
        Lifting_wing_HIL_model_dll_DW.NextOutput_ia[3];

      // UnitConversion: '<S231>/Unit Conversion' incorporates:
      //   Constant: '<S180>/Constant'

      // Unit Conversion - from: m/s to: ft/s
      // Expression: output = (3.28084*input) + (0)
      Lifting_wing_HIL_model_dll_B.UnitConversion_c = 3.280839895013123 *
        Lifting_wing_HIL_model_dll_P.Constant_Value_d;

      // UnitConversion: '<S226>/Unit Conversion' incorporates:
      //   Constant: '<S216>/Wingspan'

      // Unit Conversion - from: m to: ft
      // Expression: output = (3.28084*input) + (0)
      Lifting_wing_HIL_model_dll_B.UnitConversion_e = 3.280839895013123 *
        Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_g;

      // Outputs for Enabled SubSystem: '<S223>/Hpgw' incorporates:
      //   EnablePort: '<S234>/Enable'

      if (tmp_0) {
        // Constant: '<S223>/Constant1'
        if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0)
        {
          if (!Lifting_wing_HIL_model_dll_DW.Hpgw_MODE) {
            (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.pgw_p_CSTATE),
                               0,
                               2*sizeof(boolean_T));

            // InitializeConditions for Integrator: '<S234>/pgw_p'
            Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[0] =
              Lifting_wing_HIL_model_dll_P.pgw_p_IC;
            Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[1] =
              Lifting_wing_HIL_model_dll_P.pgw_p_IC;
            Lifting_wing_HIL_model_dll_DW.Hpgw_MODE = true;
          }
        } else {
          // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
          //   EnablePort: '<S218>/Enable'

          if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) ==
              ((&Lifting_wing_HIL_model_dll_M)->getTStart())) {
            (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.pgw_p_CSTATE),
                               1,
                               2*sizeof(boolean_T));
          }

          // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
          if (Lifting_wing_HIL_model_dll_DW.Hpgw_MODE) {
            (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.pgw_p_CSTATE),
                               1,
                               2*sizeof(boolean_T));
            Lifting_wing_HIL_model_dll_DW.Hpgw_MODE = false;
          }
        }

        // End of Constant: '<S223>/Constant1'
      }

      // End of Outputs for SubSystem: '<S223>/Hpgw'
    }

    // Outputs for Enabled SubSystem: '<S223>/Hpgw' incorporates:
    //   EnablePort: '<S234>/Enable'

    if (Lifting_wing_HIL_model_dll_DW.Hpgw_MODE) {
      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Product: '<S234>/w4' incorporates:
        //   Constant: '<S234>/Constant3'

        lat = Lifting_wing_HIL_model_dll_P.Constant3_Value /
          Lifting_wing_HIL_model_dll_B.UnitConversion_e;

        // Math: '<S234>/u^1//6' incorporates:
        //   Constant: '<S234>/Constant2'

        if ((lat < 0.0) && (Lifting_wing_HIL_model_dll_P.Constant2_Value_c > std::
                            floor(Lifting_wing_HIL_model_dll_P.Constant2_Value_c)))
        {
          // Math: '<S234>/u^1//6'
          Lifting_wing_HIL_model_dll_B.u16 = -rt_powd_snf(-lat,
            Lifting_wing_HIL_model_dll_P.Constant2_Value_c);
        } else {
          // Math: '<S234>/u^1//6'
          Lifting_wing_HIL_model_dll_B.u16 = rt_powd_snf(lat,
            Lifting_wing_HIL_model_dll_P.Constant2_Value_c);
        }

        // End of Math: '<S234>/u^1//6'

        // Fcn: '<S234>/sqrt(0.8//V)'
        rtb_Gain7 = 0.8 / Lifting_wing_HIL_model_dll_B.UnitConversion_c;
        if (rtb_Gain7 < 0.0) {
          // Fcn: '<S234>/sqrt(0.8//V)'
          Lifting_wing_HIL_model_dll_B.sqrt08V = -std::sqrt(-rtb_Gain7);
        } else {
          // Fcn: '<S234>/sqrt(0.8//V)'
          Lifting_wing_HIL_model_dll_B.sqrt08V = std::sqrt(rtb_Gain7);
        }

        // End of Fcn: '<S234>/sqrt(0.8//V)'

        // Product: '<S234>/w3'
        Lifting_wing_HIL_model_dll_B.w3 =
          Lifting_wing_HIL_model_dll_B.UnitConversion_c * lat;
      }

      // Math: '<S234>/L^1//3' incorporates:
      //   Constant: '<S234>/Constant1'

      sin2beta = std::floor(Lifting_wing_HIL_model_dll_P.Constant1_Value_c);
      if ((rtb_Lw_idx_0 < 0.0) &&
          (Lifting_wing_HIL_model_dll_P.Constant1_Value_c > sin2beta)) {
        rtb_Divide_idx_0 = -rt_powd_snf(-rtb_Lw_idx_0,
          Lifting_wing_HIL_model_dll_P.Constant1_Value_c);
      } else {
        rtb_Divide_idx_0 = rt_powd_snf(rtb_Lw_idx_0,
          Lifting_wing_HIL_model_dll_P.Constant1_Value_c);
      }

      // Product: '<S234>/w' incorporates:
      //   Integrator: '<S234>/pgw_p'
      //   Math: '<S234>/L^1//3'
      //   Product: '<S234>/Lug//V1'
      //   Product: '<S234>/w1'
      //   Product: '<S234>/w2'
      //   Sum: '<S234>/Sum'

      Lifting_wing_HIL_model_dll_B.w_h[0] =
        (Lifting_wing_HIL_model_dll_B.sqrt08V / rtb_Divide_idx_0 *
         Lifting_wing_HIL_model_dll_B.u16 *
         Lifting_wing_HIL_model_dll_B.Product_k[3] -
         Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[0]) *
        Lifting_wing_HIL_model_dll_B.w3;

      // Math: '<S234>/L^1//3' incorporates:
      //   Constant: '<S234>/Constant1'

      if ((rtb_Lw_idx_1 < 0.0) &&
          (Lifting_wing_HIL_model_dll_P.Constant1_Value_c > sin2beta)) {
        rtb_Divide_idx_0 = -rt_powd_snf(-rtb_Lw_idx_1,
          Lifting_wing_HIL_model_dll_P.Constant1_Value_c);
      } else {
        rtb_Divide_idx_0 = rt_powd_snf(rtb_Lw_idx_1,
          Lifting_wing_HIL_model_dll_P.Constant1_Value_c);
      }

      // Product: '<S234>/w' incorporates:
      //   Integrator: '<S234>/pgw_p'
      //   Math: '<S234>/L^1//3'
      //   Product: '<S234>/Lug//V1'
      //   Product: '<S234>/w1'
      //   Product: '<S234>/w2'
      //   Sum: '<S234>/Sum'

      Lifting_wing_HIL_model_dll_B.w_h[1] =
        (Lifting_wing_HIL_model_dll_B.sqrt08V / rtb_Divide_idx_0 *
         Lifting_wing_HIL_model_dll_B.u16 *
         Lifting_wing_HIL_model_dll_B.Product_k[3] -
         Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[1]) *
        Lifting_wing_HIL_model_dll_B.w3;
    }

    // End of Outputs for SubSystem: '<S223>/Hpgw'

    // Outputs for Enabled SubSystem: '<S224>/Hwgw(s)' incorporates:
    //   EnablePort: '<S239>/Enable'

    if (rEQ0 && tmp_0) {
      // Constant: '<S224>/Constant'
      if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0) {
        if (!Lifting_wing_HIL_model_dll_DW.Hwgws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.wg_p1_CSTATE), 0,
                             4*sizeof(boolean_T));

          // InitializeConditions for Integrator: '<S239>/wg_p1'
          Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.wg_p1_IC;

          // InitializeConditions for Integrator: '<S239>/wg_p2'
          Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.wg_p2_IC;

          // InitializeConditions for Integrator: '<S239>/wg_p1'
          Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.wg_p1_IC;

          // InitializeConditions for Integrator: '<S239>/wg_p2'
          Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.wg_p2_IC;
          Lifting_wing_HIL_model_dll_DW.Hwgws_MODE = true;
        }
      } else {
        // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
        //   EnablePort: '<S218>/Enable'

        if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) == ((
              &Lifting_wing_HIL_model_dll_M)->getTStart())) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.wg_p1_CSTATE), 1,
                             4*sizeof(boolean_T));
        }

        // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
        if (Lifting_wing_HIL_model_dll_DW.Hwgws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.wg_p1_CSTATE), 1,
                             4*sizeof(boolean_T));

          // Disable for Product: '<S239>/Lwg//V 1' incorporates:
          //   Outport: '<S239>/wgw'

          Lifting_wing_HIL_model_dll_B.LwgV1[0] =
            Lifting_wing_HIL_model_dll_P.wgw_Y0;
          Lifting_wing_HIL_model_dll_B.LwgV1[1] =
            Lifting_wing_HIL_model_dll_P.wgw_Y0;
          Lifting_wing_HIL_model_dll_DW.Hwgws_MODE = false;
        }
      }
    }

    if (Lifting_wing_HIL_model_dll_DW.Hwgws_MODE) {
      // Product: '<S239>/Lwg//V'
      VectorConcatenate_tmp = rtb_Lw_idx_0 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c;
      rtb_Lw_idx_0 = VectorConcatenate_tmp;

      // Product: '<S239>/w' incorporates:
      //   Gain: '<S239>/1//pi'
      //   Integrator: '<S239>/wg_p1'
      //   Product: '<S239>/Lug//V1'
      //   Sqrt: '<S239>/sqrt1'
      //   Sum: '<S239>/Sum'

      Lifting_wing_HIL_model_dll_B.w[0] = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain_g * VectorConcatenate_tmp) *
        Lifting_wing_HIL_model_dll_B.Product_k[2] -
        Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[0]) / VectorConcatenate_tmp;

      // Product: '<S239>/Lwg//V'
      VectorConcatenate_tmp = rtb_Lw_idx_1 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c;

      // Product: '<S239>/w' incorporates:
      //   Gain: '<S239>/1//pi'
      //   Integrator: '<S239>/wg_p1'
      //   Product: '<S239>/Lug//V1'
      //   Sqrt: '<S239>/sqrt1'
      //   Sum: '<S239>/Sum'

      Lifting_wing_HIL_model_dll_B.w[1] = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain_g * VectorConcatenate_tmp) *
        Lifting_wing_HIL_model_dll_B.Product_k[2] -
        Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[1]) / VectorConcatenate_tmp;
      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Sqrt: '<S239>/sqrt' incorporates:
        //   Constant: '<S239>/Constant'

        Lifting_wing_HIL_model_dll_B.sqrt_e = std::sqrt
          (Lifting_wing_HIL_model_dll_P.Constant_Value_l);
      }

      // Product: '<S239>/Lwg//V 1' incorporates:
      //   Integrator: '<S239>/wg_p2'

      Lifting_wing_HIL_model_dll_B.LwgV1[0] =
        Lifting_wing_HIL_model_dll_B.sigma_wg *
        Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[0];
      Lifting_wing_HIL_model_dll_B.LwgV1[1] = q *
        Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[1];

      // Product: '<S239>/w ' incorporates:
      //   Integrator: '<S239>/wg_p1'
      //   Integrator: '<S239>/wg_p2'
      //   Product: '<S239>/Lwg//V'
      //   Product: '<S239>/Lwg//V '
      //   Sum: '<S239>/Sum1'

      Lifting_wing_HIL_model_dll_B.w_e[0] = (Lifting_wing_HIL_model_dll_B.w[0] *
        Lifting_wing_HIL_model_dll_B.sqrt_e * rtb_Lw_idx_0 +
        (Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[0] -
         Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[0])) / rtb_Lw_idx_0;
      Lifting_wing_HIL_model_dll_B.w_e[1] = (Lifting_wing_HIL_model_dll_B.w[1] *
        Lifting_wing_HIL_model_dll_B.sqrt_e * VectorConcatenate_tmp +
        (Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[1] -
         Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[1])) / VectorConcatenate_tmp;
    }

    // End of Outputs for SubSystem: '<S224>/Hwgw(s)'

    // Outputs for Enabled SubSystem: '<S223>/Hqgw' incorporates:
    //   EnablePort: '<S235>/Enable'

    if (rEQ0 && tmp_0) {
      // Constant: '<S223>/Constant2'
      if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0) {
        if (!Lifting_wing_HIL_model_dll_DW.Hqgw_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.qgw_p_CSTATE), 0,
                             2*sizeof(boolean_T));

          // InitializeConditions for Integrator: '<S235>/qgw_p'
          Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.qgw_p_IC;
          Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.qgw_p_IC;
          Lifting_wing_HIL_model_dll_DW.Hqgw_MODE = true;
        }
      } else {
        // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
        //   EnablePort: '<S218>/Enable'

        if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) == ((
              &Lifting_wing_HIL_model_dll_M)->getTStart())) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.qgw_p_CSTATE), 1,
                             2*sizeof(boolean_T));
        }

        // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
        if (Lifting_wing_HIL_model_dll_DW.Hqgw_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.qgw_p_CSTATE), 1,
                             2*sizeof(boolean_T));

          // Disable for Product: '<S235>/w' incorporates:
          //   Outport: '<S235>/qgw'

          Lifting_wing_HIL_model_dll_B.w_b5[0] =
            Lifting_wing_HIL_model_dll_P.qgw_Y0;
          Lifting_wing_HIL_model_dll_B.w_b5[1] =
            Lifting_wing_HIL_model_dll_P.qgw_Y0;
          Lifting_wing_HIL_model_dll_DW.Hqgw_MODE = false;
        }
      }

      // End of Constant: '<S223>/Constant2'
    }

    if (Lifting_wing_HIL_model_dll_DW.Hqgw_MODE) {
      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Gain: '<S235>/pi//4'
        Lifting_wing_HIL_model_dll_B.pi4 = Lifting_wing_HIL_model_dll_P.pi4_Gain
          * Lifting_wing_HIL_model_dll_B.UnitConversion_c;
      }

      // Product: '<S235>/w'
      lat = Lifting_wing_HIL_model_dll_B.pi4 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_e;

      // Product: '<S235>/w' incorporates:
      //   Integrator: '<S235>/qgw_p'
      //   Product: '<S235>/wg//V'
      //   Sum: '<S235>/Sum'

      Lifting_wing_HIL_model_dll_B.w_b5[0] =
        (Lifting_wing_HIL_model_dll_B.LwgV1[0] /
         Lifting_wing_HIL_model_dll_B.UnitConversion_c -
         Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[0]) * lat;
      Lifting_wing_HIL_model_dll_B.w_b5[1] =
        (Lifting_wing_HIL_model_dll_B.LwgV1[1] /
         Lifting_wing_HIL_model_dll_B.UnitConversion_c -
         Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[1]) * lat;
    }

    // End of Outputs for SubSystem: '<S223>/Hqgw'

    // Saturate: '<S241>/Limit Height h<1000ft' incorporates:
    //   UnitConversion: '<S225>/Unit Conversion'

    if (z > Lifting_wing_HIL_model_dll_P.LimitHeighth1000ft_UpperSat) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.LimitHeighth1000ft_UpperSat;
    } else if (z < Lifting_wing_HIL_model_dll_P.LimitHeighth1000ft_LowerSat) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.LimitHeighth1000ft_LowerSat;
    } else {
      rtb_Divide_idx_0 = z;
    }

    // Fcn: '<S241>/Low Altitude Intensity' incorporates:
    //   Saturate: '<S241>/Limit Height h<1000ft'

    rtb_Gain7 = 0.000823 * rtb_Divide_idx_0 + 0.177;
    if (rtb_Gain7 < 0.0) {
      rtb_Divide_idx_0 = -rt_powd_snf(-rtb_Gain7, 0.4);
    } else {
      rtb_Divide_idx_0 = rt_powd_snf(rtb_Gain7, 0.4);
    }

    // Product: '<S241>/sigma_ug, sigma_vg' incorporates:
    //   Fcn: '<S241>/Low Altitude Intensity'

    lat = 1.0 / rtb_Divide_idx_0 * Lifting_wing_HIL_model_dll_B.sigma_wg;

    // Fcn: '<S258>/Low Altitude Scale Length'
    rtb_Gain7 = 0.000823 * fphi + 0.177;
    if (rtb_Gain7 < 0.0) {
      rtb_Divide_idx_0 = -rt_powd_snf(-rtb_Gain7, 1.2);
    } else {
      rtb_Divide_idx_0 = rt_powd_snf(rtb_Gain7, 1.2);
    }

    fphi /= rtb_Divide_idx_0;

    // End of Fcn: '<S258>/Low Altitude Scale Length'

    // Gain: '<S230>/Lv'
    rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.Lv_Gain * fphi;
    rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_P.Lv_Gain *
      Lifting_wing_HIL_model_dll_B.UnitConversion_h;

    // Outputs for Enabled SubSystem: '<S224>/Hvgw(s)' incorporates:
    //   EnablePort: '<S238>/Enable'

    if (rEQ0 && tmp_0) {
      // Constant: '<S224>/Constant'
      if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0) {
        if (!Lifting_wing_HIL_model_dll_DW.Hvgws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.vg_p1_CSTATE), 0,
                             4*sizeof(boolean_T));

          // InitializeConditions for Integrator: '<S238>/vg_p1'
          Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.vg_p1_IC;

          // InitializeConditions for Integrator: '<S238>/vgw_p2'
          Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.vgw_p2_IC;

          // InitializeConditions for Integrator: '<S238>/vg_p1'
          Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.vg_p1_IC;

          // InitializeConditions for Integrator: '<S238>/vgw_p2'
          Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.vgw_p2_IC;
          Lifting_wing_HIL_model_dll_DW.Hvgws_MODE = true;
        }
      } else {
        // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
        //   EnablePort: '<S218>/Enable'

        if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) == ((
              &Lifting_wing_HIL_model_dll_M)->getTStart())) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.vg_p1_CSTATE), 1,
                             4*sizeof(boolean_T));
        }

        // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
        if (Lifting_wing_HIL_model_dll_DW.Hvgws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.vg_p1_CSTATE), 1,
                             4*sizeof(boolean_T));

          // Disable for Product: '<S238>/w 1' incorporates:
          //   Outport: '<S238>/vgw'

          Lifting_wing_HIL_model_dll_B.w1[0] =
            Lifting_wing_HIL_model_dll_P.vgw_Y0;
          Lifting_wing_HIL_model_dll_B.w1[1] =
            Lifting_wing_HIL_model_dll_P.vgw_Y0;
          Lifting_wing_HIL_model_dll_DW.Hvgws_MODE = false;
        }
      }
    }

    if (Lifting_wing_HIL_model_dll_DW.Hvgws_MODE) {
      // Product: '<S238>/Lvg//V'
      VectorConcatenate_tmp = rtb_Lw_idx_0 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c;

      // Product: '<S238>/w' incorporates:
      //   Gain: '<S238>/(1//pi)'
      //   Integrator: '<S238>/vg_p1'
      //   Product: '<S238>/Lug//V1'
      //   Sqrt: '<S238>/sqrt'
      //   Sum: '<S238>/Sum'

      rtb_VectorConcatenate_a_idx_1 = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain_l * VectorConcatenate_tmp) *
        Lifting_wing_HIL_model_dll_B.Product_k[1] -
        Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[0]) / VectorConcatenate_tmp;
      Lifting_wing_HIL_model_dll_B.w_d[0] = rtb_VectorConcatenate_a_idx_1;

      // Product: '<S238>/w ' incorporates:
      //   Gain: '<S238>/sqrt(3)'
      //   Integrator: '<S238>/vg_p1'
      //   Integrator: '<S238>/vgw_p2'
      //   Product: '<S238>/Lvg//V '
      //   Sum: '<S238>/Sum1'

      Lifting_wing_HIL_model_dll_B.w_b[0] = (rtb_VectorConcatenate_a_idx_1 *
        VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_P.sqrt3_Gain +
        (Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[0] -
         Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[0])) / VectorConcatenate_tmp;

      // Product: '<S238>/Lvg//V'
      VectorConcatenate_tmp = rtb_Lw_idx_1 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c;

      // Product: '<S238>/w' incorporates:
      //   Gain: '<S238>/(1//pi)'
      //   Integrator: '<S238>/vg_p1'
      //   Product: '<S238>/Lug//V1'
      //   Sqrt: '<S238>/sqrt'
      //   Sum: '<S238>/Sum'

      rtb_VectorConcatenate_a_idx_1 = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain_l * VectorConcatenate_tmp) *
        Lifting_wing_HIL_model_dll_B.Product_k[1] -
        Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[1]) / VectorConcatenate_tmp;
      Lifting_wing_HIL_model_dll_B.w_d[1] = rtb_VectorConcatenate_a_idx_1;

      // Product: '<S238>/w ' incorporates:
      //   Gain: '<S238>/sqrt(3)'
      //   Integrator: '<S238>/vg_p1'
      //   Integrator: '<S238>/vgw_p2'
      //   Product: '<S238>/Lvg//V '
      //   Sum: '<S238>/Sum1'

      Lifting_wing_HIL_model_dll_B.w_b[1] = (rtb_VectorConcatenate_a_idx_1 *
        VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_P.sqrt3_Gain +
        (Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[1] -
         Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[1])) / VectorConcatenate_tmp;

      // Product: '<S238>/w 1' incorporates:
      //   Integrator: '<S238>/vgw_p2'

      Lifting_wing_HIL_model_dll_B.w1[0] = lat *
        Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[0];
      Lifting_wing_HIL_model_dll_B.w1[1] = q *
        Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[1];
    }

    // End of Outputs for SubSystem: '<S224>/Hvgw(s)'

    // Outputs for Enabled SubSystem: '<S223>/Hrgw' incorporates:
    //   EnablePort: '<S236>/Enable'

    if (rEQ0 && tmp_0) {
      // Constant: '<S223>/Constant3'
      if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0) {
        if (!Lifting_wing_HIL_model_dll_DW.Hrgw_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.rgw_p_CSTATE), 0,
                             2*sizeof(boolean_T));

          // InitializeConditions for Integrator: '<S236>/rgw_p'
          Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.rgw_p_IC;
          Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.rgw_p_IC;
          Lifting_wing_HIL_model_dll_DW.Hrgw_MODE = true;
        }
      } else {
        // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
        //   EnablePort: '<S218>/Enable'

        if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) == ((
              &Lifting_wing_HIL_model_dll_M)->getTStart())) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.rgw_p_CSTATE), 1,
                             2*sizeof(boolean_T));
        }

        // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
        if (Lifting_wing_HIL_model_dll_DW.Hrgw_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.rgw_p_CSTATE), 1,
                             2*sizeof(boolean_T));
          Lifting_wing_HIL_model_dll_DW.Hrgw_MODE = false;
        }
      }

      // End of Constant: '<S223>/Constant3'
    }

    if (Lifting_wing_HIL_model_dll_DW.Hrgw_MODE) {
      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Gain: '<S236>/pi//3'
        Lifting_wing_HIL_model_dll_B.pi3 = Lifting_wing_HIL_model_dll_P.pi3_Gain
          * Lifting_wing_HIL_model_dll_B.UnitConversion_c;
      }

      // Product: '<S236>/w'
      rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_B.pi3 /
        Lifting_wing_HIL_model_dll_B.UnitConversion_e;

      // Product: '<S236>/w' incorporates:
      //   Integrator: '<S236>/rgw_p'
      //   Product: '<S236>/vg//V'
      //   Sum: '<S236>/Sum'

      Lifting_wing_HIL_model_dll_B.w_a[0] = (Lifting_wing_HIL_model_dll_B.w1[0] /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c -
        Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[0]) * rtb_Lw_idx_0;
      Lifting_wing_HIL_model_dll_B.w_a[1] = (Lifting_wing_HIL_model_dll_B.w1[1] /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c -
        Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[1]) * rtb_Lw_idx_0;
    }

    // End of Outputs for SubSystem: '<S223>/Hrgw'

    // Outputs for Enabled SubSystem: '<S224>/Hugw(s)' incorporates:
    //   EnablePort: '<S237>/Enable'

    if (rEQ0 && tmp_0) {
      // Constant: '<S224>/Constant'
      if (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_b > 0.0) {
        if (!Lifting_wing_HIL_model_dll_DW.Hugws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.ug_p_CSTATE), 0,
                             2*sizeof(boolean_T));

          // InitializeConditions for Integrator: '<S237>/ug_p'
          Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[0] =
            Lifting_wing_HIL_model_dll_P.ug_p_IC;
          Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[1] =
            Lifting_wing_HIL_model_dll_P.ug_p_IC;
          Lifting_wing_HIL_model_dll_DW.Hugws_MODE = true;
        }
      } else {
        // Outputs for Enabled SubSystem: '<S215>/Distance into gust (x)' incorporates:
        //   EnablePort: '<S218>/Enable'

        if ((((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001) == ((
              &Lifting_wing_HIL_model_dll_M)->getTStart())) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.ug_p_CSTATE), 1,
                             2*sizeof(boolean_T));
        }

        // End of Outputs for SubSystem: '<S215>/Distance into gust (x)'
        if (Lifting_wing_HIL_model_dll_DW.Hugws_MODE) {
          (void) std::memset(&(Lifting_wing_HIL_model_dll_XDis.ug_p_CSTATE), 1,
                             2*sizeof(boolean_T));

          // Disable for Product: '<S237>/w1' incorporates:
          //   Outport: '<S237>/ugw'

          Lifting_wing_HIL_model_dll_B.w1_h[0] =
            Lifting_wing_HIL_model_dll_P.ugw_Y0;
          Lifting_wing_HIL_model_dll_B.w1_h[1] =
            Lifting_wing_HIL_model_dll_P.ugw_Y0;
          Lifting_wing_HIL_model_dll_DW.Hugws_MODE = false;
        }
      }
    }

    if (Lifting_wing_HIL_model_dll_DW.Hugws_MODE) {
      // Product: '<S237>/Lug//V'
      rtb_Lw_idx_0 = fphi / Lifting_wing_HIL_model_dll_B.UnitConversion_c;
      rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_B.UnitConversion_h /
        Lifting_wing_HIL_model_dll_B.UnitConversion_c;

      // Product: '<S237>/w' incorporates:
      //   Gain: '<S237>/(2//pi)'
      //   Integrator: '<S237>/ug_p'
      //   Product: '<S237>/Lug//V1'
      //   Sqrt: '<S237>/sqrt'
      //   Sum: '<S237>/Sum'

      Lifting_wing_HIL_model_dll_B.w_b2[0] = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain * rtb_Lw_idx_0) *
        Lifting_wing_HIL_model_dll_B.Product_k[0] -
        Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[0]) / rtb_Lw_idx_0;
      Lifting_wing_HIL_model_dll_B.w_b2[1] = (std::sqrt
        (Lifting_wing_HIL_model_dll_P.upi_Gain * rtb_Lw_idx_1) *
        Lifting_wing_HIL_model_dll_B.Product_k[0] -
        Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[1]) / rtb_Lw_idx_1;

      // Product: '<S237>/w1' incorporates:
      //   Integrator: '<S237>/ug_p'

      Lifting_wing_HIL_model_dll_B.w1_h[0] =
        Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[0] * lat;
      Lifting_wing_HIL_model_dll_B.w1_h[1] =
        Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[1] * q;
    }

    // End of Outputs for SubSystem: '<S224>/Hugw(s)'

    // If: '<S228>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' incorporates:
    //   UnitConversion: '<S225>/Unit Conversion'

    rtPrevAction = Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifHei;
    if (tmp_0) {
      if (z <= 1000.0) {
        rtAction = 0;
      } else if (z >= 2000.0) {
        rtAction = 1;
      } else {
        rtAction = 2;
      }

      Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifHei = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifHei;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    // If: '<S229>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' incorporates:
    //   UnitConversion: '<S225>/Unit Conversion'

    rtPrevAction = Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifH_f;
    if (tmp_0) {
      if (z <= 1000.0) {
        rtAction = 0;
      } else if (z >= 2000.0) {
        rtAction = 1;
      } else {
        rtAction = 2;
      }

      Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifH_f = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifH_f;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    switch (rtAction) {
     case 0:
      // Outputs for IfAction SubSystem: '<S229>/Low altitude  velocities' incorporates:
      //   ActionPort: '<S251>/Action Port'

      // Trigonometry: '<S257>/Trigonometric Function'
      fphi = std::sin(Lifting_wing_HIL_model_dll_B.UnitConversion);
      alt = std::cos(Lifting_wing_HIL_model_dll_B.UnitConversion);

      // Product: '<S256>/Product' incorporates:
      //   Concatenate: '<S256>/Vector Concatenate'
      //   Product: '<S257>/Product1'
      //   Product: '<S257>/Product2'
      //   SignalConversion generated from: '<S256>/Vector Concatenate'
      //   Sum: '<S257>/Sum'
      //   Sum: '<S257>/Sum1'

      rtb_jxi = fphi * Lifting_wing_HIL_model_dll_B.w1_h[0] +
        Lifting_wing_HIL_model_dll_B.w1[0] * alt;
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_B.w1_h[0] * alt - fphi *
        Lifting_wing_HIL_model_dll_B.w1[0];
      rtb_Gain1_idx_2 = Lifting_wing_HIL_model_dll_B.LwgV1[0];

      // Reshape: '<S256>/Reshape1' incorporates:
      //   Concatenate: '<S256>/Vector Concatenate'
      //   Constant: '<S180>/Constant_DCM'
      //   Product: '<S256>/Product'

      for (i = 0; i < 3; i++) {
        rtb_Sum4_g[i] = (Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i + 3] *
                         rtb_jxi +
                         Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i] *
                         rtb_Divide_idx_0) +
          Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i + 6] *
          rtb_Gain1_idx_2;
      }

      // End of Reshape: '<S256>/Reshape1'
      // End of Outputs for SubSystem: '<S229>/Low altitude  velocities'
      break;

     case 1:
      // Outputs for IfAction SubSystem: '<S229>/Medium//High  altitude velocities' incorporates:
      //   ActionPort: '<S252>/Action Port'

      // Gain: '<S252>/Gain'
      rtb_Sum4_g[0] = Lifting_wing_HIL_model_dll_P.Gain_Gain_l1 *
        Lifting_wing_HIL_model_dll_B.w1_h[1];
      rtb_Sum4_g[1] = Lifting_wing_HIL_model_dll_P.Gain_Gain_l1 *
        Lifting_wing_HIL_model_dll_B.w1[1];
      rtb_Sum4_g[2] = Lifting_wing_HIL_model_dll_P.Gain_Gain_l1 *
        Lifting_wing_HIL_model_dll_B.LwgV1[1];

      // End of Outputs for SubSystem: '<S229>/Medium//High  altitude velocities' 
      break;

     default:
      // Outputs for IfAction SubSystem: '<S229>/Interpolate  velocities' incorporates:
      //   ActionPort: '<S250>/Action Port'

      // Trigonometry: '<S255>/Trigonometric Function'
      fphi = std::sin(Lifting_wing_HIL_model_dll_B.UnitConversion);
      rtb_Gain7 = std::cos(Lifting_wing_HIL_model_dll_B.UnitConversion);

      // Sum: '<S255>/Sum' incorporates:
      //   Product: '<S255>/Product1'
      //   Product: '<S255>/Product2'

      rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_B.w1_h[0] * rtb_Gain7 - fphi *
        Lifting_wing_HIL_model_dll_B.w1[0];

      // Sum: '<S255>/Sum1' incorporates:
      //   Product: '<S255>/Product1'
      //   Product: '<S255>/Product2'

      rtb_VectorConcatenate_a_idx_1 = fphi * Lifting_wing_HIL_model_dll_B.w1_h[0]
        + Lifting_wing_HIL_model_dll_B.w1[0] * rtb_Gain7;

      // SignalConversion generated from: '<S254>/Vector Concatenate'
      rtb_VectorConcatenate_a_idx_2 = Lifting_wing_HIL_model_dll_B.LwgV1[0];

      // Product: '<S254>/Product'
      for (i = 0; i < 3; i++) {
        // Product: '<S254>/Product' incorporates:
        //   Concatenate: '<S254>/Vector Concatenate'
        //   Constant: '<S180>/Constant_DCM'

        rtb_Product_d[i] = (Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i +
                            3] * rtb_VectorConcatenate_a_idx_1 +
                            Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i] *
                            rtb_Lw_idx_1) +
          Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i + 6] *
          rtb_VectorConcatenate_a_idx_2;
      }

      // End of Product: '<S254>/Product'

      // Sum: '<S250>/Sum1' incorporates:
      //   Constant: '<S250>/max_height_low'
      //   UnitConversion: '<S225>/Unit Conversion'

      fphi = z - Lifting_wing_HIL_model_dll_P.max_height_low_Value_g;

      // Sum: '<S250>/Sum' incorporates:
      //   Constant: '<S250>/max_height_low'
      //   Constant: '<S250>/min_height_high'

      alt = Lifting_wing_HIL_model_dll_P.min_height_high_Value_h -
        Lifting_wing_HIL_model_dll_P.max_height_low_Value_g;

      // Sum: '<S250>/Sum3' incorporates:
      //   Product: '<S250>/Product1'
      //   Sum: '<S250>/Sum2'

      rtb_Sum4_g[0] = (Lifting_wing_HIL_model_dll_B.w1_h[1] - rtb_Product_d[0]) *
        fphi / alt + rtb_Product_d[0];
      rtb_Sum4_g[1] = (Lifting_wing_HIL_model_dll_B.w1[1] - rtb_Product_d[1]) *
        fphi / alt + rtb_Product_d[1];
      rtb_Sum4_g[2] = (Lifting_wing_HIL_model_dll_B.LwgV1[1] - rtb_Product_d[2])
        * fphi / alt + rtb_Product_d[2];

      // End of Outputs for SubSystem: '<S229>/Interpolate  velocities'
      break;
    }

    // UnitConversion: '<S216>/Unit Conversion'
    // Unit Conversion - from: ft/s to: m/s
    // Expression: output = (0.3048*input) + (0)
    rtb_Sum4_g[0] *= 0.3048;
    rtb_Sum4_g[1] *= 0.3048;
    rtb_Sum4_g[2] *= 0.3048;

    // Unit Conversion - from: m to: ft
    // Expression: output = (3.28084*input) + (0)
    if (rEQ0) {
      // Math: '<S217>/ln(ref_height//z0)' incorporates:
      //   Constant: '<S217>/ref_height//z0'
      //
      //  About '<S217>/ln(ref_height//z0)':
      //   Operator: log

      Lifting_wing_HIL_model_dll_B.lnref_heightz0 = std::log
        (Lifting_wing_HIL_model_dll_P.ref_heightz0_Value);
    }

    // UnitConversion: '<S262>/Unit Conversion'
    lat = 3.280839895013123 * Lifting_wing_HIL_model_dll_B.Saturation;

    // Saturate: '<S217>/3ft-->inf' incorporates:
    //   UnitConversion: '<S262>/Unit Conversion'

    if (lat > Lifting_wing_HIL_model_dll_P.uftinf_UpperSat) {
      lat = Lifting_wing_HIL_model_dll_P.uftinf_UpperSat;
    } else if (lat < Lifting_wing_HIL_model_dll_P.uftinf_LowerSat) {
      lat = Lifting_wing_HIL_model_dll_P.uftinf_LowerSat;
    }

    // Product: '<S217>/Product' incorporates:
    //   Gain: '<S217>/h//z0'
    //   Math: '<S217>/ln(h//z0)'
    //   Saturate: '<S217>/3ft-->inf'
    //
    //  About '<S217>/ln(h//z0)':
    //   Operator: log

    fphi = std::log(Lifting_wing_HIL_model_dll_P.hz0_Gain * lat) /
      Lifting_wing_HIL_model_dll_B.lnref_heightz0;
    if (rEQ0) {
      // UnitConversion: '<S261>/Unit Conversion' incorporates:
      //   Constant: '<S217>/Wind Direction'

      // Unit Conversion - from: deg to: rad
      // Expression: output = (0.0174533*input) + (0)
      rtb_Gain7 = 0.017453292519943295 *
        Lifting_wing_HIL_model_dll_P.WindShearModel_Wdeg;

      // Gain: '<S217>/Wind speed at reference height' incorporates:
      //   Constant: '<S217>/Wdeg1'
      //   Trigonometry: '<S217>/SinCos'

      Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[0] =
        -Lifting_wing_HIL_model_dll_P.WindShearModel_W_20 * std::cos(rtb_Gain7);
      Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[1] =
        -Lifting_wing_HIL_model_dll_P.WindShearModel_W_20 * std::sin(rtb_Gain7);
      Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[2] =
        -Lifting_wing_HIL_model_dll_P.WindShearModel_W_20 *
        Lifting_wing_HIL_model_dll_P.Wdeg1_Value;

      // Product: '<S180>/Product3' incorporates:
      //   Constant: '<S180>/ModelFailWind_ConstWindX'
      //   Constant: '<S180>/ModelFailWind_ConstWindY'
      //   Constant: '<S180>/ModelFailWind_ConstWindZ'

      Lifting_wing_HIL_model_dll_B.wind[0] = static_cast<real_T>(rtb_Compare) *
        Lifting_wing_HIL_model_dll_P.ModelFailWind_ConstWindX;
      Lifting_wing_HIL_model_dll_B.wind[1] = static_cast<real_T>(rtb_Compare) *
        Lifting_wing_HIL_model_dll_P.ModelFailWind_ConstWindY;
      Lifting_wing_HIL_model_dll_B.wind[2] = static_cast<real_T>(rtb_Compare) *
        Lifting_wing_HIL_model_dll_P.ModelFailWind_ConstWindZ;
    }

    // End of Outputs for SubSystem: '<S172>/Wind Models'
    if (tmp) {
      // MATLAB Function: '<S172>/MATLAB Function1' incorporates:
      //   Constant: '<S172>/kappa'

      // MATLAB Function 'Subsystem Reference/Environment Models/MATLAB Function1': '<S179>:1' 
      // '<S179>:1:2' Rm = [cos(k), 0, -sin(k);
      // '<S179>:1:3'     0, 1, 0;
      // '<S179>:1:4'     sin(k), 0, cos(k)];
      // '<S179>:1:5' va_l = Rm * va_b;
      z = Lifting_wing_HIL_model_dll_P.LW_ANGLE * 3.1415926535897931 / 180.0;
      alt = std::sin(z);
      rtb_Gain7 = std::cos(z);

      // Outputs for Atomic SubSystem: '<S172>/Wind Models'
      // Product: '<S217>/Product1' incorporates:
      //   Constant: '<S180>/Constant_DCM'
      //   Product: '<S217>/Transform from Inertial to Body axes'

      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[0];
      q = Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[1];
      lat = Lifting_wing_HIL_model_dll_B.Windspeedatreferenceheight[2];
      for (i = 0; i < 3; i++) {
        // Sum: '<S180>/Sum1' incorporates:
        //   Constant: '<S180>/Constant_DCM'
        //   Product: '<S180>/Product'
        //   Product: '<S180>/Product2'
        //   Product: '<S180>/Product4'
        //   Product: '<S180>/Product5'
        //   Product: '<S217>/Product1'
        //   Product: '<S217>/Transform from Inertial to Body axes'
        //   Sum: '<S180>/Sum'

        R_lb_0[i] = (((((fphi * VectorConcatenate_tmp *
                         Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i] +
                         Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i + 3] *
                         (fphi * q)) +
                        Lifting_wing_HIL_model_dll_P.Constant_DCM_Value[i + 6] *
                        (fphi * lat)) * static_cast<real_T>
                       (Lifting_wing_HIL_model_dll_B.Compare) +
                       static_cast<real_T>
                       (Lifting_wing_HIL_model_dll_B.Compare_g) * rtb_Sum4_g[i])
                      + static_cast<real_T>
                      (Lifting_wing_HIL_model_dll_B.Compare_e) *
                      rtb_Integrator1_p[i]) +
                     Lifting_wing_HIL_model_dll_B.wind[i]) * static_cast<real_T>
          (Lifting_wing_HIL_model_dll_B.Compare_a) + rtb_y_ho[i + 3];
      }

      // End of Outputs for SubSystem: '<S172>/Wind Models'

      // MATLAB Function: '<S172>/MATLAB Function1'
      Comega[0] = rtb_Gain7;
      Comega[3] = 0.0;
      Comega[6] = -alt;
      Comega[2] = alt;
      Comega[5] = 0.0;
      Comega[8] = rtb_Gain7;

      // Outputs for Atomic SubSystem: '<S172>/Wind Models'
      // Product: '<S180>/Product1' incorporates:
      //   Math: '<S294>/Transpose'

      rtb_Divide_idx_0 = R_lb_0[1];
      alt = R_lb_0[0];
      rtb_q3dot = R_lb_0[2];
      for (i = 0; i < 3; i++) {
        // MATLAB Function: '<S172>/MATLAB Function1'
        rtb_lon = 3 * i + 1;
        Comega[rtb_lon] = b[i];

        // Sum: '<S172>/Add' incorporates:
        //   Integrator: '<S295>/ub,vb,wb'

        rtb_Saturation_c[i] = rtb_TmpSignalConversionAtSFunct[i] -
          ((Product_tmp[3 * i] * alt + Product_tmp[rtb_lon] * rtb_Divide_idx_0)
           + Product_tmp[3 * i + 2] * rtb_q3dot);
      }

      // End of Product: '<S180>/Product1'
      // End of Outputs for SubSystem: '<S172>/Wind Models'

      // MATLAB Function: '<S172>/MATLAB Function1'
      // '<S179>:1:8' airspeed = norm(va_l, 2);
      fphi = 0.0;
      alt = 3.3121686421112381E-170;
      VectorConcatenate_tmp = rtb_Saturation_c[1];
      rtb_Lw_idx_1 = rtb_Saturation_c[0];
      rtb_VectorConcatenate_a_idx_1 = rtb_Saturation_c[2];
      for (i = 0; i < 3; i++) {
        Lifting_wing_HIL_model_dll_B.va_l[i] = (Comega[i + 3] *
          VectorConcatenate_tmp + Comega[i] * rtb_Lw_idx_1) + Comega[i + 6] *
          rtb_VectorConcatenate_a_idx_1;
        q = std::abs(Lifting_wing_HIL_model_dll_B.va_l[i]);
        if (q > alt) {
          lat = alt / q;
          fphi = fphi * lat * lat + 1.0;
          alt = q;
        } else {
          lat = q / alt;
          fphi += lat * lat;
        }
      }

      fphi = alt * std::sqrt(fphi);

      // '<S179>:1:9' sigma = 0.3;
      // '<S179>:1:10' alpha = atan2(va_l(3), va_l(1))*tanh(airspeed/sigma);
      alt = std::tanh(fphi / 0.3);
      Lifting_wing_HIL_model_dll_B.alpha = rt_atan2d_snf
        (Lifting_wing_HIL_model_dll_B.va_l[2],
         Lifting_wing_HIL_model_dll_B.va_l[0]) * alt;

      // '<S179>:1:11' beta = asin(va_l(2) / (airspeed+sigma))*tanh(airspeed/sigma); 
      Lifting_wing_HIL_model_dll_B.beta = std::asin
        (Lifting_wing_HIL_model_dll_B.va_l[1] / (fphi + 0.3)) * alt;

      // '<S179>:1:13' qbar = 0.5 * rho * airspeed ^ 2;
      Lifting_wing_HIL_model_dll_B.qbar = 0.5 * Merge * (fphi * fphi);
      Lifting_wing_HIL_model_dll_B.airspeed = fphi;
    }

    // BusCreator: '<S172>/Bus Creator' incorporates:
    //   Inport: '<Root>/TerrainZ'

    z = Lifting_wing_HIL_model_dll_U.TerrainZ;
    BusCreator_landed = Lifting_wing_HIL_model_dll_B.landed;
    lat = Lifting_wing_HIL_model_dll_B.Saturation;
    rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_B.alpha;
    alt = Lifting_wing_HIL_model_dll_B.beta;
    Merge = Lifting_wing_HIL_model_dll_B.airspeed;
    q = Lifting_wing_HIL_model_dll_B.qbar;

    // Function description;
    //   According to the rotational speed, the force and torque provided by the propeller 
    //   to the quadrotor-X aircraft are calculated. The distribution of the quadrotor motor is as follows: 
    // 3   1
    //   \ /
    //   / \
    // 4   2
    //  stands for counterclockwise and stands for clockwise
    // Input
    //   w: Motor speedunitrad/s
    //   R: Body radius(m)
    //   Cm: torque coefficient
    //   Ct: thrust coefficient
    //   Vb: Aircraft speed in the body coordinate system
    //   Cd: Damping coefficient
    //   wb: Angular velocity in the body coordinate system
    //   Cdm: Damping moment coefficient vector
    //   Jrp:  Moment of inertia of motor rotor + propeller
    // Output:
    //   Fb: thrust under the body coordinate system
    //   Fd: air resistance under the body coordinate system
    //   Mb: torque under the body coordinate system
    //   Md: aerodynamic moment
    //   Ga: gyro moment
    // MATLAB Function 'Subsystem Reference/Forces and Moments/Propeller Model': '<S274>:1' 
    // '<S274>:1:31' Cm = ModelParam_rotorCm;
    // '<S274>:1:32' dx = ModelParam_rotordx;
    // '<S274>:1:33' dy = ModelParam_rotordy;
    // '<S274>:1:34' eta = ModelParam_rotorEta;
    // '<S274>:1:35' Jrp = ModelParam_motorJm;
    // '<S274>:1:36' Ct = ModelParam_rotorCt;
    // Calculating gyro moment
    // '<S274>:1:38' Ga = zeros(3,1);
    BusCreator_mag_e[0] = Lifting_wing_HIL_model_dll_B.mag_e[0];
    rtb_IntegratorSecondOrderLimi_p[0] = Lifting_wing_HIL_model_dll_B.va_l[0];

    // Integrator: '<S295>/p,q,r '
    rtb_Product_d[0] = Lifting_wing_HIL_model_dll_X.pqr_CSTATE[0];

    // BusCreator: '<S172>/Bus Creator'
    BusCreator_mag_e[1] = Lifting_wing_HIL_model_dll_B.mag_e[1];
    rtb_IntegratorSecondOrderLimi_p[1] = Lifting_wing_HIL_model_dll_B.va_l[1];

    // Integrator: '<S295>/p,q,r '
    rtb_Product_d[1] = Lifting_wing_HIL_model_dll_X.pqr_CSTATE[1];

    // BusCreator: '<S172>/Bus Creator'
    BusCreator_mag_e[2] = Lifting_wing_HIL_model_dll_B.mag_e[2];
    rtb_Saturation_c[2] = rtb_Sum4_h[2];
    rtb_IntegratorSecondOrderLimi_p[2] = Lifting_wing_HIL_model_dll_B.va_l[2];

    // Integrator: '<S295>/p,q,r '
    rtb_Product_d[2] = Lifting_wing_HIL_model_dll_X.pqr_CSTATE[2];

    // MATLAB Function: '<S173>/Propeller Model' incorporates:
    //   BusCreator: '<S172>/Bus Creator'
    //   Integrator: '<S295>/p,q,r '
    //   SignalConversion generated from: '<S274>/ SFunction '

    rtb_Sum4_g[2] = 0.0;

    // '<S274>:1:39' Ga(1) = Jrp*wb(2)*( w(1) - w(2) - w(3) + w(4));
    rtb_Sum4_g[0] = (((Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator -
                       Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m) -
                      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k) +
                     Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o) *
      (Lifting_wing_HIL_model_dll_P.ModelParam_motorJm *
       Lifting_wing_HIL_model_dll_X.pqr_CSTATE[1]);

    // '<S274>:1:40' Ga(2) = Jrp*wb(1)*(-w(1) + w(2) + w(3) - w(4));
    rtb_Sum4_g[1] = (((-Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator +
                       Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m) +
                      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k) -
                     Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o) *
      (Lifting_wing_HIL_model_dll_P.ModelParam_motorJm *
       Lifting_wing_HIL_model_dll_X.pqr_CSTATE[0]);

    // '<S274>:1:42' w = w(:);
    // '<S274>:1:44' if USE_PROPELLER_MODEL1
    if (Lifting_wing_HIL_model_dll_P.USE_PROPELLER_MODEL1) {
      // '<S274>:1:45' M_rctcm = [-dy*Ct*cos(eta),  -dy*Ct*cos(eta), dy*Ct*cos(eta), dy*Ct*cos(eta); 
      // '<S274>:1:46'         dx*Ct*cos(eta), -dx*Ct*cos(eta), dx*Ct*cos(eta), -dx*Ct*cos(eta); 
      // '<S274>:1:47'         Cm+dx*sin(eta), -Cm-dx*sin(eta), -Cm - dx*sin(eta), Cm+dx*sin(eta)]; 
      // '<S274>:1:49' Mp = M_rctcm*(w.^2);
      rtb_Sum_ag_tmp = Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator *
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator;
      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m *
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m;
      rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k *
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k;
      rtb_q3dot_tmp = Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o *
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o;
      rtb_VectorConcatenate_a_idx_1 = std::cos
        (Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      rtb_VectorConcatenate_a_idx_2 = std::sin
        (Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      sin2beta = -Lifting_wing_HIL_model_dll_P.ModelParam_rotordy *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt *
        rtb_VectorConcatenate_a_idx_1;
      tmp_2[0] = sin2beta;
      tmp_2[3] = sin2beta;
      sin2beta = Lifting_wing_HIL_model_dll_P.ModelParam_rotordy *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt *
        rtb_VectorConcatenate_a_idx_1;
      tmp_2[6] = sin2beta;
      tmp_2[9] = sin2beta;
      sin2beta = Lifting_wing_HIL_model_dll_P.ModelParam_rotordx *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt *
        rtb_VectorConcatenate_a_idx_1;
      tmp_2[1] = sin2beta;
      rtb_Gain7 = -Lifting_wing_HIL_model_dll_P.ModelParam_rotordx *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt *
        rtb_VectorConcatenate_a_idx_1;
      tmp_2[4] = rtb_Gain7;
      tmp_2[7] = sin2beta;
      tmp_2[10] = rtb_Gain7;
      tmp_2[2] = Lifting_wing_HIL_model_dll_P.ModelParam_rotordx *
        rtb_VectorConcatenate_a_idx_2 +
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCm;
      sin2beta = -Lifting_wing_HIL_model_dll_P.ModelParam_rotorCm -
        Lifting_wing_HIL_model_dll_P.ModelParam_rotordx * std::sin
        (Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      tmp_2[5] = sin2beta;
      tmp_2[8] = sin2beta;
      tmp_2[11] = Lifting_wing_HIL_model_dll_P.ModelParam_rotordx * std::sin
        (Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta) +
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCm;
      for (i = 0; i < 3; i++) {
        rtb_Mp[i] = ((tmp_2[i + 3] * VectorConcatenate_tmp + tmp_2[i] *
                      rtb_Sum_ag_tmp) + tmp_2[i + 6] * rtb_Lw_idx_1) + tmp_2[i +
          9] * rtb_q3dot_tmp;
      }

      // torque
      // '<S274>:1:51' Fp = [0 0 0 0;
      // '<S274>:1:52'         sin(eta) sin(eta) -sin(eta) -sin(eta);
      // '<S274>:1:53'         -cos(eta) -cos(eta) -cos(eta) -cos(eta)]*Ct*(w.^2); 
      tmp_2[0] = 0.0 * Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[3] = 0.0 * Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[6] = 0.0 * Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[9] = 0.0 * Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      sin2beta = rtb_VectorConcatenate_a_idx_2 *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[1] = sin2beta;
      tmp_2[4] = sin2beta;
      sin2beta = -rtb_VectorConcatenate_a_idx_2 *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[7] = sin2beta;
      tmp_2[10] = sin2beta;
      sin2beta = -rtb_VectorConcatenate_a_idx_1 *
        Lifting_wing_HIL_model_dll_P.ModelParam_rotorCt;
      tmp_2[2] = sin2beta;
      tmp_2[5] = sin2beta;
      tmp_2[8] = sin2beta;
      tmp_2[11] = sin2beta;
      for (i = 0; i < 3; i++) {
        rtb_Fp[i] = ((tmp_2[i + 3] * VectorConcatenate_tmp + tmp_2[i] *
                      rtb_Sum_ag_tmp) + tmp_2[i + 6] * rtb_Lw_idx_1) + tmp_2[i +
          9] * rtb_q3dot_tmp;
      }

      // thrust
    } else {
      // '<S274>:1:54' else
      // '<S274>:1:55' w = w*3/(16*pi);
      // '<S274>:1:56' T = ModelParam_propellerkT0*ones(4,1) + ModelParam_propellerkTvarpi*w + ModelParam_propellerkTV*Va*ones(4,1) + ... 
      // '<S274>:1:57'         ModelParam_propellerkTvarpi2*w.*w + ModelParam_propellerkTvarpiV*w*Va + ModelParam_propellerkTV2*Va^2*ones(4,1); 
      fphi = Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTV *
        Lifting_wing_HIL_model_dll_B.airspeed;
      rtb_Sum_ag_tmp = Lifting_wing_HIL_model_dll_B.airspeed *
        Lifting_wing_HIL_model_dll_B.airspeed;
      rtb_jxi = rtb_Sum_ag_tmp *
        Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTV2;
      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator * 3.0 /
        50.26548245743669;
      rtb_Sum_o = VectorConcatenate_tmp;
      rtb_Divide_idx_0 =
        ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi *
            VectorConcatenate_tmp +
            Lifting_wing_HIL_model_dll_P.ModelParam_propellerkT0) + fphi) +
          Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi2 *
          VectorConcatenate_tmp * VectorConcatenate_tmp) +
         Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpiV *
         VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_jxi;
      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m * 3.0 /
        50.26548245743669;
      rtb_Gain1_idx_1 = VectorConcatenate_tmp;
      rtb_VectorConcatenate_a_idx_1 =
        ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi *
            VectorConcatenate_tmp +
            Lifting_wing_HIL_model_dll_P.ModelParam_propellerkT0) + fphi) +
          Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi2 *
          VectorConcatenate_tmp * VectorConcatenate_tmp) +
         Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpiV *
         VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_jxi;
      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k * 3.0 /
        50.26548245743669;
      rtb_Gain1_idx_2 = VectorConcatenate_tmp;
      rtb_VectorConcatenate_a_idx_2 =
        ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi *
            VectorConcatenate_tmp +
            Lifting_wing_HIL_model_dll_P.ModelParam_propellerkT0) + fphi) +
          Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi2 *
          VectorConcatenate_tmp * VectorConcatenate_tmp) +
         Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpiV *
         VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_jxi;
      VectorConcatenate_tmp =
        Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o * 3.0 /
        50.26548245743669;
      rtb_Lw_idx_1 =
        ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi *
            VectorConcatenate_tmp +
            Lifting_wing_HIL_model_dll_P.ModelParam_propellerkT0) + fphi) +
          Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpi2 *
          VectorConcatenate_tmp * VectorConcatenate_tmp) +
         Lifting_wing_HIL_model_dll_P.ModelParam_propellerkTvarpiV *
         VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_jxi;

      // '<S274>:1:58' Fp = [0 0 0 0;
      // '<S274>:1:59'         sin(eta) sin(eta) -sin(eta) -sin(eta);
      // '<S274>:1:60'         -cos(eta) -cos(eta) -cos(eta) -cos(eta)]*T;
      fphi = std::sin(Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      rtb_Gain7 = std::cos(Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      tmp_2[0] = 0.0;
      tmp_2[3] = 0.0;
      tmp_2[6] = 0.0;
      tmp_2[9] = 0.0;
      tmp_2[1] = fphi;
      tmp_2[4] = fphi;
      tmp_2[7] = -fphi;
      tmp_2[10] = -fphi;
      tmp_2[2] = -rtb_Gain7;
      tmp_2[5] = -rtb_Gain7;
      tmp_2[8] = -rtb_Gain7;
      tmp_2[11] = -rtb_Gain7;
      for (i = 0; i < 3; i++) {
        rtb_Fp[i] = ((tmp_2[i + 3] * rtb_VectorConcatenate_a_idx_1 + tmp_2[i] *
                      rtb_Divide_idx_0) + tmp_2[i + 6] *
                     rtb_VectorConcatenate_a_idx_2) + tmp_2[i + 9] *
          rtb_Lw_idx_1;
      }

      // thrust
      // '<S274>:1:61' M = ModelParam_propellerkM0*ones(4,1) + ModelParam_propellerkMvarpi*w + ModelParam_propellerkMV*Va*ones(4,1) + ... 
      // '<S274>:1:62'         ModelParam_propellerkMvarpi2*w.*w + ModelParam_propellerkMvarpiV*w*Va + ModelParam_propellerkMV2*Va^2*ones(4,1); 
      rtb_jxi = Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMV *
        Lifting_wing_HIL_model_dll_B.airspeed;
      rtb_q3dot = rtb_Sum_ag_tmp *
        Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMV2;

      // '<S274>:1:63' M_rctcm = [-dy*cos(eta),  -dy*cos(eta), dy*cos(eta), dy*cos(eta); 
      // '<S274>:1:64'         dx*cos(eta), -dx*cos(eta), dx*cos(eta), -dx*cos(eta); 
      // '<S274>:1:65'         dx*sin(eta), -dx*sin(eta), -dx*sin(eta), dx*sin(eta)]*T; 
      // '<S274>:1:67' Mp = M_rctcm +[0 0 0 0;0 0 0 0;1 1 -1 -1]*M;
      sin2beta = -Lifting_wing_HIL_model_dll_P.ModelParam_rotordy * rtb_Gain7;
      tmp_2[0] = sin2beta;
      tmp_2[3] = sin2beta;
      sin2beta = Lifting_wing_HIL_model_dll_P.ModelParam_rotordy * rtb_Gain7;
      tmp_2[6] = sin2beta;
      tmp_2[9] = sin2beta;
      sin2beta = Lifting_wing_HIL_model_dll_P.ModelParam_rotordx * rtb_Gain7;
      tmp_2[1] = sin2beta;
      rtb_Gain7 *= -Lifting_wing_HIL_model_dll_P.ModelParam_rotordx;
      tmp_2[4] = rtb_Gain7;
      tmp_2[7] = sin2beta;
      tmp_2[10] = rtb_Gain7;
      sin2beta = Lifting_wing_HIL_model_dll_P.ModelParam_rotordx * std::sin
        (Lifting_wing_HIL_model_dll_P.ModelParam_rotorEta);
      tmp_2[2] = sin2beta;
      rtb_Gain7 = -Lifting_wing_HIL_model_dll_P.ModelParam_rotordx * fphi;
      tmp_2[5] = rtb_Gain7;
      tmp_2[8] = rtb_Gain7;
      tmp_2[11] = sin2beta;
      fphi = ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi *
                 rtb_Sum_o +
                 Lifting_wing_HIL_model_dll_P.ModelParam_propellerkM0) + rtb_jxi)
               + Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi2 *
               rtb_Sum_o * rtb_Sum_o) +
              Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpiV *
              rtb_Sum_o * Lifting_wing_HIL_model_dll_B.airspeed) + rtb_q3dot;
      rtb_Sum_o = ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi *
                      rtb_Gain1_idx_1 +
                      Lifting_wing_HIL_model_dll_P.ModelParam_propellerkM0) +
                     rtb_jxi) +
                    Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi2 *
                    rtb_Gain1_idx_1 * rtb_Gain1_idx_1) +
                   Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpiV *
                   rtb_Gain1_idx_1 * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_q3dot;
      rtb_Gain7 = ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi *
                      rtb_Gain1_idx_2 +
                      Lifting_wing_HIL_model_dll_P.ModelParam_propellerkM0) +
                     rtb_jxi) +
                    Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi2 *
                    rtb_Gain1_idx_2 * rtb_Gain1_idx_2) +
                   Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpiV *
                   rtb_Gain1_idx_2 * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_q3dot;
      VectorConcatenate_tmp =
        ((((Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi *
            VectorConcatenate_tmp +
            Lifting_wing_HIL_model_dll_P.ModelParam_propellerkM0) + rtb_jxi) +
          Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpi2 *
          VectorConcatenate_tmp * VectorConcatenate_tmp) +
         Lifting_wing_HIL_model_dll_P.ModelParam_propellerkMvarpiV *
         VectorConcatenate_tmp * Lifting_wing_HIL_model_dll_B.airspeed) +
        rtb_q3dot;
      for (i = 0; i < 3; i++) {
        rtb_Mp[i] = (((tmp_2[i + 3] * rtb_VectorConcatenate_a_idx_1 + tmp_2[i] *
                       rtb_Divide_idx_0) + tmp_2[i + 6] *
                      rtb_VectorConcatenate_a_idx_2) + tmp_2[i + 9] *
                     rtb_Lw_idx_1) + (((static_cast<real_T>(e_a[i + 3]) *
          rtb_Sum_o + static_cast<real_T>(e_a[i]) * fphi) + static_cast<real_T>
          (e_a[i + 6]) * rtb_Gain7) + static_cast<real_T>(e_a[i + 9]) *
          VectorConcatenate_tmp);
      }

      // torque
    }

    // End of MATLAB Function: '<S173>/Propeller Model'

    // Sum: '<S340>/Add'
    rtb_q3dot = (VectorConcatenate[0] + VectorConcatenate[4]) +
      VectorConcatenate[8];

    // If: '<S296>/If'
    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_p;
    if (tmp_0) {
      rtAction = static_cast<int8_T>(!(rtb_q3dot > 0.0));
      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_p = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_p;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    if (rtAction == 0) {
      // Outputs for IfAction SubSystem: '<S296>/Positive Trace' incorporates:
      //   ActionPort: '<S338>/Action Port'

      Lifting_wing_HIL__PositiveTrace(rtb_q3dot, VectorConcatenate,
        Lifting_wing_HIL_model_dll_B.Merge_p,
        &Lifting_wing_HIL_model_dll_P.PositiveTrace_k);

      // End of Outputs for SubSystem: '<S296>/Positive Trace'
    } else {
      // Outputs for IfAction SubSystem: '<S296>/Negative Trace' incorporates:
      //   ActionPort: '<S337>/Action Port'

      Lifting_wing_HIL__NegativeTrace(VectorConcatenate,
        Lifting_wing_HIL_model_dll_B.Merge_p,
        &Lifting_wing_HIL_model_dll_DW.NegativeTrace_h,
        &Lifting_wing_HIL_model_dll_P.NegativeTrace_h);

      // End of Outputs for SubSystem: '<S296>/Negative Trace'
    }

    // Sum: '<S329>/Sum' incorporates:
    //   DotProduct: '<S308>/Dot Product'
    //   Product: '<S329>/Product'
    //   Product: '<S329>/Product1'
    //   Product: '<S329>/Product2'
    //   Product: '<S329>/Product3'

    VectorConcatenate_tmp = ((rtb_q0q1q2q3_idx_0 * rtb_q0q1q2q3_idx_0 +
      rtb_q0q1q2q3_idx_1 * rtb_q0q1q2q3_idx_1) + rtb_q0q1q2q3_idx_2 *
      rtb_q0q1q2q3_idx_2) + rtb_q0q1q2q3_idx_3 * rtb_q0q1q2q3_idx_3;

    // Sqrt: '<S328>/sqrt' incorporates:
    //   Sum: '<S329>/Sum'

    rtb_Gain7 = std::sqrt(VectorConcatenate_tmp);

    // Product: '<S323>/Product'
    rtb_Sum_o = rtb_q0q1q2q3_idx_0 / rtb_Gain7;

    // Product: '<S323>/Product1'
    rtb_q3dot = rtb_q0q1q2q3_idx_1 / rtb_Gain7;

    // Product: '<S323>/Product2'
    rtb_jxi = rtb_q0q1q2q3_idx_2 / rtb_Gain7;

    // Product: '<S323>/Product3'
    rtb_Gain7 = rtb_q0q1q2q3_idx_3 / rtb_Gain7;

    // Fcn: '<S306>/fcn2' incorporates:
    //   Fcn: '<S306>/fcn5'

    rtb_VectorConcatenate_a_idx_2 = rtb_Sum_o * rtb_Sum_o;
    rtb_Gain1_idx_2 = rtb_q3dot * rtb_q3dot;
    rtb_Gain1_idx_1 = rtb_jxi * rtb_jxi;
    sin2beta = rtb_Gain7 * rtb_Gain7;

    // Trigonometry: '<S322>/Trigonometric Function1' incorporates:
    //   Concatenate: '<S322>/Vector Concatenate'
    //   Fcn: '<S306>/fcn1'
    //   Fcn: '<S306>/fcn2'

    rtb_Lw_idx_1 = rt_atan2d_snf((rtb_q3dot * rtb_jxi + rtb_Sum_o * rtb_Gain7) *
      2.0, ((rtb_VectorConcatenate_a_idx_2 + rtb_Gain1_idx_2) - rtb_Gain1_idx_1)
      - sin2beta);

    // Fcn: '<S306>/fcn3'
    fphi = (rtb_q3dot * rtb_Gain7 - rtb_Sum_o * rtb_jxi) * -2.0;

    // If: '<S324>/If'
    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_l;
    if (tmp_0) {
      if (fphi > 1.0) {
        rtAction = 0;
      } else if (fphi < -1.0) {
        rtAction = 1;
      } else {
        rtAction = 2;
      }

      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_l = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_l;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    switch (rtAction) {
     case 0:
      // Outputs for IfAction SubSystem: '<S324>/If Action Subsystem' incorporates:
      //   ActionPort: '<S325>/Action Port'

      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Merge: '<S324>/Merge' incorporates:
        //   Constant: '<S325>/Constant'

        Lifting_wing_HIL_model_dll_B.Merge_k0 =
          Lifting_wing_HIL_model_dll_P.Constant_Value_f;
      }

      // End of Outputs for SubSystem: '<S324>/If Action Subsystem'
      break;

     case 1:
      // Outputs for IfAction SubSystem: '<S324>/If Action Subsystem1' incorporates:
      //   ActionPort: '<S326>/Action Port'

      if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
          (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
        // Merge: '<S324>/Merge' incorporates:
        //   Constant: '<S326>/Constant'

        Lifting_wing_HIL_model_dll_B.Merge_k0 =
          Lifting_wing_HIL_model_dll_P.Constant_Value_l1;
      }

      // End of Outputs for SubSystem: '<S324>/If Action Subsystem1'
      break;

     default:
      // Outputs for IfAction SubSystem: '<S324>/If Action Subsystem2' incorporates:
      //   ActionPort: '<S327>/Action Port'

      // Merge: '<S324>/Merge' incorporates:
      //   SignalConversion generated from: '<S327>/In'

      Lifting_wing_HIL_model_dll_B.Merge_k0 = fphi;

      // End of Outputs for SubSystem: '<S324>/If Action Subsystem2'
      break;
    }

    // Trigonometry: '<S322>/trigFcn' incorporates:
    //   Concatenate: '<S322>/Vector Concatenate'

    if (Lifting_wing_HIL_model_dll_B.Merge_k0 > 1.0) {
      rtb_Divide_idx_0 = 1.0;
    } else if (Lifting_wing_HIL_model_dll_B.Merge_k0 < -1.0) {
      rtb_Divide_idx_0 = -1.0;
    } else {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_B.Merge_k0;
    }

    rtb_VectorConcatenate_a_idx_1 = std::asin(rtb_Divide_idx_0);

    // End of Trigonometry: '<S322>/trigFcn'

    // Trigonometry: '<S322>/Trigonometric Function3' incorporates:
    //   Concatenate: '<S322>/Vector Concatenate'
    //   Fcn: '<S306>/fcn4'
    //   Fcn: '<S306>/fcn5'

    rtb_VectorConcatenate_a_idx_2 = rt_atan2d_snf((rtb_jxi * rtb_Gain7 +
      rtb_Sum_o * rtb_q3dot) * 2.0, ((rtb_VectorConcatenate_a_idx_2 -
      rtb_Gain1_idx_2) - rtb_Gain1_idx_1) + sin2beta);

    // Gain: '<S173>/Mass' incorporates:
    //   BusCreator: '<S172>/Bus Creator'

    rtb_Sum4_h[2] *= Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
    if (tmp) {
      // MATLAB Function: '<S173>/MATLAB Function' incorporates:
      //   BusCreator: '<S172>/Bus Creator'
      //   Gain: '<S173>/Mass'
      //   GravityWGS84: '<S181>/WGS84 Gravity Model  '
      //   Integrator: '<S295>/p,q,r '
      //   Integrator: '<S295>/xe,ye,ze'
      //   Math: '<S294>/Transpose'
      //   Product: '<S304>/Product'

      // MATLAB Function 'Subsystem Reference/Forces and Moments/MATLAB Function': '<S271>:1' 
      // '<S271>:1:3' if isempty(land_yaw) || isempty(hold_yaw_flag)
      if ((!Lifting_wing_HIL_model_dll_DW.land_yaw_not_empty) ||
          (!Lifting_wing_HIL_model_dll_DW.hold_yaw_flag_not_empty)) {
        // '<S271>:1:4' land_yaw = ModelInit_AngEuler(3);
        Lifting_wing_HIL_model_dll_DW.land_yaw_not_empty = true;

        // '<S271>:1:5' hold_yaw_flag = true;
        Lifting_wing_HIL_model_dll_DW.hold_yaw_flag = true;
        Lifting_wing_HIL_model_dll_DW.hold_yaw_flag_not_empty = true;
      }

      // '<S271>:1:7' if landed && ~hold_yaw_flag
      if ((BusCreator_landed != 0) &&
          (!Lifting_wing_HIL_model_dll_DW.hold_yaw_flag)) {
        // '<S271>:1:8' land_yaw = euler(3);
        // '<S271>:1:9' hold_yaw_flag = true;
        Lifting_wing_HIL_model_dll_DW.hold_yaw_flag = true;
      }

      // 
      // '<S271>:1:13' z = Xe(3) - terrainZ;
      z = rtb_sincos_o1[2] - z;

      // '<S271>:1:14' F_ground=[0;0;0];
      // '<S271>:1:15' M_ground=[0;0;0];
      rtb_Integrator1_p[0] = 0.0;
      M_ground[0] = 0.0;
      rtb_Integrator1_p[1] = 0.0;
      M_ground[1] = 0.0;
      rtb_Integrator1_p[2] = 0.0;
      M_ground[2] = 0.0;

      // '<S271>:1:16' if landed
      if (BusCreator_landed != 0) {
        // '<S271>:1:17' if z < 0.01
        if (z < 0.01) {
          // '<S271>:1:18' F_ground(3) = -mg(3)- 1*z- 10*Ve(3);
          rtb_Integrator1_p[2] = (-rtb_Sum4_h[2] - z) - 10.0 *
            Lifting_wing_HIL_model_dll_B.Product[2];
        } else if (z < 0.04) {
          // '<S271>:1:19' elseif z<0.04
          // '<S271>:1:20' F_ground(3)=-mg(3)-0.5*z-20*Ve(3);
          rtb_Integrator1_p[2] = (-rtb_Sum4_h[2] - 0.5 * z) - 20.0 *
            Lifting_wing_HIL_model_dll_B.Product[2];
        } else {
          // '<S271>:1:21' else
          // '<S271>:1:22' F_ground(3)=-mg(3)-1.0*z-50*Ve(3);
          rtb_Integrator1_p[2] = (-rtb_Sum4_h[2] - z) - 50.0 *
            Lifting_wing_HIL_model_dll_B.Product[2];
        }

        // '<S271>:1:25' F_ground(1)=-1000*Ve(1);
        rtb_Integrator1_p[0] = -1000.0 * Lifting_wing_HIL_model_dll_B.Product[0];

        // '<S271>:1:26' F_ground(2)=-1000*Ve(2);
        rtb_Integrator1_p[1] = -1000.0 * Lifting_wing_HIL_model_dll_B.Product[1];

        // '<S271>:1:27' F_ground = F_ground(:);
        // '<S271>:1:28' M_ground=-200*[Quet(2);Quet(3);Quet(4)]-10*Wb;
        M_ground[0] = -200.0 * Lifting_wing_HIL_model_dll_B.Merge_p[1] - 10.0 *
          rtb_Product_d[0];
        M_ground[1] = -200.0 * Lifting_wing_HIL_model_dll_B.Merge_p[2] - 10.0 *
          rtb_Product_d[1];
        M_ground[2] = -200.0 * Lifting_wing_HIL_model_dll_B.Merge_p[3] - 10.0 *
          rtb_Product_d[2];

        // M_ground=-1*[euler(1);euler(2); (euler(3)-land_yaw)]-2*Wb;
      } else {
        // '<S271>:1:30' else
        // '<S271>:1:31' hold_yaw_flag = false;
        Lifting_wing_HIL_model_dll_DW.hold_yaw_flag = false;
      }

      // '<S271>:1:34' F_env = DCM'*(mg + F_ground);
      rtb_q3dot = Lifting_wing_HIL_model_dll_P.ModelParam_uavMass * 0.0 +
        rtb_Integrator1_p[0];
      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.ModelParam_uavMass * 0.0 +
        rtb_Integrator1_p[1];
      fphi = rtb_Sum4_h[2] + rtb_Integrator1_p[2];

      // '<S271>:1:35' M_env = M_ground;
      for (i = 0; i < 3; i++) {
        Lifting_wing_HIL_model_dll_B.F_env[i] = (Product_tmp[3 * i + 1] *
          rtb_Gain7 + Product_tmp[3 * i] * rtb_q3dot) + Product_tmp[3 * i + 2] *
          fphi;
        Lifting_wing_HIL_model_dll_B.M_env[i] = M_ground[i];
      }

      // End of MATLAB Function: '<S173>/MATLAB Function'

      // DiscreteIntegrator: '<S282>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_kn =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_f;

      // DigitalClock: '<S284>/Digital Clock' incorporates:
      //   DigitalClock: '<S285>/Digital Clock'

      rtb_q3dot = (((&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1) * 0.001);

      // DigitalClock: '<S284>/Digital Clock'
      rtb_DigitalClock = rtb_q3dot;

      // MATLAB Function: '<S284>/MATLAB Function' incorporates:
      //   Constant: '<S284>/Constant'
      //   Sum: '<S284>/Add'
      //   UnitDelay: '<S284>/Unit Delay'

      Lifting_wing_HIL_MATLABFunction
        (Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_kn,
         rtb_DigitalClock - Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE,
         Lifting_wing_HIL_model_dll_P.ModelParam_DeltaRatemax,
         &Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_g,
         &Lifting_wing_HIL_model_dll_DW.sf_MATLABFunction_g);

      // DiscreteIntegrator: '<S283>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_c =
        Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_j;

      // DigitalClock: '<S285>/Digital Clock'
      rtb_DigitalClock_e = rtb_q3dot;

      // MATLAB Function: '<S285>/MATLAB Function' incorporates:
      //   Constant: '<S285>/Constant'
      //   Sum: '<S285>/Add'
      //   UnitDelay: '<S285>/Unit Delay'

      Lifting_wing_HIL_MATLABFunction
        (Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_c,
         rtb_DigitalClock_e - Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE_h,
         Lifting_wing_HIL_model_dll_P.ModelParam_DeltaRatemax,
         &Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_i,
         &Lifting_wing_HIL_model_dll_DW.sf_MATLABFunction_i);

      // Sum: '<S174>/Sum'
      Lifting_wing_HIL_model_dll_B.delta_e =
        Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_g.Aa +
        Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_i.Aa;

      // Sum: '<S174>/Sum1'
      Lifting_wing_HIL_model_dll_B.delta_a =
        Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_i.Aa -
        Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_g.Aa;
    }

    // SignalConversion generated from: '<S176>/ SFunction ' incorporates:
    //   MATLAB Function: '<S170>/aerodynamic coefficients'

    rtb_Integrator1_p[0] = rtb_Lw_idx_0;

    // MATLAB Function: '<S170>/aerodynamic coefficients' incorporates:
    //   Integrator: '<S295>/p,q,r '
    //   MATLAB Function: '<S173>/Aerodynamics and torque'
    //   SignalConversion generated from: '<S176>/ SFunction '

    // MATLAB Function 'Subsystem Reference/Aerodynamic Coefficients/aerodynamic coefficients': '<S176>:1' 
    // '<S176>:1:6' alpha = incid(1);
    // '<S176>:1:7' beta = incid(2);
    // '<S176>:1:8' Va = incid(3);
    z = Merge;

    // '<S176>:1:10' if isnan(beta)
    if (std::isnan(alt)) {
      // '<S176>:1:11' beta = 0;
      alt = 0.0;
    }

    //      maxBeta = 30 * pi / 180;
    //      if beta > maxBeta
    //          beta = maxBeta;
    //      elseif beta < -maxBeta
    //          beta = -maxBeta;
    //      end
    // '<S176>:1:19' if Va < 1
    if (Merge < 1.0) {
      // '<S176>:1:20' Va = 1;
      z = 1.0;
    }

    // '<S176>:1:22' kk = LW_ANGLE*pi/180;
    rtb_q3dot_tmp = Lifting_wing_HIL_model_dll_P.LW_ANGLE * 3.1415926535897931 /
      180.0;

    // '<S176>:1:23' Rlb = [cos(kk), 0, -sin(kk);
    // '<S176>:1:24'         0, 1, 0;
    // '<S176>:1:25'         sin(kk), 0, cos(kk)];
    // '<S176>:1:26' delta_a = delta(2);
    // '<S176>:1:27' delta_e = delta(1);
    // '<S176>:1:28' wl = Rlb * wb;
    rtb_jxi = std::sin(rtb_q3dot_tmp);
    rtb_q3dot = std::cos(rtb_q3dot_tmp);
    Comega[0] = rtb_q3dot;
    Comega[3] = 0.0;
    Comega[6] = -rtb_jxi;
    Comega[1] = 0.0;
    Comega[4] = 1.0;
    Comega[7] = 0.0;
    Comega[2] = rtb_jxi;
    Comega[5] = 0.0;
    Comega[8] = rtb_q3dot;
    rtb_jxi = rtb_Product_d[1];
    rtb_Divide_idx_0 = rtb_Product_d[0];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (i = 0; i < 3; i++) {
      rtb_Sum4_h[i] = (Comega[i + 3] * rtb_jxi + Comega[i] * rtb_Divide_idx_0) +
        Comega[i + 6] * rtb_Gain1_idx_2;
    }

    // '<S176>:1:30' C_Y = ModelParam_LBCY0 + ModelParam_LBCYB * beta;
    // '<S176>:1:31' C_l = ModelParam_LBCl0 + ModelParam_LBClB * beta + ModelParam_LBClp * ModelParam_LBb / (2 * Va) * wl(1) + ModelParam_LBCl_d * delta_a; 
    // '<S176>:1:32' C_n = ModelParam_LBCn0 + ModelParam_LBCnB * beta + ModelParam_LBCnr * ModelParam_LBb / (2 * Va) * wl(3) + ModelParam_LBCn_d * delta_a; 
    // %% 
    // '<S176>:1:35' alpha0 = ModelParam_pu_alpha0;
    // 
    // '<S176>:1:36' c0 = ModelParam_pu_c0;
    //  
    // '<S176>:1:37' c1 = ModelParam_pu_c1;
    // 
    // '<S176>:1:38' CL0 = ModelParam_pu_cl0;
    //  0
    // '<S176>:1:39' Cla = ModelParam_pu_c2;
    // 
    // '<S176>:1:40' c3 = ModelParam_pu_c3;
    //  
    // '<S176>:1:41' kL = ModelParam_pu_kL;
    // '<S176>:1:42' kD = ModelParam_pu_kD;
    // 
    // '<S176>:1:43' CL_l = c1*sin(alpha)*cos(alpha);
    // '<S176>:1:44' CD_l = c0 + c1*sin(alpha).^2;
    rtb_jxi = std::sin(rtb_Lw_idx_0);

    // '<S176>:1:46' CL_s = CL0+Cla.*sin(alpha)*cos(alpha);
    // '<S176>:1:47' CD_s = c0+c3*sin(alpha).^2;
    // '<S176>:1:48' sigmaL = (1+tanh(kL*alpha0^2-kL*alpha.^2))./(1+tanh(kL*alpha0^2)); 
    rtb_q3dot = rtb_Lw_idx_0 * rtb_Lw_idx_0;
    fphi = Lifting_wing_HIL_model_dll_P.ModelParam_pu_alpha0 *
      Lifting_wing_HIL_model_dll_P.ModelParam_pu_alpha0;
    rtb_Sum_ag_tmp = fphi * Lifting_wing_HIL_model_dll_P.ModelParam_pu_kL;
    rtb_Sum_o = (std::tanh(rtb_Sum_ag_tmp - rtb_q3dot *
      Lifting_wing_HIL_model_dll_P.ModelParam_pu_kL) + 1.0) / (std::tanh
      (rtb_Sum_ag_tmp) + 1.0);

    // '<S176>:1:49' sigmaD = (1+tanh(kD*alpha0^2-kD*alpha.^2))./(1+tanh(kD*alpha0^2)); 
    rtb_Sum_ag_tmp = fphi * Lifting_wing_HIL_model_dll_P.ModelParam_pu_kD;
    rtb_q3dot = (std::tanh(rtb_Sum_ag_tmp - rtb_q3dot *
      Lifting_wing_HIL_model_dll_P.ModelParam_pu_kD) + 1.0) / (std::tanh
      (rtb_Sum_ag_tmp) + 1.0);

    // '<S176>:1:51' if AERO_COEFFICIENT == int8(1)
    switch (Lifting_wing_HIL_model_dll_P.AERO_COEFFICIENT) {
     case 1:
      // post-stall
      // '<S176>:1:52' C_L = CL_l;
      rtb_Sum_o = Lifting_wing_HIL_model_dll_P.ModelParam_pu_c1 * rtb_jxi * std::
        cos(rtb_Lw_idx_0);

      // '<S176>:1:53' C_D = CD_l;
      rtb_Gain7 = rtb_jxi * rtb_jxi *
        Lifting_wing_HIL_model_dll_P.ModelParam_pu_c1 +
        Lifting_wing_HIL_model_dll_P.ModelParam_pu_c0;
      break;

     case 2:
      // '<S176>:1:54' elseif AERO_COEFFICIENT == int8(2)
      // pre-stall
      // '<S176>:1:55' C_L = CL_s;
      rtb_Sum_o = Lifting_wing_HIL_model_dll_P.ModelParam_pu_c2 * rtb_jxi * std::
        cos(rtb_Lw_idx_0) + Lifting_wing_HIL_model_dll_P.ModelParam_pu_cl0;

      // '<S176>:1:56' C_D = CD_s;
      rtb_Gain7 = rtb_jxi * rtb_jxi *
        Lifting_wing_HIL_model_dll_P.ModelParam_pu_c3 +
        Lifting_wing_HIL_model_dll_P.ModelParam_pu_c0;
      break;

     default:
      // '<S176>:1:57' else
      // mix
      // '<S176>:1:58' C_L = (1-sigmaL).*CL_l + sigmaL.*CL_s;
      rtb_Gain7 = std::cos(rtb_Lw_idx_0);
      rtb_Sum_o = (Lifting_wing_HIL_model_dll_P.ModelParam_pu_c2 * rtb_jxi *
                   rtb_Gain7 + Lifting_wing_HIL_model_dll_P.ModelParam_pu_cl0) *
        rtb_Sum_o + Lifting_wing_HIL_model_dll_P.ModelParam_pu_c1 * rtb_jxi *
        rtb_Gain7 * (1.0 - rtb_Sum_o);

      // '<S176>:1:59' C_D = (1-sigmaD).*CD_l+ sigmaD.*CD_s;
      rtb_Gain7 = rtb_jxi * rtb_jxi;
      rtb_Gain7 = (rtb_Gain7 * Lifting_wing_HIL_model_dll_P.ModelParam_pu_c1 +
                   Lifting_wing_HIL_model_dll_P.ModelParam_pu_c0) * (1.0 -
        rtb_q3dot) + (rtb_Gain7 * Lifting_wing_HIL_model_dll_P.ModelParam_pu_c3
                      + Lifting_wing_HIL_model_dll_P.ModelParam_pu_c0) *
        rtb_q3dot;
      break;
    }

    // MATLAB Function: '<S173>/Aerodynamics and torque' incorporates:
    //   Integrator: '<S295>/p,q,r '
    //   Integrator: '<S295>/ub,vb,wb'
    //   MATLAB Function: '<S170>/aerodynamic coefficients'
    //   SignalConversion generated from: '<S176>/ SFunction '

    // '<S176>:1:62' pp = mkpp(ModelParam_pu_breaks,ModelParam_pu_coefs);
    // '<S176>:1:63' C_m = ppval(pp, alpha) + ModelParam_LBCmq * ModelParam_LBc / (2 * Va) * wl(2) + ModelParam_LBCm_d * delta_e; 
    // '<S176>:1:64' C_m0 = ppval(pp, alpha) + ModelParam_LBCmq * ModelParam_LBc / (2 * Va) * wl(2); 
    // '<S176>:1:65' C_me = ModelParam_LBCm_d * delta_e;
    // C_m = 0;
    rtb_q3dot = q;

    // Function description;
    //  S: 
    //  c: 
    //  b: 
    //  C_L, C_D, C_m, C_Y, C_l, C_n: 
    //  qbar: 0.5*rho*Va^2 ,rho:  Va: 
    //  incid: 
    //  kappa: 
    // MATLAB Function 'Subsystem Reference/Forces and Moments/Aerodynamics and torque': '<S270>:1' 
    // 
    // '<S270>:1:13' if ~USE_AeroCoefficient
    if (!Lifting_wing_HIL_model_dll_P.USE_AeroCoefficient) {
      // '<S270>:1:14' qbar = 0;
      rtb_q3dot = 0.0;
    }

    // '<S270>:1:17' S = ModelParam_LBS;
    // '<S270>:1:18' c = ModelParam_LBc;
    // '<S270>:1:19' b = ModelParam_LBb;
    // '<S270>:1:20' rho = ModelParam_LBRho;
    // '<S270>:1:21' kappa  = LW_ANGLE*pi/180;
    // '<S270>:1:22' C_d = ModelParam_uavCd;
    // '<S270>:1:23' C_md = ModelParam_uavCCm;
    // '<S270>:1:25' F_lift = qbar*S*C_L;
    rtb_Sum_ag_tmp = rtb_q3dot * Lifting_wing_HIL_model_dll_P.ModelParam_LBS;
    rtb_Sum_o *= rtb_Sum_ag_tmp;

    // '<S270>:1:26' F_drag = qbar*S*C_D;
    rtb_Gain7 *= rtb_Sum_ag_tmp;

    // '<S270>:1:27' m = qbar*S*c*C_m;
    // 
    // '<S270>:1:29' lambda = alpha - kappa;
    fphi = rtb_Lw_idx_0 - rtb_q3dot_tmp;

    // '<S270>:1:30' f_x = cos(lambda)*(-F_drag) - sin(lambda)*(-F_lift);
    // '<S270>:1:31' f_z = sin(lambda)*(-F_drag) + cos(lambda)*(- F_lift);
    // 
    // '<S270>:1:33' f_y = qbar*S*C_Y;
    // '<S270>:1:34' l_s = qbar*S*b*C_l;
    rtb_jxi = rtb_Sum_ag_tmp * Lifting_wing_HIL_model_dll_P.ModelParam_LBb;
    rtb_Lw_idx_0 = ((Lifting_wing_HIL_model_dll_P.ModelParam_LBClp *
                     Lifting_wing_HIL_model_dll_P.ModelParam_LBb / (2.0 * z) *
                     rtb_Sum4_h[0] +
                     (Lifting_wing_HIL_model_dll_P.ModelParam_LBClB * alt +
                      Lifting_wing_HIL_model_dll_P.ModelParam_LBCl0)) +
                    Lifting_wing_HIL_model_dll_P.ModelParam_LBCl_d *
                    Lifting_wing_HIL_model_dll_B.delta_a) * rtb_jxi;

    // '<S270>:1:35' n_s = qbar*S*b*C_n;
    rtb_Gain1_idx_1 = ((Lifting_wing_HIL_model_dll_P.ModelParam_LBCnr *
                        Lifting_wing_HIL_model_dll_P.ModelParam_LBb / (2.0 * z) *
                        rtb_Sum4_h[2] +
                        (Lifting_wing_HIL_model_dll_P.ModelParam_LBCnB * alt +
                         Lifting_wing_HIL_model_dll_P.ModelParam_LBCn0)) +
                       Lifting_wing_HIL_model_dll_P.ModelParam_LBCn_d *
                       Lifting_wing_HIL_model_dll_B.delta_a) * rtb_jxi;

    // '<S270>:1:36' l = cos(kappa)*l_s + sin(kappa)*n_s;
    // '<S270>:1:37' n = -sin(kappa)*l_s + cos(kappa)*n_s;
    // -theory
    // '<S270>:1:41' u = 1;
    // '<S270>:1:42' Cd0 = 0.26;
    // '<S270>:1:43' Cy0 = 0.0;
    // '<S270>:1:44' delta_r = 0;
    // '<S270>:1:45' Comega = [b 0 0; 0 c 0; 0 0 b];
    Comega[0] = Lifting_wing_HIL_model_dll_P.ModelParam_LBb;
    Comega[3] = 0.0;
    Comega[6] = 0.0;
    Comega[1] = 0.0;
    Comega[4] = Lifting_wing_HIL_model_dll_P.ModelParam_LBc;
    Comega[7] = 0.0;
    Comega[2] = 0.0;
    Comega[5] = 0.0;
    Comega[8] = Lifting_wing_HIL_model_dll_P.ModelParam_LBb;

    // '<S270>:1:47' R_lb = [cos(kappa), 0 , -sin(kappa);
    // '<S270>:1:48'     0,     1 ,    0;
    // '<S270>:1:49'     sin(kappa), 0 ,  cos(kappa)];
    sin2beta = std::sin(rtb_q3dot_tmp);
    rtb_q3dot = std::cos(rtb_q3dot_tmp);
    R_lb[0] = rtb_q3dot;
    R_lb[3] = 0.0;
    R_lb[6] = -sin2beta;
    R_lb[1] = 0.0;
    R_lb[4] = 1.0;
    R_lb[7] = 0.0;
    R_lb[2] = sin2beta;
    R_lb[5] = 0.0;
    R_lb[8] = rtb_q3dot;

    // '<S270>:1:50' wl = R_lb*wb;
    // '<S270>:1:51' vl = R_lb*vb;
    // '<S270>:1:52' Va_norm = sqrt(va_l'*va_l);
    rtb_q3dot_tmp = 0.0;

    // '<S270>:1:53' eta = sqrt(Va_norm^2 + u*c*(wl'*wl));
    // '<S270>:1:54' AR = b^2/S;
    AR = Lifting_wing_HIL_model_dll_P.ModelParam_LBb *
      Lifting_wing_HIL_model_dll_P.ModelParam_LBb /
      Lifting_wing_HIL_model_dll_P.ModelParam_LBS;

    // '<S270>:1:55' phi_fv = [Cd0 0 0; 0 Cy0 0 ; 0 0 0.5*pi*AR/(1+sqrt(1+(AR/2)^2))+Cd0]; 
    // '<S270>:1:56' phi_fw = [0 0 0;0 0 1/b*delta_r*Cy0;0 -1/c*delta_r*(pi*AR/(1+sqrt(1+(AR/2)^2)) + Cd0) 0]; 
    // '<S270>:1:57' phi_mv = [0 0 0; 0 0 -1/c*delta_r*(pi*AR/(1+sqrt(1+(AR/2)^2)) + Cd0);0 1/b*delta_r*Cy0 0]; 
    f_a = AR / 2.0;

    // '<S270>:1:58' phi_mw = 0.5*[ModelParam_LBClp 0 0; 0 ModelParam_LBCmq 0;0 0 ModelParam_LBCnr]; 
    // '<S270>:1:59' Fa_l = -0.5*rho*S*eta*(phi_fv*vl + phi_fw*Comega*wl);
    // '<S270>:1:60' Ma_l = -0.5*rho*S*eta*(Comega*phi_mv*vl + Comega*phi_mw*Comega*wl); 
    M_ground_0 = 0.0;
    rtb_jxi = rtb_Product_d[1];
    rtb_Divide_idx_0 = rtb_Product_d[0];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (i = 0; i < 3; i++) {
      M_ground_1 = (R_lb[i + 3] * rtb_jxi + R_lb[i] * rtb_Divide_idx_0) + R_lb[i
        + 6] * rtb_Gain1_idx_2;
      M_ground[i] = M_ground_1;
      rtb_IntegratorSecondOrderLimi_a = rtb_IntegratorSecondOrderLimi_p[i];
      rtb_q3dot_tmp += rtb_IntegratorSecondOrderLimi_a *
        rtb_IntegratorSecondOrderLimi_a;
      M_ground_0 += M_ground_1 * M_ground_1;
    }

    rtb_jxi = std::sqrt(rtb_q3dot_tmp);
    rtb_jxi = -0.5 * Lifting_wing_HIL_model_dll_P.ModelParam_LBRho *
      Lifting_wing_HIL_model_dll_P.ModelParam_LBS * std::sqrt(rtb_jxi * rtb_jxi
      + Lifting_wing_HIL_model_dll_P.ModelParam_LBc * M_ground_0);
    tmp_3[0] = 0.0;
    tmp_3[3] = 0.0;
    tmp_3[6] = 0.0;
    tmp_3[1] = 0.0;
    tmp_3[4] = 0.0;
    tmp_3[7] = (3.1415926535897931 * AR / (std::sqrt(f_a * f_a + 1.0) + 1.0) +
                0.26) * (-1.0 / Lifting_wing_HIL_model_dll_P.ModelParam_LBc *
                         0.0);
    tmp_3[2] = 0.0;
    tmp_3[5] = 1.0 / Lifting_wing_HIL_model_dll_P.ModelParam_LBb * 0.0 * 0.0;
    tmp_3[8] = 0.0;
    tmp_4[0] = 0.5 * Lifting_wing_HIL_model_dll_P.ModelParam_LBClp;
    tmp_4[3] = 0.0;
    tmp_4[6] = 0.0;
    tmp_4[1] = 0.0;
    tmp_4[4] = 0.5 * Lifting_wing_HIL_model_dll_P.ModelParam_LBCmq;
    tmp_4[7] = 0.0;
    tmp_4[2] = 0.0;
    tmp_4[5] = 0.0;
    tmp_4[8] = 0.5 * Lifting_wing_HIL_model_dll_P.ModelParam_LBCnr;
    for (i = 0; i < 3; i++) {
      rtb_Divide_idx_0 = 0.0;
      rtb_Gain1_idx_2 = Comega[i];
      rtb_IntegratorSecondOrderLimi_a = Comega[i + 3];
      rtb_q3dot_tmp = Comega[i + 6];
      for (rtb_lon = 0; rtb_lon < 3; rtb_lon++) {
        rtb_lat = 3 * rtb_lon + i;
        rtb_Divide_idx_0 += R_lb[rtb_lat] *
          rtb_TmpSignalConversionAtSFunct[rtb_lon];
        Comega_tmp = 3 * rtb_lon + 1;
        Comega_tmp_0 = 3 * rtb_lon + 2;
        Comega_1[rtb_lat] = (tmp_4[3 * rtb_lon] * rtb_Gain1_idx_2 +
                             tmp_4[Comega_tmp] * rtb_IntegratorSecondOrderLimi_a)
          + tmp_4[Comega_tmp_0] * rtb_q3dot_tmp;
        Comega_0[rtb_lat] = (tmp_3[3 * rtb_lon] * rtb_Gain1_idx_2 +
                             tmp_3[Comega_tmp] * rtb_IntegratorSecondOrderLimi_a)
          + tmp_3[Comega_tmp_0] * rtb_q3dot_tmp;
      }

      R_lb_0[i] = rtb_Divide_idx_0;
      rtb_Gain1_idx_2 = Comega_1[i + 3];
      rtb_IntegratorSecondOrderLimi_a = Comega_1[i];
      rtb_q3dot_tmp = Comega_1[i + 6];
      for (rtb_lon = 0; rtb_lon < 3; rtb_lon++) {
        Comega_2[i + 3 * rtb_lon] = (Comega[3 * rtb_lon + 1] * rtb_Gain1_idx_2 +
          Comega[3 * rtb_lon] * rtb_IntegratorSecondOrderLimi_a) + Comega[3 *
          rtb_lon + 2] * rtb_q3dot_tmp;
      }
    }

    rtb_Divide_idx_0 = R_lb_0[1];
    rtb_Gain1_idx_2 = R_lb_0[0];
    rtb_IntegratorSecondOrderLimi_a = R_lb_0[2];
    M_ground_0 = M_ground[1];
    M_ground_1 = M_ground[0];
    rtb_q3dot_tmp = M_ground[2];
    for (i = 0; i < 3; i++) {
      R_lb_0[i] = (((Comega_0[i + 3] * rtb_Divide_idx_0 + Comega_0[i] *
                     rtb_Gain1_idx_2) + Comega_0[i + 6] *
                    rtb_IntegratorSecondOrderLimi_a) + ((Comega_2[i + 3] *
        M_ground_0 + Comega_2[i] * M_ground_1) + Comega_2[i + 6] * rtb_q3dot_tmp))
        * rtb_jxi;
    }

    // '<S270>:1:62' if ~USE_AeroCoefficient
    if (!Lifting_wing_HIL_model_dll_P.USE_AeroCoefficient) {
      // 
      // '<S270>:1:64' Fa= -C_d .* va_l.*abs(va_l);
      //  
      // '<S270>:1:67' Ma = -C_md.* wb.*abs(wb);
      rtb_Fa[0] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCd[0] *
        rtb_IntegratorSecondOrderLimi_p[0] * std::abs
        (rtb_IntegratorSecondOrderLimi_p[0]);
      rtb_Ma[0] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCCm[0] *
        rtb_Product_d[0] * std::abs(rtb_Product_d[0]);
      rtb_Fa[1] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCd[1] *
        rtb_IntegratorSecondOrderLimi_p[1] * std::abs
        (rtb_IntegratorSecondOrderLimi_p[1]);
      rtb_Ma[1] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCCm[1] *
        rtb_Product_d[1] * std::abs(rtb_Product_d[1]);
      rtb_Fa[2] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCd[2] *
        rtb_IntegratorSecondOrderLimi_p[2] * std::abs
        (rtb_IntegratorSecondOrderLimi_p[2]);
      rtb_Ma[2] = -Lifting_wing_HIL_model_dll_P.ModelParam_uavCCm[2] *
        rtb_Product_d[2] * std::abs(rtb_Product_d[2]);
    } else {
      // '<S270>:1:68' else
      // '<S270>:1:69' Fa = [f_x, f_y, f_z]';
      rtb_jxi = std::sin(fphi);
      fphi = std::cos(fphi);
      rtb_Fa[0] = fphi * -rtb_Gain7 - rtb_jxi * -rtb_Sum_o;
      rtb_Fa[1] = (Lifting_wing_HIL_model_dll_P.ModelParam_LBCYB * alt +
                   Lifting_wing_HIL_model_dll_P.ModelParam_LBCY0) *
        rtb_Sum_ag_tmp;
      rtb_Fa[2] = rtb_jxi * -rtb_Gain7 + fphi * -rtb_Sum_o;

      // '<S270>:1:70' Ma = [l, m, n]' - R_lb'*Ma_l;
      M_ground[0] = rtb_q3dot * rtb_Lw_idx_0 + sin2beta * rtb_Gain1_idx_1;
      M_ground[1] = ((Lifting_wing_HIL_model_dll_P.ModelParam_LBCmq *
                      Lifting_wing_HIL_model_dll_P.ModelParam_LBc / (2.0 * z) *
                      rtb_Sum4_h[1] + Lifting_wing_HIL_model_dl_ppval
                      (Lifting_wing_HIL_model_dll_P.ModelParam_pu_breaks,
                       Lifting_wing_HIL_model_dll_P.ModelParam_pu_coefs,
                       rtb_Integrator1_p[0])) +
                     Lifting_wing_HIL_model_dll_P.ModelParam_LBCm_d *
                     Lifting_wing_HIL_model_dll_B.delta_e) * (rtb_Sum_ag_tmp *
        Lifting_wing_HIL_model_dll_P.ModelParam_LBc);
      M_ground[2] = -sin2beta * rtb_Lw_idx_0 + rtb_q3dot * rtb_Gain1_idx_1;
      alt = R_lb_0[1];
      rtb_q3dot = R_lb_0[0];
      rtb_Lw_idx_0 = R_lb_0[2];
      for (i = 0; i < 3; i++) {
        rtb_Ma[i] = M_ground[i] - ((R_lb[3 * i + 1] * alt + R_lb[3 * i] *
          rtb_q3dot) + R_lb[3 * i + 2] * rtb_Lw_idx_0);
      }
    }

    // Product: '<S295>/Product' incorporates:
    //   Constant: '<S299>/Constant'
    //   MATLAB Function: '<Root>/MATLAB Function1'
    //   Sum: '<S173>/Add7'
    //   TransferFcn: '<S272>/Transfer Fcn'
    //   TransferFcn: '<S272>/Transfer Fcn1'
    //   TransferFcn: '<S272>/Transfer Fcn2'

    rtb_Sum4_h[0] = ((((rtb_Fp[0] + Lifting_wing_HIL_model_dll_B.F_env[0]) +
                       rtb_Fa[0]) + x) +
                     Lifting_wing_HIL_model_dll_P.TransferFcn_C *
                     Lifting_wing_HIL_model_dll_X.TransferFcn_CSTATE) /
      Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
    rtb_Sum4_h[1] = (((rtb_Fp[1] + Lifting_wing_HIL_model_dll_B.F_env[1]) +
                      rtb_Fa[1]) + Lifting_wing_HIL_model_dll_P.TransferFcn1_C *
                     Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE) /
      Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
    rtb_Sum4_h[2] = (((rtb_Fp[2] + Lifting_wing_HIL_model_dll_B.F_env[2]) +
                      rtb_Fa[2]) + Lifting_wing_HIL_model_dll_P.TransferFcn2_C *
                     Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE) /
      Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
    for (i = 0; i < 3; i++) {
      // Math: '<S7>/Transpose' incorporates:
      //   Math: '<Root>/Transpose'
      //   Math: '<S294>/Transpose'

      Comega[3 * i] = Product_tmp[i];
      Comega[3 * i + 1] = Product_tmp[i + 3];
      Comega[3 * i + 2] = Product_tmp[i + 6];
    }

    // Product: '<S89>/MatrixMultiply' incorporates:
    //   Math: '<S7>/Transpose'

    for (i = 0; i < 3; i++) {
      rtb_Fa[i] = (Comega[i + 3] * 0.0 + Comega[i] * 0.0) + Comega[i + 6] *
        rtb_Saturation_c[2];
    }

    // End of Product: '<S89>/MatrixMultiply'

    // Gain: '<S94>/Zero-Order Hold'
    rtb_Saturation_c[0] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain *
      rtb_Product_d[0];
    rtb_Saturation_c[1] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain *
      rtb_Product_d[1];
    rtb_Saturation_c[2] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain *
      rtb_Product_d[2];
    if (tmp) {
      // Gain: '<S94>/Gain' incorporates:
      //   Constant: '<S89>/CG_Acc0'
      //   Constant: '<S94>/wl_ins'
      //   Gain: '<S94>/Zero-Order Hold4'
      //   Sum: '<S94>/Sum7'

      Lifting_wing_HIL_model_dll_B.Gain[0] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain *
         Lifting_wing_HIL_model_dll_P.CG_Acc0_Value[0] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_acc[0]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_be[0];
      Lifting_wing_HIL_model_dll_B.Gain[1] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain *
         Lifting_wing_HIL_model_dll_P.CG_Acc0_Value[1] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_acc[1]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_be[1];
      Lifting_wing_HIL_model_dll_B.Gain[2] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain *
         Lifting_wing_HIL_model_dll_P.CG_Acc0_Value[2] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_acc[2]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_be[2];
      for (i = 0; i < 3; i++) {
        // Concatenate: '<S299>/Vector Concatenate' incorporates:
        //   Constant: '<S299>/Constant1'
        //   Constant: '<S299>/Constant2'

        rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.ModelParam_uavJ[3 * i];
        rtb_VectorConcatenate[6 * i] = rtb_Lw_idx_0;
        z = Lifting_wing_HIL_model_dll_P.Constant2_Value_mh[3 * i];
        rtb_VectorConcatenate[6 * i + 3] = z;

        // Selector: '<S298>/Selector1'
        Lifting_wing_HIL_model_dll_B.Selector1[3 * i] = z;

        // Selector: '<S298>/Selector'
        Lifting_wing_HIL_model_dll_B.Selector[3 * i] = rtb_Lw_idx_0;

        // Concatenate: '<S299>/Vector Concatenate' incorporates:
        //   Constant: '<S299>/Constant1'
        //   Constant: '<S299>/Constant2'
        //   Selector: '<S298>/Selector'
        //   Selector: '<S298>/Selector1'

        rtb_lon = 3 * i + 1;
        rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.ModelParam_uavJ[rtb_lon];
        rtb_VectorConcatenate[6 * i + 1] = rtb_Lw_idx_0;
        z = Lifting_wing_HIL_model_dll_P.Constant2_Value_mh[rtb_lon];
        rtb_VectorConcatenate[6 * i + 4] = z;

        // Selector: '<S298>/Selector1'
        Lifting_wing_HIL_model_dll_B.Selector1[rtb_lon] = z;

        // Selector: '<S298>/Selector'
        Lifting_wing_HIL_model_dll_B.Selector[rtb_lon] = rtb_Lw_idx_0;

        // Concatenate: '<S299>/Vector Concatenate' incorporates:
        //   Constant: '<S299>/Constant1'
        //   Constant: '<S299>/Constant2'
        //   Selector: '<S298>/Selector'
        //   Selector: '<S298>/Selector1'

        rtb_lon = 3 * i + 2;
        rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.ModelParam_uavJ[rtb_lon];
        rtb_VectorConcatenate[6 * i + 2] = rtb_Lw_idx_0;
        z = Lifting_wing_HIL_model_dll_P.Constant2_Value_mh[rtb_lon];
        rtb_VectorConcatenate[6 * i + 5] = z;

        // Selector: '<S298>/Selector1'
        Lifting_wing_HIL_model_dll_B.Selector1[rtb_lon] = z;

        // Selector: '<S298>/Selector'
        Lifting_wing_HIL_model_dll_B.Selector[rtb_lon] = rtb_Lw_idx_0;
      }
    }

    // Sum: '<S102>/Sum' incorporates:
    //   Product: '<S105>/i x j'
    //   Product: '<S105>/j x k'
    //   Product: '<S105>/k x i'
    //   Product: '<S106>/i x k'
    //   Product: '<S106>/j x i'
    //   Product: '<S106>/k x j'

    rtb_IntegratorSecondOrderLimi_p[0] = rtb_Saturation_c[1] *
      Lifting_wing_HIL_model_dll_B.Gain[2] - Lifting_wing_HIL_model_dll_B.Gain[1]
      * rtb_Saturation_c[2];
    rtb_IntegratorSecondOrderLimi_p[1] = Lifting_wing_HIL_model_dll_B.Gain[0] *
      rtb_Saturation_c[2] - rtb_Saturation_c[0] *
      Lifting_wing_HIL_model_dll_B.Gain[2];
    rtb_IntegratorSecondOrderLimi_p[2] = rtb_Saturation_c[0] *
      Lifting_wing_HIL_model_dll_B.Gain[1] - Lifting_wing_HIL_model_dll_B.Gain[0]
      * rtb_Saturation_c[1];

    // Product: '<S103>/j x k'
    fphi = rtb_Saturation_c[1] * rtb_IntegratorSecondOrderLimi_p[2];

    // Product: '<S103>/k x i'
    rtb_q3dot = rtb_IntegratorSecondOrderLimi_p[0] * rtb_Saturation_c[2];

    // Product: '<S103>/i x j'
    rtb_Gain7 = rtb_Saturation_c[0] * rtb_IntegratorSecondOrderLimi_p[1];

    // Product: '<S104>/k x j'
    rtb_q3dot_tmp = rtb_IntegratorSecondOrderLimi_p[1];

    // Product: '<S104>/i x k'
    rtb_IntegratorSecondOrderLimi_a = rtb_IntegratorSecondOrderLimi_p[2];

    // Product: '<S104>/j x i'
    alt = rtb_IntegratorSecondOrderLimi_p[0];

    // Product: '<S331>/Product' incorporates:
    //   Integrator: '<S295>/p,q,r '

    rtb_jxi = rtb_Product_d[1];
    rtb_Divide_idx_0 = rtb_Product_d[0];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (i = 0; i < 3; i++) {
      // SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' incorporates:
      //   Selector: '<S298>/Selector'

      rtb_Fp[i] = (Lifting_wing_HIL_model_dll_B.Selector[i + 3] * rtb_jxi +
                   Lifting_wing_HIL_model_dll_B.Selector[i] * rtb_Divide_idx_0)
        + Lifting_wing_HIL_model_dll_B.Selector[i + 6] * rtb_Gain1_idx_2;
    }

    // End of Product: '<S331>/Product'
    if (tmp) {
      for (i = 0; i < 3; i++) {
        // Selector: '<S298>/Selector2' incorporates:
        //   Concatenate: '<S299>/Vector Concatenate'

        Lifting_wing_HIL_model_dll_B.Selector2[3 * i] = rtb_VectorConcatenate[6 *
          i];
        Lifting_wing_HIL_model_dll_B.Selector2[3 * i + 1] =
          rtb_VectorConcatenate[6 * i + 1];
        Lifting_wing_HIL_model_dll_B.Selector2[3 * i + 2] =
          rtb_VectorConcatenate[6 * i + 2];
      }
    }

    // Sum: '<S173>/Add1' incorporates:
    //   TransferFcn: '<S273>/Transfer Fcn3'
    //   TransferFcn: '<S273>/Transfer Fcn4'
    //   TransferFcn: '<S273>/Transfer Fcn5'

    rtb_IntegratorSecondOrderLimi_p[0] =
      Lifting_wing_HIL_model_dll_P.TransferFcn3_C *
      Lifting_wing_HIL_model_dll_X.TransferFcn3_CSTATE;
    rtb_IntegratorSecondOrderLimi_p[1] =
      Lifting_wing_HIL_model_dll_P.TransferFcn4_C *
      Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE;
    rtb_IntegratorSecondOrderLimi_p[2] =
      Lifting_wing_HIL_model_dll_P.TransferFcn5_C *
      Lifting_wing_HIL_model_dll_X.TransferFcn5_CSTATE;

    // Sum: '<S330>/Sum' incorporates:
    //   Product: '<S333>/i x j'
    //   Product: '<S333>/j x k'
    //   Product: '<S333>/k x i'
    //   Product: '<S334>/i x k'
    //   Product: '<S334>/j x i'
    //   Product: '<S334>/k x j'

    M_ground[0] = rtb_Product_d[1] * rtb_Fp[2];
    M_ground[1] = rtb_Fp[0] * rtb_Product_d[2];
    M_ground[2] = rtb_Product_d[0] * rtb_Fp[1];
    rtb_Fp_0[0] = rtb_Fp[1] * rtb_Product_d[2];
    rtb_Fp_0[1] = rtb_Product_d[0] * rtb_Fp[2];
    rtb_Fp_0[2] = rtb_Fp[0] * rtb_Product_d[1];

    // Product: '<S332>/Product' incorporates:
    //   Integrator: '<S295>/p,q,r '

    rtb_jxi = rtb_Product_d[1];
    rtb_Divide_idx_0 = rtb_Product_d[0];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (i = 0; i < 3; i++) {
      // Product: '<S298>/Product2' incorporates:
      //   Gain: '<S173>/Gain'
      //   Saturate: '<S159>/Saturation'
      //   Selector: '<S298>/Selector1'
      //   Sum: '<S173>/Add1'
      //   Sum: '<S298>/Sum2'
      //   Sum: '<S330>/Sum'

      R_lb_0[i] = ((((((rtb_y_ho[i + 3] *
                        Lifting_wing_HIL_model_dll_P.Gain_Gain_j + rtb_Sum4_g[i])
                       + Lifting_wing_HIL_model_dll_B.M_env[i]) + rtb_Ma[i]) +
                     rtb_Mp[i]) + rtb_IntegratorSecondOrderLimi_p[i]) -
                   ((Lifting_wing_HIL_model_dll_B.Selector1[i + 3] * rtb_jxi +
                     Lifting_wing_HIL_model_dll_B.Selector1[i] *
                     rtb_Divide_idx_0) +
                    Lifting_wing_HIL_model_dll_B.Selector1[i + 6] *
                    rtb_Gain1_idx_2)) - (M_ground[i] - rtb_Fp_0[i]);
    }

    // End of Product: '<S332>/Product'

    // Product: '<S298>/Product2' incorporates:
    //   Selector: '<S298>/Selector2'

    rt_mrdivide_U1d1x3_U2d_9vOrDY9Z(R_lb_0,
      Lifting_wing_HIL_model_dll_B.Selector2,
      Lifting_wing_HIL_model_dll_B.Product2);

    // Gain: '<S94>/Zero-Order Hold3'
    rtb_Fp[0] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain *
      Lifting_wing_HIL_model_dll_B.Product2[0];
    rtb_Fp[1] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain *
      Lifting_wing_HIL_model_dll_B.Product2[1];
    rtb_Fp[2] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain *
      Lifting_wing_HIL_model_dll_B.Product2[2];

    // Sum: '<S94>/Sum' incorporates:
    //   Gain: '<S94>/Zero-Order Hold1'
    //   Gain: '<S94>/Zero-Order Hold2'
    //   Product: '<S104>/i x k'
    //   Product: '<S104>/j x i'
    //   Product: '<S104>/k x j'
    //   Product: '<S107>/i x j'
    //   Product: '<S107>/j x k'
    //   Product: '<S107>/k x i'
    //   Product: '<S108>/i x k'
    //   Product: '<S108>/j x i'
    //   Product: '<S108>/k x j'
    //   Sum: '<S101>/Sum'
    //   Sum: '<S98>/Sum'

    fphi = ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain * rtb_Sum4_h[0] -
             Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain * rtb_Fa[0]) +
            (fphi - rtb_q3dot_tmp * rtb_Saturation_c[2])) + (rtb_Fp[1] *
      Lifting_wing_HIL_model_dll_B.Gain[2] - Lifting_wing_HIL_model_dll_B.Gain[1]
      * rtb_Fp[2]);
    rtb_Sum_o = ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain * rtb_Sum4_h
                  [1] - Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain *
                  rtb_Fa[1]) + (rtb_q3dot - rtb_Saturation_c[0] *
      rtb_IntegratorSecondOrderLimi_a)) + (Lifting_wing_HIL_model_dll_B.Gain[0] *
      rtb_Fp[2] - rtb_Fp[0] * Lifting_wing_HIL_model_dll_B.Gain[2]);
    rtb_Gain7 = ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain * rtb_Sum4_h
                  [2] - Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain *
                  rtb_Fa[2]) + (rtb_Gain7 - alt * rtb_Saturation_c[1])) +
      (rtb_Fp[0] * Lifting_wing_HIL_model_dll_B.Gain[1] -
       Lifting_wing_HIL_model_dll_B.Gain[0] * rtb_Fp[1]);
    for (i = 0; i < 3; i++) {
      // Sum: '<S94>/Sum4' incorporates:
      //   Constant: '<S94>/Measurement bias'
      //   Constant: '<S94>/Scale factors & Cross-coupling  errors'
      //   Product: '<S94>/Product'

      rtb_Lw_idx_0 =
        ((Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_a_sf_cc[i + 3] *
          rtb_Sum_o +
          Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_a_sf_cc[i] * fphi)
         + Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_a_sf_cc[i + 6] *
         rtb_Gain7) +
        Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_a_bias[i];
      rtb_Fp[i] = rtb_Lw_idx_0;

      // Switch: '<S96>/Switch' incorporates:
      //   Constant: '<S96>/Constant'

      if (Lifting_wing_HIL_model_dll_P.Constant_Value_am >=
          Lifting_wing_HIL_model_dll_P.Switch_Threshold) {
        rtb_Lw_idx_0 = rtb_IntegratorSecondOrderLimite[i];
      }

      // End of Switch: '<S96>/Switch'

      // Saturate: '<S94>/Saturation'
      alt = Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_e[i];
      rtb_q3dot = Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_l[i];
      if (rtb_Lw_idx_0 > rtb_q3dot) {
        rtb_Ma[i] = rtb_q3dot;
      } else if (rtb_Lw_idx_0 < alt) {
        rtb_Ma[i] = alt;
      } else {
        rtb_Ma[i] = rtb_Lw_idx_0;
      }

      // End of Saturate: '<S94>/Saturation'
    }

    rEQ0 = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
            (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[2] == 0);
    if (rEQ0) {
      // RandomNumber: '<S89>/Random Number'
      Lifting_wing_HIL_model_dll_B.RandomNumber[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput[2];
    }

    // Sum: '<S89>/Sum' incorporates:
    //   Integrator: '<S89>/Integrator'
    //   Sum: '<S89>/Add'

    Lifting_wing_HIL_model_dll_B.Sum[0] =
      (Lifting_wing_HIL_model_dll_B.RandomNumber[0] +
       Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[0]) + rtb_Ma[0];
    Lifting_wing_HIL_model_dll_B.Sum[1] =
      (Lifting_wing_HIL_model_dll_B.RandomNumber[1] +
       Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[1]) + rtb_Ma[1];
    Lifting_wing_HIL_model_dll_B.Sum[2] =
      (Lifting_wing_HIL_model_dll_B.RandomNumber[2] +
       Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[2]) + rtb_Ma[2];
    if (tmp) {
      // Delay: '<S89>/Delay' incorporates:
      //   Constant: '<S89>/DelayLength0'
      //   Constant: '<S89>/Enable0'

      if (Lifting_wing_HIL_model_dll_P.Enable0_Value > 0.0) {
        if ((Lifting_wing_HIL_model_dll_P.DelayLength0_Value < 1.0) || std::
            isnan(Lifting_wing_HIL_model_dll_P.DelayLength0_Value)) {
          // Delay: '<S89>/Delay'
          Lifting_wing_HIL_model_dll_B.Delay[0] =
            Lifting_wing_HIL_model_dll_B.Sum[0];
          Lifting_wing_HIL_model_dll_B.Delay[1] =
            Lifting_wing_HIL_model_dll_B.Sum[1];
          Lifting_wing_HIL_model_dll_B.Delay[2] =
            Lifting_wing_HIL_model_dll_B.Sum[2];
        } else {
          if (Lifting_wing_HIL_model_dll_P.DelayLength0_Value > 100.0) {
            tmp_6 = 100U;
          } else {
            rtb_Divide_idx_0 = std::trunc
              (Lifting_wing_HIL_model_dll_P.DelayLength0_Value);
            if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
              rtb_Divide_idx_0 = 0.0;
            } else {
              rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
            }

            tmp_6 = rtb_Divide_idx_0 < 0.0 ? static_cast<uint32_T>(-static_cast<
              int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0))) :
              static_cast<uint32_T>(rtb_Divide_idx_0);
          }

          i = static_cast<int32_T>(100U - tmp_6) * 3;

          // Delay: '<S89>/Delay'
          Lifting_wing_HIL_model_dll_B.Delay[0] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[i];
          Lifting_wing_HIL_model_dll_B.Delay[1] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[i + 1];
          Lifting_wing_HIL_model_dll_B.Delay[2] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[i + 2];
        }
      }

      // End of Delay: '<S89>/Delay'

      // DataTypeConversion: '<S15>/Data Type Conversion2'
      Lifting_wing_HIL_model_dll_B.xacc = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay[0]);

      // DataTypeConversion: '<S15>/Data Type Conversion1'
      Lifting_wing_HIL_model_dll_B.yacc = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay[1]);

      // DataTypeConversion: '<S15>/Data Type Conversion3'
      Lifting_wing_HIL_model_dll_B.zacc = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay[2]);
    }

    // Gain: '<S160>/Zero-Order Hold' incorporates:
    //   Constant: '<S160>/Scale factors & Cross-coupling  errors '
    //   Product: '<S160>/Product'

    // Unit Conversion - from: m/s^2 to: gn
    // Expression: output = (0.101972*input) + (0)
    rtb_jxi = rtb_Product_d[0];
    rtb_Divide_idx_0 = rtb_Product_d[1];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (rtb_lon = 0; rtb_lon < 3; rtb_lon++) {
      // SecondOrderIntegrator: '<S166>/Integrator, Second-Order Limited'
      alt = Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[rtb_lon];
      rtb_Ma[rtb_lon] = alt;
      rtb_IntegratorSecondOrderLimi_p[rtb_lon] =
        Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[rtb_lon + 3];

      // UnitConversion: '<S156>/Unit Conversion' incorporates:
      //   Saturate: '<S159>/Saturation'
      //   Sum: '<S159>/Sum4'

      rtb_q3dot = 0.10197162129779282 * rtb_Sum4_h[rtb_lon];
      rtb_Saturation_c[rtb_lon] = rtb_q3dot;

      // Sum: '<S160>/Sum4' incorporates:
      //   Constant: '<S160>/Measurement bias'
      //   Constant: '<S160>/Scale factors & Cross-coupling  errors '
      //   Constant: '<S160>/g-sensitive bias'
      //   Gain: '<S160>/Zero-Order Hold'
      //   Gain: '<S160>/Zero-Order Hold1'
      //   Product: '<S160>/Product'
      //   Product: '<S160>/Product1'

      rtb_Lw_idx_0 = (((Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_p *
                        rtb_jxi *
                        Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_g_sf_cc[
                        rtb_lon] +
                        Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_g_sf_cc[
                        rtb_lon + 3] *
                        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_p *
                         rtb_Divide_idx_0)) +
                       Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_g_sf_cc[rtb_lon
                       + 6] * (Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_p
        * rtb_Gain1_idx_2)) +
                      Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_g_bias[rtb_lon])
        + Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain_n * rtb_q3dot *
        Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_g_sen[rtb_lon];
      rtb_Sum4_g[rtb_lon] = rtb_Lw_idx_0;

      // Switch: '<S164>/Switch' incorporates:
      //   Constant: '<S164>/Constant'

      if (Lifting_wing_HIL_model_dll_P.Constant_Value_l3 >=
          Lifting_wing_HIL_model_dll_P.Switch_Threshold_o) {
        rtb_Lw_idx_0 = alt;
      }

      // End of Switch: '<S164>/Switch'

      // Saturate: '<S160>/Saturation'
      alt = Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_m[rtb_lon];
      rtb_q3dot = Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_g[rtb_lon];
      if (rtb_Lw_idx_0 > rtb_q3dot) {
        // Saturate: '<S160>/Saturation'
        Lifting_wing_HIL_model_dll_B.Saturation_n[rtb_lon] = rtb_q3dot;
      } else if (rtb_Lw_idx_0 < alt) {
        // Saturate: '<S160>/Saturation'
        Lifting_wing_HIL_model_dll_B.Saturation_n[rtb_lon] = alt;
      } else {
        // Saturate: '<S160>/Saturation'
        Lifting_wing_HIL_model_dll_B.Saturation_n[rtb_lon] = rtb_Lw_idx_0;
      }

      // End of Saturate: '<S160>/Saturation'
    }

    if (tmp) {
      // Delay: '<S92>/Delay1' incorporates:
      //   Constant: '<S92>/DelayLength1'
      //   Constant: '<S92>/Enable1'

      if (Lifting_wing_HIL_model_dll_P.Enable1_Value > 0.0) {
        if ((Lifting_wing_HIL_model_dll_P.DelayLength1_Value < 1.0) || std::
            isnan(Lifting_wing_HIL_model_dll_P.DelayLength1_Value)) {
          // Delay: '<S92>/Delay1'
          Lifting_wing_HIL_model_dll_B.Delay1[0] =
            Lifting_wing_HIL_model_dll_B.Saturation_n[0];
          Lifting_wing_HIL_model_dll_B.Delay1[1] =
            Lifting_wing_HIL_model_dll_B.Saturation_n[1];
          Lifting_wing_HIL_model_dll_B.Delay1[2] =
            Lifting_wing_HIL_model_dll_B.Saturation_n[2];
        } else {
          if (Lifting_wing_HIL_model_dll_P.DelayLength1_Value > 100.0) {
            tmp_6 = 100U;
          } else {
            rtb_Divide_idx_0 = std::trunc
              (Lifting_wing_HIL_model_dll_P.DelayLength1_Value);
            if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
              rtb_Divide_idx_0 = 0.0;
            } else {
              rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
            }

            tmp_6 = rtb_Divide_idx_0 < 0.0 ? static_cast<uint32_T>(-static_cast<
              int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0))) :
              static_cast<uint32_T>(rtb_Divide_idx_0);
          }

          i = static_cast<int32_T>(100U - tmp_6) * 3;

          // Delay: '<S92>/Delay1'
          Lifting_wing_HIL_model_dll_B.Delay1[0] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[i];
          Lifting_wing_HIL_model_dll_B.Delay1[1] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[i + 1];
          Lifting_wing_HIL_model_dll_B.Delay1[2] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[i + 2];
        }
      }

      // End of Delay: '<S92>/Delay1'

      // DataTypeConversion: '<S15>/Data Type Conversion4'
      Lifting_wing_HIL_model_dll_B.xgyro = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1[0]);

      // DataTypeConversion: '<S15>/Data Type Conversion5'
      Lifting_wing_HIL_model_dll_B.ygyro = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1[1]);

      // DataTypeConversion: '<S15>/Data Type Conversion6'
      Lifting_wing_HIL_model_dll_B.zgyro = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1[2]);

      // RandomNumber: '<S93>/Random Number2'
      Lifting_wing_HIL_model_dll_B.RandomNumber2[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_j[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber2[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_j[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber2[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_j[2];
    }

    // MATLAB Function: '<S93>/MATLAB Function1' incorporates:
    //   Constant: '<S93>/K_m1'
    //   Constant: '<S93>/Measurement bias1'
    //   Integrator: '<S93>/Integrator1'
    //   Math: '<S7>/Transpose'
    //   Sum: '<S93>/Sum1'

    // MATLAB Function 'Sensor Model/Magnetometer Hub/MATLAB Function1': '<S168>:1' 
    // '<S168>:1:3' Mag_means = K_m*DCM*mag_e + b_m + n_m;
    for (i = 0; i < 3; i++) {
      rtb_Divide_idx_0 = 0.0;
      alt = Lifting_wing_HIL_model_dll_P.K_m1_Value[i + 3];
      rtb_q3dot = Lifting_wing_HIL_model_dll_P.K_m1_Value[i];
      rtb_Lw_idx_0 = Lifting_wing_HIL_model_dll_P.K_m1_Value[i + 6];
      for (rtb_lon = 0; rtb_lon < 3; rtb_lon++) {
        rtb_Divide_idx_0 += ((Comega[3 * rtb_lon + 1] * alt + Comega[3 * rtb_lon]
                              * rtb_q3dot) + Comega[3 * rtb_lon + 2] *
                             rtb_Lw_idx_0) * BusCreator_mag_e[rtb_lon];
      }

      R_lb_0[i] = ((Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE[i] +
                    Lifting_wing_HIL_model_dll_P.Measurementbias1_Value[i]) +
                   rtb_Divide_idx_0) +
        Lifting_wing_HIL_model_dll_B.RandomNumber2[i];
    }

    // End of MATLAB Function: '<S93>/MATLAB Function1'

    // Product: '<S93>/Product1' incorporates:
    //   Constant: '<S93>/K_pulse1'

    rtb_Divide_idx_0 = R_lb_0[1];
    alt = R_lb_0[0];
    rtb_q3dot = R_lb_0[2];
    for (i = 0; i < 3; i++) {
      // Product: '<S93>/Product1' incorporates:
      //   Constant: '<S93>/K_pulse1'

      Lifting_wing_HIL_model_dll_B.Product1[i] =
        (Lifting_wing_HIL_model_dll_P.K_pulse1_Value[i + 3] * rtb_Divide_idx_0 +
         Lifting_wing_HIL_model_dll_P.K_pulse1_Value[i] * alt) +
        Lifting_wing_HIL_model_dll_P.K_pulse1_Value[i + 6] * rtb_q3dot;
    }

    if (tmp) {
      // Delay: '<S93>/Delay1' incorporates:
      //   Constant: '<S93>/DelayLength1'
      //   Constant: '<S93>/Enable1'

      if (Lifting_wing_HIL_model_dll_P.Enable1_Value_a > 0.0) {
        if ((Lifting_wing_HIL_model_dll_P.DelayLength1_Value_g < 1.0) || std::
            isnan(Lifting_wing_HIL_model_dll_P.DelayLength1_Value_g)) {
          // Delay: '<S93>/Delay1'
          Lifting_wing_HIL_model_dll_B.Delay1_h[0] =
            Lifting_wing_HIL_model_dll_B.Product1[0];
          Lifting_wing_HIL_model_dll_B.Delay1_h[1] =
            Lifting_wing_HIL_model_dll_B.Product1[1];
          Lifting_wing_HIL_model_dll_B.Delay1_h[2] =
            Lifting_wing_HIL_model_dll_B.Product1[2];
        } else {
          if (Lifting_wing_HIL_model_dll_P.DelayLength1_Value_g > 100.0) {
            tmp_6 = 100U;
          } else {
            rtb_Divide_idx_0 = std::trunc
              (Lifting_wing_HIL_model_dll_P.DelayLength1_Value_g);
            if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
              rtb_Divide_idx_0 = 0.0;
            } else {
              rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
            }

            tmp_6 = rtb_Divide_idx_0 < 0.0 ? static_cast<uint32_T>(-static_cast<
              int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0))) :
              static_cast<uint32_T>(rtb_Divide_idx_0);
          }

          i = static_cast<int32_T>(100U - tmp_6) * 3;

          // Delay: '<S93>/Delay1'
          Lifting_wing_HIL_model_dll_B.Delay1_h[0] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[i];
          Lifting_wing_HIL_model_dll_B.Delay1_h[1] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[i + 1];
          Lifting_wing_HIL_model_dll_B.Delay1_h[2] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[i + 2];
        }
      }

      // End of Delay: '<S93>/Delay1'

      // DataTypeConversion: '<S15>/Data Type Conversion7'
      Lifting_wing_HIL_model_dll_B.xmag = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1_h[0]);

      // DataTypeConversion: '<S15>/Data Type Conversion8'
      Lifting_wing_HIL_model_dll_B.ymag = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1_h[1]);

      // DataTypeConversion: '<S15>/Data Type Conversion9'
      Lifting_wing_HIL_model_dll_B.zmag = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_B.Delay1_h[2]);
    }

    if (rEQ0) {
      // RandomNumber: '<S90>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1 =
        Lifting_wing_HIL_model_dll_DW.NextOutput_h;
    }

    // Product: '<S90>/Product' incorporates:
    //   Constant: '<S90>/K_pulse0'
    //   Integrator: '<S90>/Integrator1'
    //   Sum: '<S90>/Add2'
    //   Sum: '<S90>/Sum'

    fphi = ((Lifting_wing_HIL_model_dll_B.RandomNumber1 +
             Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_m) + lat) *
      Lifting_wing_HIL_model_dll_P.K_pulse0_Value;

    // Saturate: '<S123>/Limit  altitude  to troposhere'
    if (fphi > Lifting_wing_HIL_model_dll_P.Limitaltitudetotroposhere_Upper) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.Limitaltitudetotroposhere_Upper;
    } else if (fphi <
               Lifting_wing_HIL_model_dll_P.Limitaltitudetotroposhere_Lower) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.Limitaltitudetotroposhere_Lower;
    } else {
      rtb_Divide_idx_0 = fphi;
    }

    // Sum: '<S123>/Sum1' incorporates:
    //   Constant: '<S123>/Sea Level  Temperature'
    //   Gain: '<S123>/Lapse Rate'
    //   Saturate: '<S123>/Limit  altitude  to troposhere'

    rtb_q3dot = Lifting_wing_HIL_model_dll_P.SeaLevelTemperature_Value -
      Lifting_wing_HIL_model_dll_P.LapseRate_Gain * rtb_Divide_idx_0;

    // Gain: '<S123>/1//T0'
    rtb_Gain7 = Lifting_wing_HIL_model_dll_P.uT0_Gain * rtb_q3dot;

    // Sum: '<S123>/Sum' incorporates:
    //   Constant: '<S123>/Altitude of Troposphere'

    lat = Lifting_wing_HIL_model_dll_P.AltitudeofTroposphere_Value - fphi;

    // Math: '<S123>/(T//T0)^(g//LR) ' incorporates:
    //   Constant: '<S123>/Constant'

    if ((rtb_Gain7 < 0.0) && (Lifting_wing_HIL_model_dll_P.Constant_Value_o >
         std::floor(Lifting_wing_HIL_model_dll_P.Constant_Value_o))) {
      rtb_Divide_idx_0 = -rt_powd_snf(-rtb_Gain7,
        Lifting_wing_HIL_model_dll_P.Constant_Value_o);
    } else {
      rtb_Divide_idx_0 = rt_powd_snf(rtb_Gain7,
        Lifting_wing_HIL_model_dll_P.Constant_Value_o);
    }

    // Saturate: '<S123>/Limit  altitude  to Stratosphere'
    if (lat > Lifting_wing_HIL_model_dll_P.LimitaltitudetoStratosphere_Upp) {
      lat = Lifting_wing_HIL_model_dll_P.LimitaltitudetoStratosphere_Upp;
    } else if (lat <
               Lifting_wing_HIL_model_dll_P.LimitaltitudetoStratosphere_Low) {
      lat = Lifting_wing_HIL_model_dll_P.LimitaltitudetoStratosphere_Low;
    }

    // Product: '<S123>/Product2' incorporates:
    //   Gain: '<S123>/P0'
    //   Gain: '<S123>/g//R'
    //   Math: '<S123>/(T//T0)^(g//LR) '
    //   Math: '<S123>/Stratosphere Model'
    //   Product: '<S123>/Product1'
    //   Saturate: '<S123>/Limit  altitude  to Stratosphere'
    //
    //  About '<S123>/Stratosphere Model':
    //   Operator: exp

    alt = std::exp(1.0 / rtb_q3dot * (Lifting_wing_HIL_model_dll_P.gR_Gain * lat))
      * (Lifting_wing_HIL_model_dll_P.P0_Gain * rtb_Divide_idx_0);

    // Gain: '<S90>/Gain'
    rtb_q3dot = Lifting_wing_HIL_model_dll_P.Gain_Gain_c * q;
    if (tmp) {
      // DataTypeConversion: '<S6>/Data Type Conversion6' incorporates:
      //   Constant: '<S6>/Constant'

      rtb_Divide_idx_0 = std::floor
        (Lifting_wing_HIL_model_dll_P.Constant_Value_kl);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
      }

      // DataTypeConversion: '<S6>/Data Type Conversion6'
      Lifting_wing_HIL_model_dll_B.fields_updated = rtb_Divide_idx_0 < 0.0 ?
        static_cast<uint32_T>(-static_cast<int32_T>(static_cast<uint32_T>
        (-rtb_Divide_idx_0))) : static_cast<uint32_T>(rtb_Divide_idx_0);
    }

    // Outport: '<Root>/MavHILSensor' incorporates:
    //   BusCreator: '<S15>/Bus Creator'
    //   DataTypeConversion: '<S15>/Data Type Conversion10'
    //   DataTypeConversion: '<S15>/Data Type Conversion11'
    //   DataTypeConversion: '<S15>/Data Type Conversion12'
    //   DataTypeConversion: '<S15>/Data Type Conversion13'
    //   Gain: '<S90>/Gain3'

    Lifting_wing_HIL_model_dll_Y.MavHILSensor.time_usec =
      rtb_DataTypeConversion1;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.xacc =
      Lifting_wing_HIL_model_dll_B.xacc;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.yacc =
      Lifting_wing_HIL_model_dll_B.yacc;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.zacc =
      Lifting_wing_HIL_model_dll_B.zacc;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.xgyro =
      Lifting_wing_HIL_model_dll_B.xgyro;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.ygyro =
      Lifting_wing_HIL_model_dll_B.ygyro;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.zgyro =
      Lifting_wing_HIL_model_dll_B.zgyro;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.xmag =
      Lifting_wing_HIL_model_dll_B.xmag;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.ymag =
      Lifting_wing_HIL_model_dll_B.ymag;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.zmag =
      Lifting_wing_HIL_model_dll_B.zmag;
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.abs_pressure = static_cast<
      real32_T>(Lifting_wing_HIL_model_dll_P.Gain3_Gain * alt);
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.diff_pressure = static_cast<
      real32_T>(rtb_q3dot);
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.pressure_alt =
      static_cast<real32_T>(fphi);
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.temperature = static_cast<real32_T>
      (rtb_Switch);
    Lifting_wing_HIL_model_dll_Y.MavHILSensor.fields_updated =
      Lifting_wing_HIL_model_dll_B.fields_updated;

    // DataTypeConversion: '<S14>/Data Type Conversion2'
    x = static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Merge_p[0]);
    rtb_AngQuatern_idx_1 = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Merge_p[1]);
    rtb_AngQuatern_idx_2 = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Merge_p[2]);
    rtb_AngQuatern_idx_3 = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Merge_p[3]);
    if (tmp) {
      // UnitConversion: '<S42>/Unit Conversion' incorporates:
      //   Constant: '<S18>/ref_rotation'

      // Unit Conversion - from: deg to: rad
      // Expression: output = (0.0174533*input) + (0)
      rtb_Gain7 = 0.017453292519943295 *
        Lifting_wing_HIL_model_dll_P.FlatEarthtoLLA_psi_a;

      // Trigonometry: '<S21>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o1_e = std::sin(rtb_Gain7);

      // Trigonometry: '<S21>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o2_l = std::cos(rtb_Gain7);

      // Sum: '<S45>/Sum' incorporates:
      //   Constant: '<S45>/Constant'
      //   Constant: '<S45>/f'

      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.f_Value_p -
        Lifting_wing_HIL_model_dll_P.Constant_Value_n;

      // Sqrt: '<S46>/sqrt' incorporates:
      //   Constant: '<S46>/Constant'
      //   Product: '<S46>/Product1'
      //   Sum: '<S46>/Sum1'

      Lifting_wing_HIL_model_dll_B.sqrt_b = std::sqrt
        (Lifting_wing_HIL_model_dll_P.Constant_Value_p4 - rtb_Gain7 * rtb_Gain7);

      // Switch: '<S36>/Switch' incorporates:
      //   Abs: '<S36>/Abs'
      //   Constant: '<S18>/ref_position'
      //   Constant: '<S39>/Constant'
      //   RelationalOperator: '<S39>/Compare'

      if (std::abs(Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0]) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const_b) {
        // Switch: '<S36>/Switch' incorporates:
        //   Bias: '<S36>/Bias'
        //   Bias: '<S36>/Bias1'
        //   Constant: '<S36>/Constant2'
        //   Math: '<S36>/Math Function1'

        rtb_Switch = rt_modd_snf
          (Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0] +
           Lifting_wing_HIL_model_dll_P.Bias_Bias_j,
           Lifting_wing_HIL_model_dll_P.Constant2_Value) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_o;
      } else {
        // Switch: '<S36>/Switch'
        rtb_Switch = Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0];
      }

      // End of Switch: '<S36>/Switch'

      // Abs: '<S35>/Abs' incorporates:
      //   Abs: '<S32>/Abs1'

      fphi = std::abs(rtb_Switch);

      // If: '<S35>/If' incorporates:
      //   Abs: '<S35>/Abs'

      if (tmp_0) {
        rtAction = static_cast<int8_T>(!(fphi > 0.0));
        Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_m = rtAction;
      } else {
        rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_m;
      }

      if (rtAction == 0) {
        // Outputs for IfAction SubSystem: '<S35>/If Action Subsystem' incorporates:
        //   ActionPort: '<S37>/Action Port'

        Lifting_wing__IfActionSubsystem(rtb_Switch, fphi, &alt);

        // End of Outputs for SubSystem: '<S35>/If Action Subsystem'
      } else {
        // Outputs for IfAction SubSystem: '<S35>/If Action Subsystem1' incorporates:
        //   ActionPort: '<S38>/Action Port'

        Lifting_wi_IfActionSubsystem1_g(&alt,
          &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1_g);

        // End of Outputs for SubSystem: '<S35>/If Action Subsystem1'
      }

      // RelationalOperator: '<S34>/Compare' incorporates:
      //   Constant: '<S34>/Constant'

      rtb_Compare_a = (fphi >
                       Lifting_wing_HIL_model_dll_P.CompareToConstant_const_c);

      // Switch: '<S32>/Switch'
      if (rtb_Compare_a) {
        // Switch: '<S32>/Switch' incorporates:
        //   Bias: '<S32>/Bias'
        //   Bias: '<S32>/Bias1'
        //   Gain: '<S32>/Gain'
        //   Product: '<S32>/Divide1'

        Lifting_wing_HIL_model_dll_B.Switch_c = ((fphi +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_e) *
          Lifting_wing_HIL_model_dll_P.Gain_Gain_k +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_n) * alt;
      } else {
        // Switch: '<S32>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch_c = rtb_Switch;
      }

      // End of Switch: '<S32>/Switch'
    }

    // UnitConversion: '<S43>/Unit Conversion'
    // Unit Conversion - from: deg to: rad
    // Expression: output = (0.0174533*input) + (0)
    fphi = 0.017453292519943295 * Lifting_wing_HIL_model_dll_B.Switch_c;

    // Trigonometry: '<S44>/Trigonometric Function1'
    rtb_Gain7 = std::sin(fphi);

    // Sum: '<S44>/Sum1' incorporates:
    //   Constant: '<S44>/Constant'
    //   Product: '<S44>/Product1'

    rtb_Gain7 = Lifting_wing_HIL_model_dll_P.Constant_Value_fz -
      Lifting_wing_HIL_model_dll_B.sqrt_b * Lifting_wing_HIL_model_dll_B.sqrt_b *
      rtb_Gain7 * rtb_Gain7;

    // Product: '<S41>/Product1' incorporates:
    //   Constant: '<S41>/Constant1'
    //   Sqrt: '<S41>/sqrt'

    rtb_Sum_o = Lifting_wing_HIL_model_dll_P.Constant1_Value_lv / std::sqrt
      (rtb_Gain7);
    if (tmp) {
      // Sum: '<S41>/Sum1' incorporates:
      //   Constant: '<S41>/Constant'
      //   Product: '<S41>/Product2'

      Lifting_wing_HIL_model_dll_B.Sum1_p =
        Lifting_wing_HIL_model_dll_P.Constant_Value_fp -
        Lifting_wing_HIL_model_dll_B.sqrt_b *
        Lifting_wing_HIL_model_dll_B.sqrt_b;

      // Switch: '<S20>/Switch1' incorporates:
      //   Constant: '<S20>/Constant'
      //   Constant: '<S20>/Constant1'

      if (rtb_Compare_a) {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant_Value;
      } else {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant1_Value;
      }

      // Sum: '<S20>/Sum' incorporates:
      //   Constant: '<S18>/ref_position'
      //   Switch: '<S20>/Switch1'

      rtb_Switch = rtb_Divide_idx_0 +
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[1];

      // Switch: '<S33>/Switch' incorporates:
      //   Abs: '<S33>/Abs'
      //   Constant: '<S40>/Constant'
      //   RelationalOperator: '<S40>/Compare'

      if (std::abs(rtb_Switch) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const_e) {
        // Switch: '<S33>/Switch' incorporates:
        //   Bias: '<S33>/Bias'
        //   Bias: '<S33>/Bias1'
        //   Constant: '<S33>/Constant2'
        //   Math: '<S33>/Math Function1'

        Lifting_wing_HIL_model_dll_B.Switch_b = rt_modd_snf(rtb_Switch +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_n,
          Lifting_wing_HIL_model_dll_P.Constant2_Value_b) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_nx;
      } else {
        // Switch: '<S33>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch_b = rtb_Switch;
      }

      // End of Switch: '<S33>/Switch'
    }

    // Sum: '<S18>/Sum' incorporates:
    //   Product: '<S21>/rad lat'
    //   Product: '<S21>/rad long '
    //   Product: '<S21>/x*cos'
    //   Product: '<S21>/x*sin'
    //   Product: '<S21>/y*cos'
    //   Product: '<S21>/y*sin'
    //   Product: '<S41>/Product3'
    //   Product: '<S41>/Product4'
    //   Sum: '<S21>/Sum'
    //   Sum: '<S21>/Sum1'
    //   Trigonometry: '<S41>/Trigonometric Function'
    //   UnitConversion: '<S22>/Unit Conversion'

    // Unit Conversion - from: rad to: deg
    // Expression: output = (57.2958*input) + (0)
    rtb_Switch = (rtb_sincos_o1[0] * Lifting_wing_HIL_model_dll_B.SinCos_o2_l -
                  rtb_sincos_o1[1] * Lifting_wing_HIL_model_dll_B.SinCos_o1_e) /
      (rtb_Sum_o * Lifting_wing_HIL_model_dll_B.Sum1_p / rtb_Gain7) *
      57.295779513082323 + Lifting_wing_HIL_model_dll_B.Switch_c;
    q = 1.0 / (rtb_Sum_o * std::cos(fphi)) * (rtb_sincos_o1[0] *
      Lifting_wing_HIL_model_dll_B.SinCos_o1_e + rtb_sincos_o1[1] *
      Lifting_wing_HIL_model_dll_B.SinCos_o2_l) * 57.295779513082323 +
      Lifting_wing_HIL_model_dll_B.Switch_b;

    // Switch: '<S27>/Switch' incorporates:
    //   Abs: '<S27>/Abs'
    //   Constant: '<S30>/Constant'
    //   RelationalOperator: '<S30>/Compare'

    if (std::abs(rtb_Switch) >
        Lifting_wing_HIL_model_dll_P.CompareToConstant_const_p) {
      // Switch: '<S27>/Switch' incorporates:
      //   Bias: '<S27>/Bias'
      //   Bias: '<S27>/Bias1'
      //   Constant: '<S27>/Constant2'
      //   Math: '<S27>/Math Function1'

      fphi = rt_modd_snf(rtb_Switch + Lifting_wing_HIL_model_dll_P.Bias_Bias_d,
                         Lifting_wing_HIL_model_dll_P.Constant2_Value_mf) +
        Lifting_wing_HIL_model_dll_P.Bias1_Bias_l;
    } else {
      // Switch: '<S27>/Switch'
      fphi = rtb_Switch;
    }

    // End of Switch: '<S27>/Switch'

    // Abs: '<S26>/Abs' incorporates:
    //   Abs: '<S23>/Abs1'

    rtb_Switch = std::abs(fphi);

    // If: '<S26>/If' incorporates:
    //   Abs: '<S26>/Abs'

    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f4;
    if (tmp_0) {
      rtAction = static_cast<int8_T>(!(rtb_Switch > 0.0));
      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f4 = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f4;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    if (rtAction == 0) {
      // Outputs for IfAction SubSystem: '<S26>/If Action Subsystem' incorporates:
      //   ActionPort: '<S28>/Action Port'

      Lifting_wing__IfActionSubsystem(fphi, rtb_Switch,
        &Lifting_wing_HIL_model_dll_B.Merge_c);

      // End of Outputs for SubSystem: '<S26>/If Action Subsystem'
    } else {
      // Outputs for IfAction SubSystem: '<S26>/If Action Subsystem1' incorporates:
      //   ActionPort: '<S29>/Action Port'

      Lifting_wing_IfActionSubsystem1(&Lifting_wing_HIL_model_dll_B.Merge_c,
        &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1);

      // End of Outputs for SubSystem: '<S26>/If Action Subsystem1'
    }

    // RelationalOperator: '<S25>/Compare' incorporates:
    //   Constant: '<S25>/Constant'

    rtb_Compare_d = (rtb_Switch >
                     Lifting_wing_HIL_model_dll_P.CompareToConstant_const_o);

    // Switch: '<S23>/Switch' incorporates:
    //   Bias: '<S23>/Bias'
    //   Bias: '<S23>/Bias1'
    //   Gain: '<S23>/Gain'
    //   Product: '<S23>/Divide1'

    if (rtb_Compare_d) {
      fphi = ((rtb_Switch + Lifting_wing_HIL_model_dll_P.Bias_Bias) *
              Lifting_wing_HIL_model_dll_P.Gain_Gain +
              Lifting_wing_HIL_model_dll_P.Bias1_Bias) *
        Lifting_wing_HIL_model_dll_B.Merge_c;
    }

    // End of Switch: '<S23>/Switch'

    // DataTypeConversion: '<S14>/Data Type Conversion4' incorporates:
    //   Gain: '<S14>/Gain'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain_Gain_o *
      fphi);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/MavHILStateQuat' incorporates:
    //   DataTypeConversion: '<S14>/Data Type Conversion4'

    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.lat = rtb_Divide_idx_0 < 0.0 ?
      -static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // Switch: '<S19>/Switch1' incorporates:
    //   Constant: '<S19>/Constant'
    //   Constant: '<S19>/Constant1'

    if (rtb_Compare_d) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant_Value_ar;
    } else {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant1_Value_k;
    }

    // Sum: '<S19>/Sum' incorporates:
    //   Switch: '<S19>/Switch1'

    fphi = rtb_Divide_idx_0 + q;

    // Switch: '<S24>/Switch' incorporates:
    //   Abs: '<S24>/Abs'
    //   Bias: '<S24>/Bias'
    //   Bias: '<S24>/Bias1'
    //   Constant: '<S24>/Constant2'
    //   Constant: '<S31>/Constant'
    //   Math: '<S24>/Math Function1'
    //   RelationalOperator: '<S31>/Compare'

    if (std::abs(fphi) > Lifting_wing_HIL_model_dll_P.CompareToConstant_const_h3)
    {
      fphi = rt_modd_snf(fphi + Lifting_wing_HIL_model_dll_P.Bias_Bias_g,
                         Lifting_wing_HIL_model_dll_P.Constant2_Value_m1) +
        Lifting_wing_HIL_model_dll_P.Bias1_Bias_c;
    }

    // End of Switch: '<S24>/Switch'

    // DataTypeConversion: '<S14>/Data Type Conversion9' incorporates:
    //   Gain: '<S14>/Gain2'
    //   Gain: '<S14>/Gain7'
    //   Sqrt: '<S14>/Sqrt1'

    rtb_Divide_idx_0 = std::round(std::sqrt
      (Lifting_wing_HIL_model_dll_P.Gain2_Gain * rtb_q3dot) *
      Lifting_wing_HIL_model_dll_P.Gain7_Gain);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    alt = std::round(Lifting_wing_HIL_model_dll_P.Gain7_Gain * Merge);
    if (std::isnan(alt) || std::isinf(alt)) {
      alt = 0.0;
    } else {
      alt = std::fmod(alt, 65536.0);
    }

    // Sum: '<S295>/Sum' incorporates:
    //   Product: '<S335>/i x j'
    //   Product: '<S335>/j x k'
    //   Product: '<S335>/k x i'
    //   Product: '<S336>/i x k'
    //   Product: '<S336>/j x i'
    //   Product: '<S336>/k x j'
    //   Sum: '<S300>/Sum'

    Lifting_wing_HIL_model_dll_B.Sum_p[0] = (rtb_TmpSignalConversionAtSFunct[1] *
      rtb_Product_d[2] - rtb_Product_d[1] * rtb_TmpSignalConversionAtSFunct[2])
      + rtb_Sum4_h[0];
    Lifting_wing_HIL_model_dll_B.Sum_p[1] = (rtb_Product_d[0] *
      rtb_TmpSignalConversionAtSFunct[2] - rtb_TmpSignalConversionAtSFunct[0] *
      rtb_Product_d[2]) + rtb_Sum4_h[1];
    Lifting_wing_HIL_model_dll_B.Sum_p[2] = (rtb_TmpSignalConversionAtSFunct[0] *
      rtb_Product_d[1] - rtb_Product_d[0] * rtb_TmpSignalConversionAtSFunct[1])
      + rtb_Sum4_h[2];

    // DataTypeConversion: '<S14>/Data Type Conversion7' incorporates:
    //   Gain: '<S14>/Gain4'
    //   Product: '<S304>/Product'

    rtb_q3dot = std::round(Lifting_wing_HIL_model_dll_P.Gain4_Gain *
      Lifting_wing_HIL_model_dll_B.Product[0]);
    if (std::isnan(rtb_q3dot) || std::isinf(rtb_q3dot)) {
      rtb_q3dot = 0.0;
    } else {
      rtb_q3dot = std::fmod(rtb_q3dot, 65536.0);
    }

    // DataTypeConversion: '<S14>/Data Type Conversion8' incorporates:
    //   Gain: '<S14>/Gain5'
    //   Sum: '<S295>/Sum'

    rtb_Switch = std::round(Lifting_wing_HIL_model_dll_P.Gain5_Gain *
      Lifting_wing_HIL_model_dll_B.Sum_p[0]);
    if (std::isnan(rtb_Switch) || std::isinf(rtb_Switch)) {
      rtb_Switch = 0.0;
    } else {
      rtb_Switch = std::fmod(rtb_Switch, 65536.0);
    }

    // DataTypeConversion: '<S14>/Data Type Conversion7' incorporates:
    //   Gain: '<S14>/Gain4'
    //   Product: '<S304>/Product'

    Merge = std::round(Lifting_wing_HIL_model_dll_P.Gain4_Gain *
                       Lifting_wing_HIL_model_dll_B.Product[1]);
    if (std::isnan(Merge) || std::isinf(Merge)) {
      Merge = 0.0;
    } else {
      Merge = std::fmod(Merge, 65536.0);
    }

    // DataTypeConversion: '<S14>/Data Type Conversion8' incorporates:
    //   Gain: '<S14>/Gain5'
    //   Sum: '<S295>/Sum'

    q = std::round(Lifting_wing_HIL_model_dll_P.Gain5_Gain *
                   Lifting_wing_HIL_model_dll_B.Sum_p[1]);
    if (std::isnan(q) || std::isinf(q)) {
      q = 0.0;
    } else {
      q = std::fmod(q, 65536.0);
    }

    // DataTypeConversion: '<S14>/Data Type Conversion7' incorporates:
    //   Gain: '<S14>/Gain4'
    //   Product: '<S304>/Product'

    rtb_Lw_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain4_Gain *
      Lifting_wing_HIL_model_dll_B.Product[2]);
    if (std::isnan(rtb_Lw_idx_0) || std::isinf(rtb_Lw_idx_0)) {
      rtb_Lw_idx_0 = 0.0;
    } else {
      rtb_Lw_idx_0 = std::fmod(rtb_Lw_idx_0, 65536.0);
    }

    // DataTypeConversion: '<S14>/Data Type Conversion8' incorporates:
    //   Gain: '<S14>/Gain5'
    //   Sum: '<S295>/Sum'

    rtb_Gain7 = std::round(Lifting_wing_HIL_model_dll_P.Gain5_Gain *
      Lifting_wing_HIL_model_dll_B.Sum_p[2]);
    if (std::isnan(rtb_Gain7) || std::isinf(rtb_Gain7)) {
      rtb_Gain7 = 0.0;
    } else {
      rtb_Gain7 = std::fmod(rtb_Gain7, 65536.0);
    }

    // Outport: '<Root>/MavHILStateQuat' incorporates:
    //   BusCreator: '<S14>/Bus Creator'
    //   DataTypeConversion: '<S14>/Data Type Conversion3'
    //   Integrator: '<S295>/p,q,r '

    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.time_usec =
      rtb_DataTypeConversion1;
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.attitude_quaternion[0] = x;
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.attitude_quaternion[1] =
      rtb_AngQuatern_idx_1;
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.attitude_quaternion[2] =
      rtb_AngQuatern_idx_2;
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.attitude_quaternion[3] =
      rtb_AngQuatern_idx_3;
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.rollspeed =
      static_cast<real32_T>(rtb_Product_d[0]);
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.pitchspeed = static_cast<
      real32_T>(rtb_Product_d[1]);
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.yawspeed = static_cast<real32_T>
      (rtb_Product_d[2]);

    // DataTypeConversion: '<S14>/Data Type Conversion1' incorporates:
    //   Gain: '<S14>/Gain1'

    lat = std::round(Lifting_wing_HIL_model_dll_P.Gain1_Gain * fphi);
    if (std::isnan(lat) || std::isinf(lat)) {
      lat = 0.0;
    } else {
      lat = std::fmod(lat, 4.294967296E+9);
    }

    // Outport: '<Root>/MavHILStateQuat' incorporates:
    //   DataTypeConversion: '<S14>/Data Type Conversion1'

    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.lon = lat < 0.0 ? -static_cast<
      int32_T>(static_cast<uint32_T>(-lat)) : static_cast<int32_T>
      (static_cast<uint32_T>(lat));

    // Sum: '<S18>/Sum1' incorporates:
    //   Constant: '<S14>/ModelParam_envAltitude'
    //   UnaryMinus: '<S18>/Ze2height'

    lat = -rtb_sincos_o1[2] -
      Lifting_wing_HIL_model_dll_P.ModelParam_envAltitude;

    // Saturate: '<S14>/Saturation' incorporates:
    //   Sum: '<S18>/Sum1'

    if (lat > Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_a) {
      lat = Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_a;
    } else if (lat < Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_i) {
      lat = Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_i;
    }

    // DataTypeConversion: '<S14>/Data Type Conversion5' incorporates:
    //   Gain: '<S14>/Gain3'
    //   Saturate: '<S14>/Saturation'

    lat = std::round(Lifting_wing_HIL_model_dll_P.Gain3_Gain_i * lat);
    if (std::isnan(lat) || std::isinf(lat)) {
      lat = 0.0;
    } else {
      lat = std::fmod(lat, 4.294967296E+9);
    }

    // Outport: '<Root>/MavHILStateQuat' incorporates:
    //   DataTypeConversion: '<S14>/Data Type Conversion5'
    //   DataTypeConversion: '<S14>/Data Type Conversion7'
    //   DataTypeConversion: '<S14>/Data Type Conversion8'
    //   DataTypeConversion: '<S14>/Data Type Conversion9'

    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.alt = lat < 0.0 ?
      -static_cast<int32_T>(static_cast<uint32_T>(-lat)) : static_cast<int32_T>(
      static_cast<uint32_T>(lat));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.vx = static_cast<int16_T>
      (rtb_q3dot < 0.0 ? static_cast<int32_T>(static_cast<int16_T>
        (-static_cast<int16_T>(static_cast<uint16_T>(-rtb_q3dot)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>(rtb_q3dot))));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.vy = static_cast<int16_T>(Merge
      < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-static_cast<int16_T>(
      static_cast<uint16_T>(-Merge)))) : static_cast<int32_T>
      (static_cast<int16_T>(static_cast<uint16_T>(Merge))));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.vz = static_cast<int16_T>
      (rtb_Lw_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Lw_idx_0)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>
         (rtb_Lw_idx_0))));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.ind_airspeed =
      static_cast<uint16_T>(rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(
      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>
      (-rtb_Divide_idx_0)))) : static_cast<int32_T>(static_cast<uint16_T>
      (rtb_Divide_idx_0)));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.true_airspeed =
      static_cast<uint16_T>(alt < 0.0 ? static_cast<int32_T>
      (static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>(-alt))))
      : static_cast<int32_T>(static_cast<uint16_T>(alt)));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.xacc = static_cast<int16_T>
      (rtb_Switch < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Switch)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>
         (rtb_Switch))));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.yacc = static_cast<int16_T>(q <
      0.0 ? static_cast<int32_T>(static_cast<int16_T>(-static_cast<int16_T>(
      static_cast<uint16_T>(-q)))) : static_cast<int32_T>(static_cast<int16_T>(
      static_cast<uint16_T>(q))));
    Lifting_wing_HIL_model_dll_Y.MavHILStateQuat.zacc = static_cast<int16_T>
      (rtb_Gain7 < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-static_cast<
         int16_T>(static_cast<uint16_T>(-rtb_Gain7)))) : static_cast<int32_T>(
        static_cast<int16_T>(static_cast<uint16_T>(rtb_Gain7))));
    tmp_1 = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
             (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[3] == 0);
    if (tmp_1) {
      // Gain: '<S91>/Gain1' incorporates:
      //   UniformRandomNumber: '<S91>/Uniform Random Number1'

      Lifting_wing_HIL_model_dll_B.Gain1[0] =
        Lifting_wing_HIL_model_dll_P.Gain1_Gain_b *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[0];
      Lifting_wing_HIL_model_dll_B.Gain1[1] =
        Lifting_wing_HIL_model_dll_P.Gain1_Gain_b *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[1];
      Lifting_wing_HIL_model_dll_B.Gain1[2] =
        Lifting_wing_HIL_model_dll_P.Gain1_Gain_b *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[2];
    }

    // Sum: '<S91>/Sum' incorporates:
    //   Integrator: '<S273>/Integrator1'
    //   Integrator: '<S295>/xe,ye,ze'

    rtb_Integrator1_p[0] = rtb_sincos_o1[0] +
      Lifting_wing_HIL_model_dll_B.Gain1[0];
    rtb_Integrator1_p[1] = rtb_sincos_o1[1] +
      Lifting_wing_HIL_model_dll_B.Gain1[1];
    rtb_Integrator1_p[2] = rtb_sincos_o1[2] +
      Lifting_wing_HIL_model_dll_B.Gain1[2];
    if (tmp) {
      // UnitConversion: '<S151>/Unit Conversion' incorporates:
      //   Constant: '<S125>/ref_rotation'

      // Unit Conversion - from: deg to: rad
      // Expression: output = (0.0174533*input) + (0)
      rtb_Gain7 = 0.017453292519943295 *
        Lifting_wing_HIL_model_dll_P.FlatEarthtoLLA_psi_m;

      // Trigonometry: '<S130>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o1_g = std::sin(rtb_Gain7);

      // Trigonometry: '<S130>/SinCos'
      Lifting_wing_HIL_model_dll_B.SinCos_o2_j = std::cos(rtb_Gain7);

      // Sum: '<S154>/Sum' incorporates:
      //   Constant: '<S154>/Constant'
      //   Constant: '<S154>/f'

      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.f_Value_g -
        Lifting_wing_HIL_model_dll_P.Constant_Value_oe;

      // Sqrt: '<S155>/sqrt' incorporates:
      //   Constant: '<S155>/Constant'
      //   Product: '<S155>/Product1'
      //   Sum: '<S155>/Sum1'

      Lifting_wing_HIL_model_dll_B.sqrt_j = std::sqrt
        (Lifting_wing_HIL_model_dll_P.Constant_Value_lj - rtb_Gain7 * rtb_Gain7);

      // Switch: '<S145>/Switch' incorporates:
      //   Abs: '<S145>/Abs'
      //   Constant: '<S125>/ref_position'
      //   Constant: '<S148>/Constant'
      //   RelationalOperator: '<S148>/Compare'

      if (std::abs(Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0]) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const_i) {
        // Switch: '<S145>/Switch' incorporates:
        //   Bias: '<S145>/Bias'
        //   Bias: '<S145>/Bias1'
        //   Constant: '<S145>/Constant2'
        //   Math: '<S145>/Math Function1'

        rtb_q3dot = rt_modd_snf
          (Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0] +
           Lifting_wing_HIL_model_dll_P.Bias_Bias_j1,
           Lifting_wing_HIL_model_dll_P.Constant2_Value_bi) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_k;
      } else {
        // Switch: '<S145>/Switch'
        rtb_q3dot = Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[0];
      }

      // End of Switch: '<S145>/Switch'

      // Abs: '<S144>/Abs' incorporates:
      //   Abs: '<S141>/Abs1'

      rtb_Switch = std::abs(rtb_q3dot);

      // If: '<S144>/If' incorporates:
      //   Abs: '<S144>/Abs'

      if (tmp_0) {
        rtAction = static_cast<int8_T>(!(rtb_Switch > 0.0));
        Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_j = rtAction;
      } else {
        rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_j;
      }

      if (rtAction == 0) {
        // Outputs for IfAction SubSystem: '<S144>/If Action Subsystem' incorporates:
        //   ActionPort: '<S146>/Action Port'

        Lifting_wing__IfActionSubsystem(rtb_q3dot, rtb_Switch, &fphi);

        // End of Outputs for SubSystem: '<S144>/If Action Subsystem'
      } else {
        // Outputs for IfAction SubSystem: '<S144>/If Action Subsystem1' incorporates:
        //   ActionPort: '<S147>/Action Port'

        Lifting_wi_IfActionSubsystem1_g(&fphi,
          &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1_j);

        // End of Outputs for SubSystem: '<S144>/If Action Subsystem1'
      }

      // RelationalOperator: '<S143>/Compare' incorporates:
      //   Constant: '<S143>/Constant'

      rtb_Compare_a = (rtb_Switch >
                       Lifting_wing_HIL_model_dll_P.CompareToConstant_const_lb);

      // Switch: '<S141>/Switch'
      if (rtb_Compare_a) {
        // Switch: '<S141>/Switch' incorporates:
        //   Bias: '<S141>/Bias'
        //   Bias: '<S141>/Bias1'
        //   Gain: '<S141>/Gain'
        //   Product: '<S141>/Divide1'

        Lifting_wing_HIL_model_dll_B.Switch_l = ((rtb_Switch +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_f) *
          Lifting_wing_HIL_model_dll_P.Gain_Gain_l +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_o3) * fphi;
      } else {
        // Switch: '<S141>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch_l = rtb_q3dot;
      }

      // End of Switch: '<S141>/Switch'
    }

    // UnitConversion: '<S152>/Unit Conversion'
    // Unit Conversion - from: deg to: rad
    // Expression: output = (0.0174533*input) + (0)
    fphi = 0.017453292519943295 * Lifting_wing_HIL_model_dll_B.Switch_l;

    // Trigonometry: '<S153>/Trigonometric Function1'
    rtb_q3dot = std::sin(fphi);

    // Sum: '<S153>/Sum1' incorporates:
    //   Constant: '<S153>/Constant'
    //   Product: '<S153>/Product1'

    rtb_q3dot = Lifting_wing_HIL_model_dll_P.Constant_Value_j3 -
      Lifting_wing_HIL_model_dll_B.sqrt_j * Lifting_wing_HIL_model_dll_B.sqrt_j *
      rtb_q3dot * rtb_q3dot;

    // Product: '<S150>/Product1' incorporates:
    //   Constant: '<S150>/Constant1'
    //   Sqrt: '<S150>/sqrt'

    rtb_Gain7 = Lifting_wing_HIL_model_dll_P.Constant1_Value_e / std::sqrt
      (rtb_q3dot);
    if (tmp) {
      // Sum: '<S150>/Sum1' incorporates:
      //   Constant: '<S150>/Constant'
      //   Product: '<S150>/Product2'

      Lifting_wing_HIL_model_dll_B.Sum1_m =
        Lifting_wing_HIL_model_dll_P.Constant_Value_lk -
        Lifting_wing_HIL_model_dll_B.sqrt_j *
        Lifting_wing_HIL_model_dll_B.sqrt_j;
    }

    // UnitConversion: '<S131>/Unit Conversion' incorporates:
    //   Product: '<S130>/rad lat'
    //   Product: '<S130>/x*cos'
    //   Product: '<S130>/y*sin'
    //   Product: '<S150>/Product3'
    //   Sum: '<S130>/Sum'

    // Unit Conversion - from: rad to: deg
    // Expression: output = (57.2958*input) + (0)
    rtb_Lw_idx_0 = (rtb_Integrator1_p[0] *
                    Lifting_wing_HIL_model_dll_B.SinCos_o2_j -
                    rtb_Integrator1_p[1] *
                    Lifting_wing_HIL_model_dll_B.SinCos_o1_g) / (rtb_Gain7 *
      Lifting_wing_HIL_model_dll_B.Sum1_m / rtb_q3dot) * 57.295779513082323;
    if (tmp) {
      // Switch: '<S129>/Switch1' incorporates:
      //   Constant: '<S129>/Constant'
      //   Constant: '<S129>/Constant1'

      if (rtb_Compare_a) {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant_Value_a;
      } else {
        rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant1_Value_b;
      }

      // Sum: '<S129>/Sum' incorporates:
      //   Constant: '<S125>/ref_position'
      //   Switch: '<S129>/Switch1'

      rtb_q3dot = rtb_Divide_idx_0 +
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSLatLong[1];

      // Switch: '<S142>/Switch' incorporates:
      //   Abs: '<S142>/Abs'
      //   Constant: '<S149>/Constant'
      //   RelationalOperator: '<S149>/Compare'

      if (std::abs(rtb_q3dot) >
          Lifting_wing_HIL_model_dll_P.CompareToConstant_const_jt) {
        // Switch: '<S142>/Switch' incorporates:
        //   Bias: '<S142>/Bias'
        //   Bias: '<S142>/Bias1'
        //   Constant: '<S142>/Constant2'
        //   Math: '<S142>/Math Function1'

        Lifting_wing_HIL_model_dll_B.Switch_d = rt_modd_snf(rtb_q3dot +
          Lifting_wing_HIL_model_dll_P.Bias_Bias_hi,
          Lifting_wing_HIL_model_dll_P.Constant2_Value_m) +
          Lifting_wing_HIL_model_dll_P.Bias1_Bias_j;
      } else {
        // Switch: '<S142>/Switch'
        Lifting_wing_HIL_model_dll_B.Switch_d = rtb_q3dot;
      }

      // End of Switch: '<S142>/Switch'
    }

    // Sum: '<S125>/Sum' incorporates:
    //   Product: '<S130>/rad long '
    //   Product: '<S130>/x*sin'
    //   Product: '<S130>/y*cos'
    //   Product: '<S150>/Product4'
    //   Sum: '<S130>/Sum1'
    //   Trigonometry: '<S150>/Trigonometric Function'
    //   UnitConversion: '<S131>/Unit Conversion'

    rtb_Switch = rtb_Lw_idx_0 + Lifting_wing_HIL_model_dll_B.Switch_l;
    q = 1.0 / (rtb_Gain7 * std::cos(fphi)) * (rtb_Integrator1_p[0] *
      Lifting_wing_HIL_model_dll_B.SinCos_o1_g + rtb_Integrator1_p[1] *
      Lifting_wing_HIL_model_dll_B.SinCos_o2_j) * 57.295779513082323 +
      Lifting_wing_HIL_model_dll_B.Switch_d;

    // Switch: '<S136>/Switch' incorporates:
    //   Abs: '<S136>/Abs'
    //   Constant: '<S139>/Constant'
    //   RelationalOperator: '<S139>/Compare'

    if (std::abs(rtb_Switch) >
        Lifting_wing_HIL_model_dll_P.CompareToConstant_const_hj) {
      // Switch: '<S136>/Switch' incorporates:
      //   Bias: '<S136>/Bias'
      //   Bias: '<S136>/Bias1'
      //   Constant: '<S136>/Constant2'
      //   Math: '<S136>/Math Function1'

      fphi = rt_modd_snf(rtb_Switch + Lifting_wing_HIL_model_dll_P.Bias_Bias_h,
                         Lifting_wing_HIL_model_dll_P.Constant2_Value_bb) +
        Lifting_wing_HIL_model_dll_P.Bias1_Bias_h;
    } else {
      // Switch: '<S136>/Switch'
      fphi = rtb_Switch;
    }

    // End of Switch: '<S136>/Switch'

    // Abs: '<S135>/Abs' incorporates:
    //   Abs: '<S132>/Abs1'

    rtb_q3dot = std::abs(fphi);

    // If: '<S135>/If' incorporates:
    //   Abs: '<S135>/Abs'

    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_g;
    if (tmp_0) {
      rtAction = static_cast<int8_T>(!(rtb_q3dot > 0.0));
      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_g = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_g;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    if (rtAction == 0) {
      // Outputs for IfAction SubSystem: '<S135>/If Action Subsystem' incorporates:
      //   ActionPort: '<S137>/Action Port'

      Lifting_wing__IfActionSubsystem(fphi, rtb_q3dot,
        &Lifting_wing_HIL_model_dll_B.Merge_pz);

      // End of Outputs for SubSystem: '<S135>/If Action Subsystem'
    } else {
      // Outputs for IfAction SubSystem: '<S135>/If Action Subsystem1' incorporates:
      //   ActionPort: '<S138>/Action Port'

      Lifting_wing_IfActionSubsystem1(&Lifting_wing_HIL_model_dll_B.Merge_pz,
        &Lifting_wing_HIL_model_dll_P.IfActionSubsystem1_n);

      // End of Outputs for SubSystem: '<S135>/If Action Subsystem1'
    }

    // RelationalOperator: '<S134>/Compare' incorporates:
    //   Constant: '<S134>/Constant'

    rtb_Compare_d = (rtb_q3dot >
                     Lifting_wing_HIL_model_dll_P.CompareToConstant_const_fd);

    // Switch: '<S132>/Switch' incorporates:
    //   Bias: '<S132>/Bias'
    //   Bias: '<S132>/Bias1'
    //   Gain: '<S132>/Gain'
    //   Product: '<S132>/Divide1'

    if (rtb_Compare_d) {
      fphi = ((rtb_q3dot + Lifting_wing_HIL_model_dll_P.Bias_Bias_c) *
              Lifting_wing_HIL_model_dll_P.Gain_Gain_m +
              Lifting_wing_HIL_model_dll_P.Bias1_Bias_f) *
        Lifting_wing_HIL_model_dll_B.Merge_pz;
    }

    // End of Switch: '<S132>/Switch'

    // DataTypeConversion: '<S13>/Data Type Conversion4' incorporates:
    //   Gain: '<S13>/Gain'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain_Gain_pm *
      fphi);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    rtb_lat = rtb_Divide_idx_0 < 0.0 ? -static_cast<int32_T>
      (static_cast<uint32_T>(-rtb_Divide_idx_0)) : static_cast<int32_T>(
      static_cast<uint32_T>(rtb_Divide_idx_0));

    // End of DataTypeConversion: '<S13>/Data Type Conversion4'

    // Switch: '<S128>/Switch1' incorporates:
    //   Constant: '<S128>/Constant'
    //   Constant: '<S128>/Constant1'

    if (rtb_Compare_d) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant_Value_b;
    } else {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.Constant1_Value_bf;
    }

    // Sum: '<S128>/Sum' incorporates:
    //   Switch: '<S128>/Switch1'

    rtb_q3dot = rtb_Divide_idx_0 + q;

    // Switch: '<S133>/Switch' incorporates:
    //   Abs: '<S133>/Abs'
    //   Bias: '<S133>/Bias'
    //   Bias: '<S133>/Bias1'
    //   Constant: '<S133>/Constant2'
    //   Constant: '<S140>/Constant'
    //   Math: '<S133>/Math Function1'
    //   RelationalOperator: '<S140>/Compare'

    if (std::abs(rtb_q3dot) >
        Lifting_wing_HIL_model_dll_P.CompareToConstant_const_hi) {
      rtb_q3dot = rt_modd_snf(rtb_q3dot +
        Lifting_wing_HIL_model_dll_P.Bias_Bias_c1,
        Lifting_wing_HIL_model_dll_P.Constant2_Value_mz) +
        Lifting_wing_HIL_model_dll_P.Bias1_Bias_nn;
    }

    // End of Switch: '<S133>/Switch'

    // DataTypeConversion: '<S13>/Data Type Conversion1' incorporates:
    //   Gain: '<S13>/Gain1'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain1_Gain_h *
      rtb_q3dot);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    rtb_lon = rtb_Divide_idx_0 < 0.0 ? -static_cast<int32_T>
      (static_cast<uint32_T>(-rtb_Divide_idx_0)) : static_cast<int32_T>(
      static_cast<uint32_T>(rtb_Divide_idx_0));

    // End of DataTypeConversion: '<S13>/Data Type Conversion1'

    // Sum: '<S125>/Sum1' incorporates:
    //   Constant: '<S91>/ModelParam_envAltitude'
    //   UnaryMinus: '<S125>/Ze2height'

    rtb_Gain7 = -rtb_Integrator1_p[2] -
      Lifting_wing_HIL_model_dll_P.ModelParam_envAltitude;

    // Saturate: '<S91>/Saturation'
    if (rtb_Gain7 > Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_i) {
      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_i;
    } else if (rtb_Gain7 < Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_i4)
    {
      rtb_Gain7 = Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_i4;
    }

    // End of Saturate: '<S91>/Saturation'

    // DataTypeConversion: '<S13>/Data Type Conversion5' incorporates:
    //   Gain: '<S13>/Gain3'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain3_Gain_g *
      rtb_Gain7);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    i = rtb_Divide_idx_0 < 0.0 ? -static_cast<int32_T>(static_cast<uint32_T>
      (-rtb_Divide_idx_0)) : static_cast<int32_T>(static_cast<uint32_T>
      (rtb_Divide_idx_0));

    // End of DataTypeConversion: '<S13>/Data Type Conversion5'
    if (tmp) {
      // DataTypeConversion: '<S13>/Data Type Conversion2' incorporates:
      //   Constant: '<S91>/ModelParam.GPSEphFinal'
      //   Gain: '<S13>/Gain6'

      rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain6_Gain *
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSEphFinal);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion2'
      Lifting_wing_HIL_model_dll_B.eph = static_cast<uint16_T>(rtb_Divide_idx_0 <
        0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(
        static_cast<uint16_T>(-rtb_Divide_idx_0)))) : static_cast<int32_T>(
        static_cast<uint16_T>(rtb_Divide_idx_0)));

      // DataTypeConversion: '<S13>/Data Type Conversion3' incorporates:
      //   Constant: '<S91>/ModelParam.GPSEpvFinal'
      //   Gain: '<S13>/Gain8'

      rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain8_Gain *
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSEpvFinal);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion3'
      Lifting_wing_HIL_model_dll_B.epv = static_cast<uint16_T>(rtb_Divide_idx_0 <
        0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(
        static_cast<uint16_T>(-rtb_Divide_idx_0)))) : static_cast<int32_T>(
        static_cast<uint16_T>(rtb_Divide_idx_0)));
    }

    // Sum: '<S91>/Sum3' incorporates:
    //   Product: '<S304>/Product'
    //   TransferFcn: '<S127>/Transfer Fcn1'
    //   TransferFcn: '<S127>/Transfer Fcn4'

    rtb_Integrator1_p[0] = Lifting_wing_HIL_model_dll_P.TransferFcn4_C_b *
      Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE_l +
      Lifting_wing_HIL_model_dll_B.Product[0];
    rtb_Integrator1_p[1] = Lifting_wing_HIL_model_dll_P.TransferFcn1_C_j *
      Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE_o +
      Lifting_wing_HIL_model_dll_B.Product[1];

    // MATLAB Function: '<S91>/GenCogVel' incorporates:
    //   Sum: '<S91>/Sum3'

    // MATLAB Function 'Sensor Model/GPS/GenCogVel': '<S126>:1'
    // '<S126>:1:2' v=norm(u(1:2));
    alt = 3.3121686421112381E-170;
    q = std::abs(rtb_Integrator1_p[0]);
    if (q > 3.3121686421112381E-170) {
      rtb_Switch = 1.0;
      alt = q;
    } else {
      lat = q / 3.3121686421112381E-170;
      rtb_Switch = lat * lat;
    }

    q = std::abs(rtb_Integrator1_p[1]);
    if (q > alt) {
      lat = alt / q;
      rtb_Switch = rtb_Switch * lat * lat + 1.0;
      alt = q;
    } else {
      lat = q / alt;
      rtb_Switch += lat * lat;
    }

    rtb_Switch = alt * std::sqrt(rtb_Switch);

    // '<S126>:1:4' if v < 1
    if (rtb_Switch < 1.0) {
      // '<S126>:1:5' cot = 0;
      Merge = 0.0;
    } else {
      // '<S126>:1:6' else
      // '<S126>:1:7' cot=atan2d(u(2),u(1));
      Merge = 57.295779513082323 * rt_atan2d_snf(rtb_Integrator1_p[1],
        rtb_Integrator1_p[0]);
    }

    // '<S126>:1:10' if cot<0
    if (Merge < 0.0) {
      // '<S126>:1:11' cot=cot+360;
      Merge += 360.0;
    }

    if (tmp) {
      // DataTypeConversion: '<S13>/Data Type Conversion9' incorporates:
      //   Constant: '<S91>/ModelParam_GPSFix3DFix'

      rtb_Divide_idx_0 = std::round
        (Lifting_wing_HIL_model_dll_P.ModelParam_GPSFix3DFix);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 256.0);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion9'
      Lifting_wing_HIL_model_dll_B.fix_type = static_cast<uint8_T>
        (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<uint8_T>(-
           static_cast<int8_T>(static_cast<uint8_T>(-rtb_Divide_idx_0)))) :
         static_cast<int32_T>(static_cast<uint8_T>(rtb_Divide_idx_0)));

      // DataTypeConversion: '<S13>/Data Type Conversion12' incorporates:
      //   Constant: '<S91>/ModelParam.GPSSatsVisible'

      rtb_Divide_idx_0 = std::round
        (Lifting_wing_HIL_model_dll_P.ModelParam_GPSSatsVisible);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 256.0);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion12'
      Lifting_wing_HIL_model_dll_B.satellites_visible = static_cast<uint8_T>
        (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<uint8_T>(-
           static_cast<int8_T>(static_cast<uint8_T>(-rtb_Divide_idx_0)))) :
         static_cast<int32_T>(static_cast<uint8_T>(rtb_Divide_idx_0)));
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   BusCreator: '<S13>/Bus Creator1'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.time_usec = rtb_DataTypeConversion1;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.lat = rtb_lat;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.lon = rtb_lon;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.alt = i;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.eph =
      Lifting_wing_HIL_model_dll_B.eph;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.epv =
      Lifting_wing_HIL_model_dll_B.epv;

    // DataTypeConversion: '<S13>/Data Type Conversion6' incorporates:
    //   Gain: '<S13>/Gain9'
    //   MATLAB Function: '<S91>/GenCogVel'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain9_Gain *
      rtb_Switch);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion6'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.vel = static_cast<uint16_T>
      (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Divide_idx_0)))) :
       static_cast<int32_T>(static_cast<uint16_T>(rtb_Divide_idx_0)));

    // DataTypeConversion: '<S13>/Data Type Conversion7' incorporates:
    //   Gain: '<S13>/Gain4'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain4_Gain_n *
      rtb_Integrator1_p[0]);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion7'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.vn = static_cast<int16_T>
      (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Divide_idx_0)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>
         (rtb_Divide_idx_0))));

    // DataTypeConversion: '<S13>/Data Type Conversion10' incorporates:
    //   Gain: '<S13>/Gain10'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain10_Gain *
      rtb_Integrator1_p[1]);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion10'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.ve = static_cast<int16_T>
      (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Divide_idx_0)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>
         (rtb_Divide_idx_0))));

    // DataTypeConversion: '<S13>/Data Type Conversion11' incorporates:
    //   Gain: '<S13>/Gain11'
    //   Product: '<S304>/Product'
    //   Sum: '<S91>/Sum3'
    //   TransferFcn: '<S127>/Transfer Fcn2'

    rtb_Divide_idx_0 = std::round((Lifting_wing_HIL_model_dll_P.TransferFcn2_C_o
      * Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE_j +
      Lifting_wing_HIL_model_dll_B.Product[2]) *
      Lifting_wing_HIL_model_dll_P.Gain11_Gain);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion11'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.vd = static_cast<int16_T>
      (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<int16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Divide_idx_0)))) :
       static_cast<int32_T>(static_cast<int16_T>(static_cast<uint16_T>
         (rtb_Divide_idx_0))));

    // DataTypeConversion: '<S13>/Data Type Conversion8' incorporates:
    //   Gain: '<S13>/Gain2'
    //   MATLAB Function: '<S91>/GenCogVel'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain2_Gain_p *
      Merge);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 65536.0);
    }

    // Outport: '<Root>/MavHILGPS' incorporates:
    //   BusCreator: '<S13>/Bus Creator1'
    //   DataTypeConversion: '<S13>/Data Type Conversion8'

    Lifting_wing_HIL_model_dll_Y.MavHILGPS.cog = static_cast<uint16_T>
      (rtb_Divide_idx_0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-
         static_cast<int16_T>(static_cast<uint16_T>(-rtb_Divide_idx_0)))) :
       static_cast<int32_T>(static_cast<uint16_T>(rtb_Divide_idx_0)));
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.fix_type =
      Lifting_wing_HIL_model_dll_B.fix_type;
    Lifting_wing_HIL_model_dll_Y.MavHILGPS.satellites_visible =
      Lifting_wing_HIL_model_dll_B.satellites_visible;
    if (tmp) {
      // DataTypeConversion: '<S13>/Data Type Conversion13' incorporates:
      //   Constant: '<S91>/ModelParam.GPSEphFinal'
      //   Gain: '<S13>/Gain5'

      rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain5_Gain_e *
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSEphFinal);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion13'
      Lifting_wing_HIL_model_dll_B.hAcc = rtb_Divide_idx_0 < 0.0 ?
        static_cast<uint32_T>(-static_cast<int32_T>(static_cast<uint32_T>
        (-rtb_Divide_idx_0))) : static_cast<uint32_T>(rtb_Divide_idx_0);

      // DataTypeConversion: '<S13>/Data Type Conversion14' incorporates:
      //   Constant: '<S91>/ModelParam.GPSEpvFinal'
      //   Gain: '<S13>/Gain7'

      rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain7_Gain_g *
        Lifting_wing_HIL_model_dll_P.ModelParam_GPSEpvFinal);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
      }

      // DataTypeConversion: '<S13>/Data Type Conversion14'
      Lifting_wing_HIL_model_dll_B.vAcc = rtb_Divide_idx_0 < 0.0 ?
        static_cast<uint32_T>(-static_cast<int32_T>(static_cast<uint32_T>
        (-rtb_Divide_idx_0))) : static_cast<uint32_T>(rtb_Divide_idx_0);
    }

    // MATLAB Function: '<S91>/-pi-pi---->0-2pi'
    // //rad
    // MATLAB Function 'Sensor Model/GPS/-pi-pi---->0-2pi': '<S124>:1'
    // '<S124>:1:3' if yaw180>0
    if (rtb_Lw_idx_1 > 0.0) {
      // '<S124>:1:4' yaw360 = yaw180;
      alt = rtb_Lw_idx_1;
    } else {
      // '<S124>:1:5' else
      // '<S124>:1:6' yaw360 = yaw180 +2*pi;
      alt = rtb_Lw_idx_1 + 6.2831853071795862;
    }

    // End of MATLAB Function: '<S91>/-pi-pi---->0-2pi'

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   BusCreator: '<S13>/Bus Creator2'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.fix_type =
      Lifting_wing_HIL_model_dll_B.fix_type;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.satellites_visible =
      Lifting_wing_HIL_model_dll_B.satellites_visible;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.lat = rtb_lat;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.lon = rtb_lon;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.alt = i;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.hAcc =
      Lifting_wing_HIL_model_dll_B.hAcc;
    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.vAcc =
      Lifting_wing_HIL_model_dll_B.vAcc;

    // DataTypeConversion: '<S13>/Data Type Conversion17' incorporates:
    //   Gain: '<S13>/Gain12'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain12_Gain *
      Lifting_wing_HIL_model_dll_B.Product[0]);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion17'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.velN = rtb_Divide_idx_0 < 0.0 ? -
      static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // DataTypeConversion: '<S13>/Data Type Conversion15' incorporates:
    //   Gain: '<S13>/Gain13'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain13_Gain *
      Lifting_wing_HIL_model_dll_B.Product[1]);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion15'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.velE = rtb_Divide_idx_0 < 0.0 ? -
      static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // DataTypeConversion: '<S13>/Data Type Conversion16' incorporates:
    //   Gain: '<S13>/Gain14'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain14_Gain *
      Lifting_wing_HIL_model_dll_B.Product[2]);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion16'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.velD = rtb_Divide_idx_0 < 0.0 ? -
      static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // DataTypeConversion: '<S13>/Data Type Conversion18' incorporates:
    //   Gain: '<S13>/Gain15'
    //   MATLAB Function: '<S91>/GenCogVel'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain15_Gain *
      rtb_Switch);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion18'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.gSpeed = rtb_Divide_idx_0 < 0.0 ?
      -static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // DataTypeConversion: '<S13>/Data Type Conversion19' incorporates:
    //   Gain: '<S13>/Gain16'
    //   MATLAB Function: '<S91>/GenCogVel'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain16_Gain *
      Merge);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion19'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.headMot = rtb_Divide_idx_0 < 0.0 ?
      -static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

    // DataTypeConversion: '<S13>/Data Type Conversion20' incorporates:
    //   Gain: '<S13>/Gain17'

    rtb_Divide_idx_0 = std::round(Lifting_wing_HIL_model_dll_P.Gain17_Gain * alt);
    if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
      rtb_Divide_idx_0 = 0.0;
    } else {
      rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
    }

    // Outport: '<Root>/PXIHILGPSData' incorporates:
    //   DataTypeConversion: '<S13>/Data Type Conversion20'

    Lifting_wing_HIL_model_dll_Y.PXIHILGPSData.headVeh = rtb_Divide_idx_0 < 0.0 ?
      -static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
      static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));
    if (tmp) {
      // DataTypeConversion: '<S16>/Data Type Conversion' incorporates:
      //   Constant: '<S16>/CopterID'

      rtb_Divide_idx_0 = std::floor(Lifting_wing_HIL_model_dll_P.CopterID_Value);
      if (std::isnan(rtb_Divide_idx_0) || std::isinf(rtb_Divide_idx_0)) {
        rtb_Divide_idx_0 = 0.0;
      } else {
        rtb_Divide_idx_0 = std::fmod(rtb_Divide_idx_0, 4.294967296E+9);
      }

      // DataTypeConversion: '<S16>/Data Type Conversion'
      Lifting_wing_HIL_model_dll_B.copterID = rtb_Divide_idx_0 < 0.0 ? -
        static_cast<int32_T>(static_cast<uint32_T>(-rtb_Divide_idx_0)) :
        static_cast<int32_T>(static_cast<uint32_T>(rtb_Divide_idx_0));

      // DataTypeConversion: '<S16>/Data Type Conversion1' incorporates:
      //   Constant: '<S16>/UAVType'

      Lifting_wing_HIL_model_dll_B.vehicleType =
        Lifting_wing_HIL_model_dll_P.ModelParam_uavType;
    }

    // Sum: '<S51>/Add'
    rtb_lon = 0;

    // DataTypeConversion: '<S16>/Data Type Conversion3' incorporates:
    //   Product: '<S304>/Product'

    x = static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Product[0]);
    rtb_AngQuatern_idx_1 = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Product[1]);
    rtb_AngQuatern_idx_2 = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Product[2]);

    // Sum: '<S51>/Add' incorporates:
    //   Math: '<S7>/Transpose'

    Merge = (Comega[0] + Comega[4]) + Comega[8];

    // If: '<S47>/If' incorporates:
    //   Math: '<S7>/Transpose'

    rtPrevAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_a;
    if (tmp_0) {
      rtAction = static_cast<int8_T>(!(Merge > 0.0));
      Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_a = rtAction;
    } else {
      rtAction = Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_a;
    }

    if (rtPrevAction != rtAction) {
      rtsiSetBlockStateForSolverChangedAtMajorStep
        (&(&Lifting_wing_HIL_model_dll_M)->solverInfo, true);
    }

    if (rtAction == 0) {
      // Outputs for IfAction SubSystem: '<S47>/Positive Trace' incorporates:
      //   ActionPort: '<S49>/Action Port'

      Lifting_wing_HIL__PositiveTrace(Merge, Comega,
        Lifting_wing_HIL_model_dll_B.Merge_k,
        &Lifting_wing_HIL_model_dll_P.PositiveTrace);

      // End of Outputs for SubSystem: '<S47>/Positive Trace'
    } else {
      // Outputs for IfAction SubSystem: '<S47>/Negative Trace' incorporates:
      //   ActionPort: '<S48>/Action Port'

      Lifting_wing_HIL__NegativeTrace(Comega,
        Lifting_wing_HIL_model_dll_B.Merge_k,
        &Lifting_wing_HIL_model_dll_DW.NegativeTrace,
        &Lifting_wing_HIL_model_dll_P.NegativeTrace);

      // End of Outputs for SubSystem: '<S47>/Negative Trace'
    }

    if (tmp) {
      // DataTypeConversion: '<S16>/Data Type Conversion7' incorporates:
      //   Constant: '<S7>/Constant'
      //   Gain: '<S16>/Gain'
      //   Gain: '<S16>/Gain1'

      Lifting_wing_HIL_model_dll_B.MotorRPMS[0] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain_Gain_g *
         Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[1] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain_Gain_g *
         Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[2] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain_Gain_g *
         Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[3] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain_Gain_g *
         Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[4] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain1_Gain_m *
         Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_g.Aa);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[5] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain1_Gain_m *
         Lifting_wing_HIL_model_dll_B.sf_MATLABFunction_i.Aa);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[6] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain1_Gain_m *
         Lifting_wing_HIL_model_dll_P.Constant_Value_c[0]);
      Lifting_wing_HIL_model_dll_B.MotorRPMS[7] = static_cast<real32_T>
        (Lifting_wing_HIL_model_dll_P.Gain1_Gain_m *
         Lifting_wing_HIL_model_dll_P.Constant_Value_c[1]);
    }

    // Outport: '<Root>/MavVehile3DInfo' incorporates:
    //   BusCreator generated from: '<Root>/MavVehile3DInfo'
    //   DataTypeConversion: '<S16>/Data Type Conversion4'
    //   DataTypeConversion: '<S16>/Data Type Conversion5'
    //   DataTypeConversion: '<S16>/Data Type Conversion6'
    //   DataTypeConversion: '<S16>/Data Type Conversion8'
    //   DataTypeConversion: '<S16>/Data Type Conversion9'
    //   Integrator: '<S295>/p,q,r '
    //   Integrator: '<S295>/xe,ye,ze'
    //   Sum: '<S295>/Sum'

    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.copterID =
      Lifting_wing_HIL_model_dll_B.copterID;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.vehicleType =
      Lifting_wing_HIL_model_dll_B.vehicleType;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.runnedTime =
      rtb_DataTypeConversion1_tmp_tmp;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.VelE[0] = x;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosE[0] = static_cast<real32_T>
      (rtb_sincos_o1[0]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.VelE[1] = rtb_AngQuatern_idx_1;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosE[1] = static_cast<real32_T>
      (rtb_sincos_o1[1]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.VelE[2] = rtb_AngQuatern_idx_2;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosE[2] = static_cast<real32_T>
      (rtb_sincos_o1[2]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngEuler[0] =
      static_cast<real32_T>(rtb_VectorConcatenate_a_idx_2);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngEuler[1] =
      static_cast<real32_T>(rtb_VectorConcatenate_a_idx_1);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngEuler[2] =
      static_cast<real32_T>(rtb_Lw_idx_1);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngQuatern[0] =
      static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Merge_k[0]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngQuatern[1] =
      static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Merge_k[1]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngQuatern[2] =
      static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Merge_k[2]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AngQuatern[3] =
      static_cast<real32_T>(Lifting_wing_HIL_model_dll_B.Merge_k[3]);
    for (i = 0; i < 8; i++) {
      Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.MotorRPMS[i] =
        Lifting_wing_HIL_model_dll_B.MotorRPMS[i];
    }

    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AccB[0] = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Sum_p[0]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.RateB[0] = static_cast<real32_T>
      (rtb_Product_d[0]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosGPS[0] = fphi;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AccB[1] = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Sum_p[1]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.RateB[1] = static_cast<real32_T>
      (rtb_Product_d[1]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosGPS[1] = rtb_q3dot;
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.AccB[2] = static_cast<real32_T>
      (Lifting_wing_HIL_model_dll_B.Sum_p[2]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.RateB[2] = static_cast<real32_T>
      (rtb_Product_d[2]);
    Lifting_wing_HIL_model_dll_Y.MavVehile3DInfo.PosGPS[2] = rtb_Gain7;

    // End of Outport: '<Root>/MavVehile3DInfo'
    if (tmp) {
      for (i = 0; i < 20; i++) {
        // DataTypeConversion: '<Root>/Data Type Conversion1' incorporates:
        //   Inport: '<Root>/inFloatsCollision'

        DataTypeConversion1[i] =
          Lifting_wing_HIL_model_dll_U.inFloatsCollision[i];
      }

      // MATLAB Function: '<Root>/CollisionDetection' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Constant: '<Root>/uavMass'
      //   Product: '<S304>/Product'

      //  vect=[1;1;1;1;1;1;1;1];
      // 
      // MATLAB Function 'CollisionDetection': '<S1>:1'
      // '<S1>:1:6' if isempty(isCol)
      // 
      // '<S1>:1:12' if isempty(fOut)
      // 
      // '<S1>:1:18' if isempty(mv0)
      // 
      // '<S1>:1:24' if isempty(tColi)
      // 
      // '<S1>:1:29' if isCol < 0.5
      if ((Lifting_wing_HIL_model_dll_DW.isCol < 0.5) && (std::abs
           (DataTypeConversion1[5] - 12345.0) < 1.0) && (DataTypeConversion1[6] >
           0.5)) {
        // CopterID0
        // '<S1>:1:31' if abs(uFloats(6) - 12345) < 1 && uFloats(7) > 0.5
        // 12345uFloats(7)ID
        // '<S1>:1:32' isCol = int8(1);
        Lifting_wing_HIL_model_dll_DW.isCol = 1;

        // 
        // 
        // '<S1>:1:34' if uFloats(11) > 0
        if (DataTypeConversion1[10] > 0.0) {
          // 
          // '<S1>:1:35' massOb = mass * uFloats(11) ^ 2;
          Merge = DataTypeConversion1[10] * DataTypeConversion1[10] *
            Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;

          // '<S1>:1:36' veOb = uFloats(12 : 14);
          // '<S1>:1:37' veNew = (mass * ve + massOb * veOb) / (mass + massOb);
          rtb_Switch = Lifting_wing_HIL_model_dll_P.ModelParam_uavMass + Merge;
          Lifting_wing_HIL_model_dll_DW.mv0[0] =
            (Lifting_wing_HIL_model_dll_P.ModelParam_uavMass *
             Lifting_wing_HIL_model_dll_B.Product[0] + Merge *
             DataTypeConversion1[11]) / rtb_Switch;
          Lifting_wing_HIL_model_dll_DW.mv0[1] =
            (Lifting_wing_HIL_model_dll_P.ModelParam_uavMass *
             Lifting_wing_HIL_model_dll_B.Product[1] + Merge *
             DataTypeConversion1[12]) / rtb_Switch;
          Lifting_wing_HIL_model_dll_DW.mv0[2] =
            (Lifting_wing_HIL_model_dll_P.ModelParam_uavMass *
             Lifting_wing_HIL_model_dll_B.Product[2] + Merge *
             DataTypeConversion1[13]) / rtb_Switch;
        } else {
          // '<S1>:1:38' else
          // 1/10 
          // '<S1>:1:39' veNew = -ve / 10.0;
          Lifting_wing_HIL_model_dll_DW.mv0[0] =
            -Lifting_wing_HIL_model_dll_B.Product[0] / 10.0;
          Lifting_wing_HIL_model_dll_DW.mv0[1] =
            -Lifting_wing_HIL_model_dll_B.Product[1] / 10.0;
          Lifting_wing_HIL_model_dll_DW.mv0[2] =
            -Lifting_wing_HIL_model_dll_B.Product[2] / 10.0;
        }

        // '<S1>:1:42' mv0 = mass * (veNew - ve);
        Lifting_wing_HIL_model_dll_DW.mv0[0] =
          (Lifting_wing_HIL_model_dll_DW.mv0[0] -
           Lifting_wing_HIL_model_dll_B.Product[0]) *
          Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
        Lifting_wing_HIL_model_dll_DW.mv0[1] =
          (Lifting_wing_HIL_model_dll_DW.mv0[1] -
           Lifting_wing_HIL_model_dll_B.Product[1]) *
          Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;
        Lifting_wing_HIL_model_dll_DW.mv0[2] =
          (Lifting_wing_HIL_model_dll_DW.mv0[2] -
           Lifting_wing_HIL_model_dll_B.Product[2]) *
          Lifting_wing_HIL_model_dll_P.ModelParam_uavMass;

        // '<S1>:1:43' tColi = t;
        Lifting_wing_HIL_model_dll_DW.tColi = rtb_DataTypeConversion1_tmp_tmp;

        // 
      }

      // 
      // '<S1>:1:48' if isCol >= 0.5
      if ((Lifting_wing_HIL_model_dll_DW.isCol >= 0.5) &&
          (!(rtb_DataTypeConversion1_tmp_tmp -
             Lifting_wing_HIL_model_dll_DW.tColi > 0.05))) {
        // '<S1>:1:49' if (t - tColi) > 0.05
        // '<S1>:1:51' else
        // 0.05s
        // '<S1>:1:53' mv = DCM * mv0;
        // '<S1>:1:54' mv(1) = mv(1) * (0.7 + 0.3 * rand());
        Lifting_wing_HIL_model_dll_rand();

        // '<S1>:1:55' mv(2) = mv(2) * (0.7 + 0.3 * rand());
        Lifting_wing_HIL_model_dll_rand();

        // '<S1>:1:56' mv(3) = mv(3) * (0.7 + 0.3 * rand());
        Lifting_wing_HIL_model_dll_rand();

        // '<S1>:1:57' fOut(1 : 3) = mv / 0.05;
        // 
        // '<S1>:1:58' fOut(4 : 6) = rand(3, 1) * mass;
        Lifting_wing_HIL_model_d_rand_o(rtb_TmpSignalConversionAtSFunct);
      } else {
        // '<S1>:1:50' fOut = [0; 0; 0; 0; 0; 0];
      }

      // 
      // '<S1>:1:63' fm = fOut;
      // tzXYZ
      // '<S1>:1:65' tz = [100; 0; 0; 0];
      rtb_Sum_o = 100.0;
      rtb_q3dot = 0.0;

      // '<S1>:1:66' ddm = [0; 0; 0; 0; 0; 0];
      // '<S1>:1:67' if abs(uFloats(6) - 12345) < 1
      if (std::abs(DataTypeConversion1[5] - 12345.0) < 1.0) {
        // 
        // '<S1>:1:68' kRa = 40;
        // '<S1>:1:69' kRaVe = 5;
        // '<S1>:1:70' if uFloats(7) < 0.5
        if (DataTypeConversion1[6] < 0.5) {
          // 
          // 
          // '<S1>:1:72' tz(1) = uFloats(20);
          rtb_Sum_o = DataTypeConversion1[19];

          // UE4
          // '<S1>:1:74' tz(2 : 4) = uFloats(8 : 10);
          rtb_q3dot = DataTypeConversion1[9];
        } else {
          // '<S1>:1:75' else
          // '<S1>:1:76' kRa = 20;
        }

        // 
        // 
        // '<S1>:1:80' if uFloats(15) < 0
        // 
        // '<S1>:1:85' if uFloats(16) < 0
        // 
        // '<S1>:1:90' if uFloats(17) < 0
        // 
        // '<S1>:1:95' if uFloats(18) < 0
        // 
        // '<S1>:1:100' if uFloats(19) < 0
        // 
        //      if uFloats(20) < 0
        //          z = uFloats(20);
        //          ddm(3) = -mass*9.8-collision_force(z, ve(3));
        //      end
      }

      // End of MATLAB Function: '<Root>/CollisionDetection'

      // MATLAB Function: '<Root>/MATLAB Function' incorporates:
      //   Inport: '<Root>/TerrainZ'

      // 
      // '<S1>:1:112' ddmm = DCM * ddm(1 : 3);
      // '<S1>:1:113' fm = fm + [ddmm; 0; 0; 0];
      // '<S1>:1:115' isCrash = isCol;
      Merge = Lifting_wing_HIL_model_dll_U.TerrainZ;

      // MATLAB Function 'MATLAB Function': '<S2>:1'
      // '<S2>:1:5' if isempty(lastZ)
      // '<S2>:1:8' y=TerrainZ;
      // '<S2>:1:9' if tz(1)<=99
      if (rtb_Sum_o <= 99.0) {
        // '<S2>:1:10' y=tz(4)+tz(1);
        Merge = rtb_Sum_o + rtb_q3dot;
      }

      // '<S2>:1:13' lastZ=0.6*lastZ+0.4*y;
      Lifting_wing_HIL_model_dll_DW.lastZ = 0.6 *
        Lifting_wing_HIL_model_dll_DW.lastZ + 0.4 * Merge;

      // End of MATLAB Function: '<Root>/MATLAB Function'
      // '<S2>:1:14' yy=lastZ;
      //  persistent last;
      //  if isempty(last)
      //      last=TerrainZ;
      //  end
      //  y=TerrainZ;
      //  if tz(1)<10
      //      if tz(1)<0
      //          y=last;
      //      else
      //          y=tz(3)+tz(1);
      //      end
      //  end
    }

    // Saturate: '<Root>/Saturation' incorporates:
    //   Inport: '<Root>/inPWMs'

    for (i = 0; i < 16; i++) {
      lat = Lifting_wing_HIL_model_dll_U.inPWMs[i];
      if (lat > Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_n) {
        rtb_Saturation[i] = Lifting_wing_HIL_model_dll_P.Saturation_UpperSat_n;
      } else if (lat < Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_h) {
        rtb_Saturation[i] = Lifting_wing_HIL_model_dll_P.Saturation_LowerSat_h;
      } else {
        rtb_Saturation[i] = lat;
      }
    }

    // End of Saturate: '<Root>/Saturation'

    // MATLAB Function: '<Root>/MATLAB Function2' incorporates:
    //   Inport: '<Root>/inSILFloats'

    for (i = 0; i < 6; i++) {
      rtb_Signal_Saturation_7[i] = rtb_Saturation[i];
    }

    // MATLAB Function 'MATLAB Function2': '<S4>:1'
    // '<S4>:1:3' x = inSILFloats(2)/10;
    x = Lifting_wing_HIL_model_dll_U.inSILFloats[1] / 10.0F;

    // '<S4>:1:4' if x > 1
    if (x > 1.0F) {
      // '<S4>:1:5' x = single(1);
      x = 1.0F;
    } else if (x < 0.0F) {
      // '<S4>:1:6' elseif x < 0
      // '<S4>:1:7' x = single(0);
      x = 0.0F;
    }

    // '<S4>:1:10' if inSILFloats(1) == 1
    if (Lifting_wing_HIL_model_dll_U.inSILFloats[0] == 1.0F) {
      // '<S4>:1:11' u(1) = x*u(1);
      rtb_Signal_Saturation_7[0] = x * static_cast<real32_T>(rtb_Saturation[0]);
    } else if (Lifting_wing_HIL_model_dll_U.inSILFloats[0] == 2.0F) {
      // '<S4>:1:12' elseif inSILFloats(1) == 2
      // '<S4>:1:13' u(1) = x*u(1);
      rtb_Signal_Saturation_7[0] = x * static_cast<real32_T>(rtb_Saturation[0]);

      // '<S4>:1:14' u(2) = x*u(2);
      rtb_Signal_Saturation_7[1] = x * static_cast<real32_T>(rtb_Saturation[1]);
    } else if (Lifting_wing_HIL_model_dll_U.inSILFloats[0] >= 3.0F) {
      // '<S4>:1:15' elseif inSILFloats(1) >= 3
      // '<S4>:1:16' u(1) = x*u(1);
      rtb_Signal_Saturation_7[0] = x * static_cast<real32_T>(rtb_Saturation[0]);

      // '<S4>:1:17' u(2) = x*u(2);
      rtb_Signal_Saturation_7[1] = x * static_cast<real32_T>(rtb_Saturation[1]);

      // '<S4>:1:18' u(3) = x*u(3);
      rtb_Signal_Saturation_7[2] = x * static_cast<real32_T>(rtb_Saturation[2]);
    }

    // End of MATLAB Function: '<Root>/MATLAB Function2'
    // '<S4>:1:21' y = u;
    if (tmp) {
      // MATLAB Function: '<S12>/Model Fail Assessment' incorporates:
      //   Constant: '<S12>/ModelFailEnable'
      //   Integrator: '<S295>/p,q,r '
      //   Integrator: '<S295>/xe,ye,ze'
      //   Product: '<S304>/Product'
      //   SignalConversion generated from: '<S17>/ SFunction '

      // MATLAB Function 'Mav HIL/EnvironmentModel/Model Fail Assessment': '<S17>:1' 
      // '<S17>:1:4' if isempty(xTemp)
      // '<S17>:1:9' if isempty(kk)
      // '<S17>:1:14' if isempty(ss)
      // '<S17>:1:18' if ~ModelFailEnable&&(kk<0.5)
      if ((!Lifting_wing_HIL_model_dll_P.ModelFailEnable) &&
          (Lifting_wing_HIL_model_dll_DW.kk < 0.5)) {
        // '<S17>:1:19' xTemp=zeros(8,1);
        std::memset(&Lifting_wing_HIL_model_dll_DW.xTemp[0], 0, sizeof(real_T) <<
                    3U);

        // '<S17>:1:20' kk=0;
        Lifting_wing_HIL_model_dll_DW.kk = 0.0;

        // '<S17>:1:21' ss=[xe;ang];
        Lifting_wing_HIL_model_dll_DW.ss[0] = rtb_sincos_o1[0];
        Lifting_wing_HIL_model_dll_DW.ss[3] = rtb_VectorConcatenate_a_idx_2;
        Lifting_wing_HIL_model_dll_DW.ss[1] = rtb_sincos_o1[1];
        Lifting_wing_HIL_model_dll_DW.ss[4] = rtb_VectorConcatenate_a_idx_1;
        Lifting_wing_HIL_model_dll_DW.ss[2] = rtb_sincos_o1[2];
        Lifting_wing_HIL_model_dll_DW.ss[5] = rtb_Lw_idx_1;
      }

      // '<S17>:1:24' if ModelFailEnable&&~landed
      if (Lifting_wing_HIL_model_dll_P.ModelFailEnable && (BusCreator_landed ==
           0)) {
        // '<S17>:1:25' xTemp(1:4,1)=[norm(xe-ss(1:3,1));norm(ve);norm(ang-ss(4:6,1));norm(wb)]; 
        BusCreator_mag_e[0] = rtb_sincos_o1[0] -
          Lifting_wing_HIL_model_dll_DW.ss[0];
        rtb_TmpSignalConversionAtSFunct[0] = rtb_VectorConcatenate_a_idx_2 -
          Lifting_wing_HIL_model_dll_DW.ss[3];
        BusCreator_mag_e[1] = rtb_sincos_o1[1] -
          Lifting_wing_HIL_model_dll_DW.ss[1];
        rtb_TmpSignalConversionAtSFunct[1] = rtb_VectorConcatenate_a_idx_1 -
          Lifting_wing_HIL_model_dll_DW.ss[4];
        BusCreator_mag_e[2] = rtb_sincos_o1[2] -
          Lifting_wing_HIL_model_dll_DW.ss[2];
        rtb_TmpSignalConversionAtSFunct[2] = rtb_Lw_idx_1 -
          Lifting_wing_HIL_model_dll_DW.ss[5];
        Lifting_wing_HIL_model_dll_DW.xTemp[0] = Lifting_wing_HIL_model_dll_norm
          (BusCreator_mag_e);
        Lifting_wing_HIL_model_dll_DW.xTemp[1] = Lifting_wing_HIL_model_dll_norm
          (Lifting_wing_HIL_model_dll_B.Product);
        Lifting_wing_HIL_model_dll_DW.xTemp[2] = Lifting_wing_HIL_model_dll_norm
          (rtb_TmpSignalConversionAtSFunct);
        Lifting_wing_HIL_model_dll_DW.xTemp[3] = Lifting_wing_HIL_model_dll_norm
          (rtb_Product_d);

        // '<S17>:1:26' xTemp(5:8,1)= (xTemp(5:8,1)*kk+xTemp(1:4,1))/(kk+1);
        Lifting_wing_HIL_model_dll_DW.xTemp[4] =
          (Lifting_wing_HIL_model_dll_DW.xTemp[4] *
           Lifting_wing_HIL_model_dll_DW.kk +
           Lifting_wing_HIL_model_dll_DW.xTemp[0]) /
          (Lifting_wing_HIL_model_dll_DW.kk + 1.0);
        Lifting_wing_HIL_model_dll_DW.xTemp[5] =
          (Lifting_wing_HIL_model_dll_DW.xTemp[5] *
           Lifting_wing_HIL_model_dll_DW.kk +
           Lifting_wing_HIL_model_dll_DW.xTemp[1]) /
          (Lifting_wing_HIL_model_dll_DW.kk + 1.0);
        Lifting_wing_HIL_model_dll_DW.xTemp[6] =
          (Lifting_wing_HIL_model_dll_DW.xTemp[6] *
           Lifting_wing_HIL_model_dll_DW.kk +
           Lifting_wing_HIL_model_dll_DW.xTemp[2]) /
          (Lifting_wing_HIL_model_dll_DW.kk + 1.0);
        Lifting_wing_HIL_model_dll_DW.xTemp[7] =
          (Lifting_wing_HIL_model_dll_DW.xTemp[7] *
           Lifting_wing_HIL_model_dll_DW.kk +
           Lifting_wing_HIL_model_dll_DW.xTemp[3]) /
          (Lifting_wing_HIL_model_dll_DW.kk + 1.0);

        // '<S17>:1:28' kk=kk+1;
        Lifting_wing_HIL_model_dll_DW.kk++;
      }

      // End of MATLAB Function: '<S12>/Model Fail Assessment'

      // If: '<S50>/If1' incorporates:
      //   Constant: '<S50>/Constant'
      //   Math: '<S7>/Transpose'

      // landed = int8(0);
      // '<S17>:1:32' FailInfo=xTemp;
      rtAction = -1;
      if (tmp_0) {
        if (Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuater_a > 1) {
          rtAction = 0;
        }

        Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem = rtAction;
      } else {
        rtAction = Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem;
      }

      if (rtAction == 0) {
        // Outputs for IfAction SubSystem: '<S50>/If Warning//Error' incorporates:
        //   ActionPort: '<S74>/if'

        Lifting_wing_HIL_IfWarningError(Comega,
          Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuater_a,
          Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuaterni,
          &Lifting_wing_HIL_model_dll_P.IfWarningError);

        // End of Outputs for SubSystem: '<S50>/If Warning//Error'
      }
    }

    if (rEQ0) {
      // RandomNumber: '<S89>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_g[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_g[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_g[2];
    }

    // Gain: '<S100>/2*zeta * wn'
    rtb_Gain7 = 2.0 * Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_z_a *
      Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_w_a;

    // Gain: '<S100>/wn^2'
    Merge = Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_w_a *
      Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer0_w_a;

    // Sum: '<S100>/Sum2' incorporates:
    //   Gain: '<S100>/2*zeta * wn'
    //   Gain: '<S100>/wn^2'
    //   Sum: '<S100>/Sum3'

    Lifting_wing_HIL_model_dll_B.Sum2[0] = (rtb_Fp[0] -
      rtb_IntegratorSecondOrderLimite[0]) * Merge - rtb_Gain7 *
      rtb_IntegratorSecondOrderLimi_2;

    // SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'
    rtb_Integrator1_p[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[0];

    // Sum: '<S100>/Sum2' incorporates:
    //   Gain: '<S100>/2*zeta * wn'
    //   Gain: '<S100>/wn^2'
    //   Sum: '<S100>/Sum3'

    Lifting_wing_HIL_model_dll_B.Sum2[1] = (rtb_Fp[1] -
      rtb_IntegratorSecondOrderLimite[1]) * Merge - rtb_Gain7 *
      rtb_IntegratorSecondOrderLimi_1;

    // SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'
    rtb_Integrator1_p[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[1];

    // Sum: '<S100>/Sum2' incorporates:
    //   Gain: '<S100>/2*zeta * wn'
    //   Gain: '<S100>/wn^2'
    //   Sum: '<S100>/Sum3'

    Lifting_wing_HIL_model_dll_B.Sum2[2] = (rtb_Fp[2] -
      rtb_IntegratorSecondOrderLimite[2]) * Merge - rtb_Gain7 *
      rtb_IntegratorSecondOrderLimi_0;

    // SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'
    rtb_Integrator1_p[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[2];

    // Gain: '<S113>/2*zeta * wn' incorporates:
    //   SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'

    rtb_Gain7 = 2.0 * Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_z_a *
      Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_w_a;
    rtb_IntegratorSecondOrderLimite[0] = rtb_Gain7 *
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[3];

    // Gain: '<S95>/Zero-Order Hold2'
    rtb_IntegratorSecondOrderLimi_2 =
      Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain_k * rtb_Fa[0];

    // Gain: '<S95>/Zero-Order Hold'
    rtb_Fp[0] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i *
      rtb_Product_d[0];

    // Gain: '<S113>/2*zeta * wn' incorporates:
    //   SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'

    rtb_IntegratorSecondOrderLimite[1] = rtb_Gain7 *
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[4];

    // Gain: '<S95>/Zero-Order Hold2'
    rtb_IntegratorSecondOrderLimi_1 =
      Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain_k * rtb_Fa[1];

    // Gain: '<S95>/Zero-Order Hold'
    rtb_Fp[1] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i *
      rtb_Product_d[1];

    // Gain: '<S113>/2*zeta * wn' incorporates:
    //   SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited'

    rtb_IntegratorSecondOrderLimite[2] = rtb_Gain7 *
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[5];

    // Gain: '<S95>/Zero-Order Hold2'
    rtb_IntegratorSecondOrderLimi_0 =
      Lifting_wing_HIL_model_dll_P.ZeroOrderHold2_Gain_k * rtb_Fa[2];

    // Gain: '<S95>/Zero-Order Hold'
    rtb_Fp[2] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i *
      rtb_Product_d[2];
    if (tmp) {
      // Gain: '<S95>/Gain' incorporates:
      //   Constant: '<S89>/CG_Acc1'
      //   Constant: '<S95>/wl_ins'
      //   Gain: '<S95>/Zero-Order Hold4'
      //   Sum: '<S95>/Sum7'

      Lifting_wing_HIL_model_dll_B.Gain_l[0] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain_g *
         Lifting_wing_HIL_model_dll_P.CG_Acc1_Value[0] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_acc[0]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_bv[0];
      Lifting_wing_HIL_model_dll_B.Gain_l[1] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain_g *
         Lifting_wing_HIL_model_dll_P.CG_Acc1_Value[1] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_acc[1]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_bv[1];
      Lifting_wing_HIL_model_dll_B.Gain_l[2] =
        (Lifting_wing_HIL_model_dll_P.ZeroOrderHold4_Gain_g *
         Lifting_wing_HIL_model_dll_P.CG_Acc1_Value[2] -
         Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_acc[2]) *
        Lifting_wing_HIL_model_dll_P.Gain_Gain_bv[2];
    }

    // Sum: '<S115>/Sum' incorporates:
    //   Product: '<S118>/i x j'
    //   Product: '<S118>/j x k'
    //   Product: '<S118>/k x i'
    //   Product: '<S119>/i x k'
    //   Product: '<S119>/j x i'
    //   Product: '<S119>/k x j'

    rtb_Fa[0] = rtb_Fp[1] * Lifting_wing_HIL_model_dll_B.Gain_l[2] -
      Lifting_wing_HIL_model_dll_B.Gain_l[1] * rtb_Fp[2];
    rtb_Fa[1] = Lifting_wing_HIL_model_dll_B.Gain_l[0] * rtb_Fp[2] - rtb_Fp[0] *
      Lifting_wing_HIL_model_dll_B.Gain_l[2];
    rtb_Fa[2] = rtb_Fp[0] * Lifting_wing_HIL_model_dll_B.Gain_l[1] -
      Lifting_wing_HIL_model_dll_B.Gain_l[0] * rtb_Fp[1];

    // Sum: '<S114>/Sum' incorporates:
    //   Product: '<S116>/i x j'
    //   Product: '<S116>/j x k'
    //   Product: '<S116>/k x i'
    //   Product: '<S117>/i x k'
    //   Product: '<S117>/j x i'
    //   Product: '<S117>/k x j'

    rtb_sincos_o1[0] = rtb_Fp[1] * rtb_Fa[2] - rtb_Fa[1] * rtb_Fp[2];
    rtb_sincos_o1[1] = rtb_Fa[0] * rtb_Fp[2] - rtb_Fp[0] * rtb_Fa[2];
    rtb_sincos_o1[2] = rtb_Fp[0] * rtb_Fa[1] - rtb_Fa[0] * rtb_Fp[1];

    // Gain: '<S95>/Zero-Order Hold3'
    rtb_Fa[0] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain_g *
      Lifting_wing_HIL_model_dll_B.Product2[0];
    rtb_Fa[1] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain_g *
      Lifting_wing_HIL_model_dll_B.Product2[1];
    rtb_Fa[2] = Lifting_wing_HIL_model_dll_P.ZeroOrderHold3_Gain_g *
      Lifting_wing_HIL_model_dll_B.Product2[2];

    // Gain: '<S113>/wn^2'
    rtb_Gain7 = Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_w_a *
      Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_w_a;

    // Product: '<S95>/Product' incorporates:
    //   Gain: '<S95>/Zero-Order Hold1'
    //   Product: '<S120>/i x j'
    //   Product: '<S120>/j x k'
    //   Product: '<S120>/k x i'
    //   Product: '<S121>/i x k'
    //   Product: '<S121>/j x i'
    //   Product: '<S121>/k x j'
    //   Sum: '<S111>/Sum'
    //   Sum: '<S95>/Sum'

    rtb_Lw_idx_0 = ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain_g *
                     rtb_Sum4_h[1] - rtb_IntegratorSecondOrderLimi_1) +
                    rtb_sincos_o1[1]) + (Lifting_wing_HIL_model_dll_B.Gain_l[0] *
      rtb_Fa[2] - rtb_Fa[0] * Lifting_wing_HIL_model_dll_B.Gain_l[2]);
    rtb_IntegratorSecondOrderLimi_2 =
      ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain_g * rtb_Sum4_h[0] -
        rtb_IntegratorSecondOrderLimi_2) + rtb_sincos_o1[0]) + (rtb_Fa[1] *
      Lifting_wing_HIL_model_dll_B.Gain_l[2] -
      Lifting_wing_HIL_model_dll_B.Gain_l[1] * rtb_Fa[2]);
    rtb_IntegratorSecondOrderLimi_0 =
      ((Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain_g * rtb_Sum4_h[2] -
        rtb_IntegratorSecondOrderLimi_0) + rtb_sincos_o1[2]) + (rtb_Fa[0] *
      Lifting_wing_HIL_model_dll_B.Gain_l[1] -
      Lifting_wing_HIL_model_dll_B.Gain_l[0] * rtb_Fa[1]);
    for (i = 0; i < 3; i++) {
      // Sum: '<S113>/Sum2' incorporates:
      //   Constant: '<S95>/Measurement bias'
      //   Constant: '<S95>/Scale factors & Cross-coupling  errors'
      //   Gain: '<S113>/wn^2'
      //   Product: '<S95>/Product'
      //   Sum: '<S113>/Sum3'
      //   Sum: '<S95>/Sum4'

      Lifting_wing_HIL_model_dll_B.Sum2_b[i] =
        ((((Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_a_sf_cc[i + 3] *
            rtb_Lw_idx_0 +
            Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_a_sf_cc[i] *
            rtb_IntegratorSecondOrderLimi_2) +
           Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_a_sf_cc[i + 6] *
           rtb_IntegratorSecondOrderLimi_0) +
          Lifting_wing_HIL_model_dll_P.ThreeaxisAccelerometer1_a_bias[i]) -
         rtb_Integrator1_p[i]) * rtb_Gain7 - rtb_IntegratorSecondOrderLimite[i];
    }

    if (tmp) {
      // RandomNumber: '<S89>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_b[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber3[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_b[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber3[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_b[2];
    }

    if (rEQ0) {
      // RandomNumber: '<S90>/Random Number2'
      Lifting_wing_HIL_model_dll_B.RandomNumber2_o =
        Lifting_wing_HIL_model_dll_DW.NextOutput_l;

      // RandomNumber: '<S92>/Random Number'
      Lifting_wing_HIL_model_dll_B.RandomNumber_b[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_i[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber_b[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_i[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber_b[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_i[2];
    }

    if (tmp_1) {
      // Gain: '<S91>/BiasGain1' incorporates:
      //   UniformRandomNumber: '<S91>/Uniform Random Number4'

      Lifting_wing_HIL_model_dll_B.BiasGain1[0] =
        Lifting_wing_HIL_model_dll_P.BiasGain1_Gain *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[0];
      Lifting_wing_HIL_model_dll_B.BiasGain1[1] =
        Lifting_wing_HIL_model_dll_P.BiasGain1_Gain *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[1];
      Lifting_wing_HIL_model_dll_B.BiasGain1[2] =
        Lifting_wing_HIL_model_dll_P.BiasGain1_Gain *
        Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[2];
    }

    for (i = 0; i < 20; i++) {
      // DataTypeConversion: '<S10>/Data Type Conversion' incorporates:
      //   Inport: '<Root>/inSILFloats'

      DataTypeConversion1[i] = Lifting_wing_HIL_model_dll_U.inSILFloats[i];
    }

    if (tmp) {
      // MATLAB Function: '<S381>/failture_gyro_ng_var' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_gyro1/failture_gyro_ng_var': '<S395>:1' 
      // '<S395>:1:4' if isempty(gyro_ng_var_init)
      // '<S395>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_j) {
        // '<S395>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_ml =
          rtb_DataTypeConversion1_tmp_tmp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_j = true;
      }

      // '<S395>:1:20' gyro_ng_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S395>:1:21' if type ==7
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 7.0F) {
        // '<S395>:1:22' gyro_ng_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.gyro_ng_var_en = DataTypeConversion1[0];

        // '<S395>:1:23' gyro_ng_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S395>:1:24' gyro_ng_var_T = data(3: 2+gyro_ng_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S395>:1:25' N = length(gyro_ng_var_T);
        // '<S395>:1:26' if  N~=gyro_ng_var_N
        // '<S395>:1:30' gyro_ng_var_dt = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S395>:1:31' if gyro_ng_var_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S395>:1:32' gyro_ng_var_dt(1:18 - gyro_ng_var_N) = data(3+gyro_ng_var_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data[i] =
              DataTypeConversion1[rtb_lon + i];
          }
        } else {
          // '<S395>:1:33' else
          // '<S395>:1:34' gyro_ng_var_dt(1:gyro_ng_var_N) = data(3+gyro_ng_var_N:2+2*gyro_ng_var_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data[i] =
              DataTypeConversion1[rtb_lat + i];
          }

          // '<S395>:1:35' gyro_ng_var_am = data(3+2*gyro_ng_var_N:4+2*gyro_ng_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S395>:1:44' gyro_ng_var_default = ones(3,1);
      // '<S395>:1:45' gyro_ng_var = ones(3,1);
      // '<S395>:1:46' x = gyro_ng_var_default;
      // 
      // '<S395>:1:48' if gyro_ng_var_en && ~gyro_ng_var_init
      if ((Lifting_wing_HIL_model_dll_DW.gyro_ng_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.gyro_ng_var_init != 0.0))) {
        // '<S395>:1:49' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_ml =
          rtb_DataTypeConversion1_tmp_tmp;

        // '<S395>:1:50' gyro_ng_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.gyro_ng_var_init = 1.0;

        // '<S395>:1:51' N = length(gyro_ng_var_T);
        // '<S395>:1:52' gyro_ng_var_am_rand = ones(N, 3);
        Comega_tmp_0 = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0] * 3;
        for (i = 0; i < Comega_tmp; i++) {
          gyro_ng_var_am_rand_data[i] = 1.0;
        }

        // '<S395>:1:53' v = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.v_n.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.v_n.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S395>:1:54' for i = 1 : gyro_ng_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S395>:1:55' gyro_ng_var_am_rand(i, 1) = data_gen1(gyro_ng_var_am(1), gyro_ng_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S395>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model_d_rand_a() + Merge;

          // '<S395>:1:56' gyro_ng_var_am_rand(i, 2) = data_gen1(gyro_ng_var_am(1), gyro_ng_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S395>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + Comega_tmp_0] = (rtb_q3dot - Merge)
            * Lifting_wing_HIL_model_d_rand_a() + Merge;

          // '<S395>:1:57' gyro_ng_var_am_rand(i, 3) = data_gen1(gyro_ng_var_am(1), gyro_ng_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S395>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + (Comega_tmp_0 << 1)] = (rtb_q3dot -
            Merge) * Lifting_wing_HIL_model_d_rand_a() + Merge;

          // '<S395>:1:58' v(i) = 0;
          Lifting_wing_HIL_model_dll_DW.v_n.data[rtb_lat] = 0.0;
        }

        // '<S395>:1:60' x_init  = gyro_ng_var_am_rand;
        Lifting_wing_HIL_model_dll_DW.x_init_i.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0];
        Lifting_wing_HIL_model_dll_DW.x_init_i.size[1] = 3;
        rtb_lat = Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0] * 3;
        if (rtb_lat - 1 >= 0) {
          std::memcpy(&Lifting_wing_HIL_model_dll_DW.x_init_i.data[0],
                      &gyro_ng_var_am_rand_data[0], static_cast<uint32_T>
                      (rtb_lat) * sizeof(real_T));
        }
      }

      // '<S395>:1:63' if gyro_ng_var_en
      if (Lifting_wing_HIL_model_dll_DW.gyro_ng_var_en != 0.0) {
        // 
        // '<S395>:1:65' runtime = timestamp - timestart;
        Merge = rtb_DataTypeConversion1_tmp_tmp -
          Lifting_wing_HIL_model_dll_DW.timestart_ml;

        // '<S395>:1:66' gyro_ng_var(1)= param_gen(runtime, x(1), x_init(:, 1) , gyro_ng_var_T, v , gyro_ng_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memcpy(&tmp_data[0],
                      &Lifting_wing_HIL_model_dll_DW.x_init_i.data[0],
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[0] = tmp_data_0;

        // '<S395>:1:67' gyro_ng_var(2)= param_gen(runtime, x(2), x_init(:, 2) , gyro_ng_var_T, v , gyro_ng_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_i.data[i +
            Lifting_wing_HIL_model_dll_DW.x_init_i.size[0]];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[1] = tmp_data_0;

        // '<S395>:1:68' gyro_ng_var(3)= param_gen(runtime, x(3), x_init(:, 3) , gyro_ng_var_T, v , gyro_ng_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_i.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_i.data
            [(Lifting_wing_HIL_model_dll_DW.x_init_i.size[0] << 1) + i];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[2] = tmp_data_0;
      } else {
        // '<S395>:1:69' else
        // '<S395>:1:70' gyro_ng_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.gyro_ng_var_init = 0.0;

        // '<S395>:1:71' gyro_ng_var= gyro_ng_var_default;
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[0] = 1.0;
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[1] = 1.0;
        Lifting_wing_HIL_model_dll_B.gyro_ng_var[2] = 1.0;
      }

      // End of MATLAB Function: '<S381>/failture_gyro_ng_var'

      // MATLAB Function: '<S381>/failture_gyro_kgp' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_gyro1/failture_gyro_kgp': '<S393>:1' 
      // '<S393>:1:4' if isempty(gyro_kgp_init)
      // '<S393>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_c) {
        // '<S393>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_jj =
          rtb_DataTypeConversion1_tmp_tmp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_c = true;
      }

      // '<S393>:1:18' gyro_kgp_N = 1;
      rtb_q3dot = 1.0;

      // '<S393>:1:19' if type ==3
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 3.0F) {
        // '<S393>:1:20' gyro_kgp_en = data(1);
        Lifting_wing_HIL_model_dll_DW.gyro_kgp_en = DataTypeConversion1[0];

        // '<S393>:1:21' gyro_kgp_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S393>:1:22' gyro_kgp_T = data(3: 2+gyro_kgp_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S393>:1:23' N = length(gyro_kgp_T);
        // '<S393>:1:24' if  N~=gyro_kgp_N
        // '<S393>:1:28' gyro_kgp_dt = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S393>:1:29' if gyro_kgp_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S393>:1:30' gyro_kgp_dt(1:18 - gyro_kgp_N) = data(3+gyro_kgp_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.data[i] =
              DataTypeConversion1[rtb_lon + i];
          }
        } else {
          // '<S393>:1:31' else
          // '<S393>:1:32' gyro_kgp_dt(1:gyro_kgp_N) = data(3+gyro_kgp_N:2+2*gyro_kgp_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.data[i] =
              DataTypeConversion1[rtb_lat + i];
          }

          // '<S393>:1:33' gyro_kgp_am = data(3+2*gyro_kgp_N:4+2*gyro_kgp_N);
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S393>:1:42' gyro_kgp_default = ones(3,1);
      // '<S393>:1:43' gyro_kgp = ones(3,1);
      // '<S393>:1:44' x = gyro_kgp_default;
      // 
      // '<S393>:1:46' if gyro_kgp_en && ~gyro_kgp_init
      if ((Lifting_wing_HIL_model_dll_DW.gyro_kgp_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.gyro_kgp_init != 0.0))) {
        // '<S393>:1:47' gyro_kgp_init = 1;
        Lifting_wing_HIL_model_dll_DW.gyro_kgp_init = 1.0;

        // '<S393>:1:48' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_jj =
          rtb_DataTypeConversion1_tmp_tmp;

        // '<S393>:1:49' N = length(gyro_kgp_T);
        // '<S393>:1:50' gyro_kgp_am_rand = ones(N, 3);
        Comega_tmp_0 = Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0] * 3;
        for (i = 0; i < Comega_tmp; i++) {
          gyro_ng_var_am_rand_data[i] = 1.0;
        }

        // '<S393>:1:51' v = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.v_bm.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.v_bm.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S393>:1:52' for i = 1 : gyro_kgp_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S393>:1:53' gyro_kgp_am_rand(i, 1) = data_gen1(gyro_kgp_am(1), gyro_kgp_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S393>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model_d_rand_c() + Merge;

          // '<S393>:1:54' gyro_kgp_am_rand(i, 2) = data_gen1(gyro_kgp_am(1), gyro_kgp_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S393>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + Comega_tmp_0] = (rtb_q3dot - Merge)
            * Lifting_wing_HIL_model_d_rand_c() + Merge;

          // '<S393>:1:55' gyro_kgp_am_rand(i, 3) = data_gen1(gyro_kgp_am(1), gyro_kgp_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S393>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + (Comega_tmp_0 << 1)] = (rtb_q3dot -
            Merge) * Lifting_wing_HIL_model_d_rand_c() + Merge;

          // '<S393>:1:56' v(i) = 0;
          Lifting_wing_HIL_model_dll_DW.v_bm.data[rtb_lat] = 0.0;
        }

        // '<S393>:1:58' x_init  = gyro_kgp_am_rand;
        Lifting_wing_HIL_model_dll_DW.x_init_n.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0];
        Lifting_wing_HIL_model_dll_DW.x_init_n.size[1] = 3;
        rtb_lat = Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0] * 3;
        if (rtb_lat - 1 >= 0) {
          std::memcpy(&Lifting_wing_HIL_model_dll_DW.x_init_n.data[0],
                      &gyro_ng_var_am_rand_data[0], static_cast<uint32_T>
                      (rtb_lat) * sizeof(real_T));
        }
      }

      // '<S393>:1:61' if gyro_kgp_en
      if (!(Lifting_wing_HIL_model_dll_DW.gyro_kgp_en != 0.0)) {
        // '<S393>:1:67' else
        // '<S393>:1:68' gyro_kgp_init = 0;
        Lifting_wing_HIL_model_dll_DW.gyro_kgp_init = 0.0;

        // '<S393>:1:69' gyro_kgp= gyro_kgp_default;
      } else {
        // 
        // '<S393>:1:63' runtime = timestamp - timestart;
        // '<S393>:1:64' gyro_kgp(1)= param_gen(runtime, x(1), x_init(:, 1) , gyro_kgp_T, v , gyro_kgp_dt ); 
      }

      // End of MATLAB Function: '<S381>/failture_gyro_kgp'

      // MATLAB Function: '<S381>/failture_gyro_kg_cg' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_gyro1/failture_gyro_kg_cg': '<S392>:1' 
      // '<S392>:1:5' if isempty(gyro_init)
      // '<S392>:1:13' if type == 1
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 1.0F) {
        // '<S392>:1:14' gyro_kg_cg_en = data(1);
        Lifting_wing_HIL_model_dll_DW.gyro_kg_cg_en = DataTypeConversion1[0];

        // '<S392>:1:15' gyro_kg__N = data(2);
        // 
        // '<S392>:1:16' gyro_kg_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.size[0] = 2;

        // '<S392>:1:17' gyro_cg_limit =  data(5: 6 );
        Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[0] =
          DataTypeConversion1[4];
        Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[1] =
          DataTypeConversion1[3];
        Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[1] =
          DataTypeConversion1[5];
      }

      // '<S392>:1:22' if gyro_kg_cg_en
      if (Lifting_wing_HIL_model_dll_DW.gyro_kg_cg_en != 0.0) {
        // '<S392>:1:23' if ~gyro_init
        if (!(Lifting_wing_HIL_model_dll_DW.gyro_init != 0.0)) {
          // '<S392>:1:24' gyro_init = 1;
          Lifting_wing_HIL_model_dll_DW.gyro_init = 1.0;

          // '<S392>:1:25' gyro_kg(1) = data_gen1(gyro_kg_limit(1), gyro_kg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_kg[0] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;

          // '<S392>:1:26' gyro_kg(2) = data_gen1(gyro_kg_limit(1), gyro_kg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_kg[1] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;

          // '<S392>:1:27' gyro_kg(3) = data_gen1(gyro_kg_limit(1), gyro_kg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_kg[2] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;

          // '<S392>:1:28' gyro_cg(1) = data_gen1(gyro_cg_limit(1), gyro_cg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_cg[0] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;

          // '<S392>:1:29' gyro_cg(2) = data_gen1(gyro_cg_limit(1), gyro_cg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_cg[1] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;

          // '<S392>:1:30' gyro_cg(3) = data_gen1(gyro_cg_limit(1), gyro_cg_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S392>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.gyro_cg[2] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model_d_rand_p() + Merge;
        }
      } else {
        // '<S392>:1:32' else
        // '<S392>:1:33' gyro_init = 0;
        Lifting_wing_HIL_model_dll_DW.gyro_init = 0.0;

        // '<S392>:1:34' gyro_kg = ones(3, 1);
        // '<S392>:1:35' gyro_cg = zeros(3, 1);
        Lifting_wing_HIL_model_dll_DW.gyro_kg[0] = 1.0;
        Lifting_wing_HIL_model_dll_DW.gyro_cg[0] = 0.0;
        Lifting_wing_HIL_model_dll_DW.gyro_kg[1] = 1.0;
        Lifting_wing_HIL_model_dll_DW.gyro_cg[1] = 0.0;
        Lifting_wing_HIL_model_dll_DW.gyro_kg[2] = 1.0;
        Lifting_wing_HIL_model_dll_DW.gyro_cg[2] = 0.0;
      }

      // End of MATLAB Function: '<S381>/failture_gyro_kg_cg'

      // MATLAB Function: '<S92>/MATLAB Function'
      // '<S392>:1:38' ygyro_kg = gyro_kg;
      // '<S392>:1:39' ygyro_cg = gyro_cg;
      // MATLAB Function 'Sensor Model/Gyroscope Hub/MATLAB Function': '<S157>:1' 
      // '<S157>:1:3' if isempty(gyro)
      if (!Lifting_wing_HIL_model_dll_DW.gyro_not_empty) {
        // '<S157>:1:4' gyro = gyroout;
        Lifting_wing_HIL_model_dll_DW.gyro_not_empty = true;
      }

      // End of MATLAB Function: '<S92>/MATLAB Function'
      // '<S157>:1:7' if kgp == 0
      // MATLAB Function 'Sensor Model/Gyroscope Hub/MATLAB Function1': '<S158>:1' 
      // '<S158>:1:3' y = [kgp1(1) 0 0;
      // '<S158>:1:4'        0 kgp1(2) 0;
      // '<S158>:1:5'        0 0 kgp1(3)];
    }

    // SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited'
    rtb_Integrator1_p[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[0];
    rtb_Fp[0] = Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[3];
    rtb_Integrator1_p[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[1];
    rtb_Fp[1] = Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[4];
    rtb_Integrator1_p[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[2];
    rtb_Fp[2] = Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[5];
    if (rEQ0) {
      // RandomNumber: '<S92>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_gk[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_gk[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_gk[2];
    }

    if (tmp) {
      // MATLAB Function: '<S381>/failture_gyro_nbg_var' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_gyro1/failture_gyro_nbg_var': '<S394>:1' 
      // '<S394>:1:4' if isempty(gyro_nbg_var_init)
      // '<S394>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_h5) {
        // '<S394>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_n =
          rtb_DataTypeConversion1_tmp_tmp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_h5 = true;
      }

      // '<S394>:1:18' gyro_nbg_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S394>:1:19' if type ==5
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 5.0F) {
        // '<S394>:1:20' gyro_nbg_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_en = DataTypeConversion1[0];

        // '<S394>:1:21' gyro_nbg_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S394>:1:22' gyro_nbg_var_T = data(3: 2+gyro_nbg_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S394>:1:23' N = length(gyro_nbg_var_T);
        // '<S394>:1:24' if  N~=gyro_nbg_var_N
        // '<S394>:1:28' gyro_nbg_var_dt = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S394>:1:29' if gyro_nbg_var_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S394>:1:30' gyro_nbg_var_dt(1:18 - gyro_nbg_var_N) = data(3+gyro_nbg_var_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data[i] =
              DataTypeConversion1[rtb_lon + i];
          }
        } else {
          // '<S394>:1:31' else
          // '<S394>:1:32' gyro_nbg_var_dt(1:gyro_nbg_var_N) = data(3+gyro_nbg_var_N:2+2*gyro_nbg_var_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data[i] =
              DataTypeConversion1[rtb_lat + i];
          }

          // '<S394>:1:33' gyro_nbg_var_am = data(3+2*gyro_nbg_var_N:4+2*gyro_nbg_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S394>:1:42' gyro_nbg_var_default = ones(3,1);
      // '<S394>:1:43' gyro_nbg_var = ones(3,1);
      // '<S394>:1:44' x = gyro_nbg_var_default;
      // 
      // '<S394>:1:46' if gyro_nbg_var_en && ~gyro_nbg_var_init
      if ((Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_init != 0.0))) {
        // '<S394>:1:47' gyro_nbg_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_init = 1.0;

        // '<S394>:1:48' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_n =
          rtb_DataTypeConversion1_tmp_tmp;

        // '<S394>:1:49' N = length(gyro_nbg_var_T);
        // '<S394>:1:50' gyro_nbg_var_am_rand = ones(N, 3);
        Comega_tmp_0 = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0] * 3;
        for (i = 0; i < Comega_tmp; i++) {
          gyro_ng_var_am_rand_data[i] = 1.0;
        }

        // '<S394>:1:51' v = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.v_j.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.v_j.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S394>:1:52' for i = 1 : gyro_nbg_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S394>:1:53' gyro_nbg_var_am_rand(i, 1) = data_gen1(gyro_nbg_var_am(1), gyro_nbg_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S394>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model_d_rand_i() + Merge;

          // '<S394>:1:54' gyro_nbg_var_am_rand(i, 2) = data_gen1(gyro_nbg_var_am(1), gyro_nbg_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S394>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + Comega_tmp_0] = (rtb_q3dot - Merge)
            * Lifting_wing_HIL_model_d_rand_i() + Merge;

          // '<S394>:1:55' gyro_nbg_var_am_rand(i, 3) = data_gen1(gyro_nbg_var_am(1), gyro_nbg_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S394>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + (Comega_tmp_0 << 1)] = (rtb_q3dot -
            Merge) * Lifting_wing_HIL_model_d_rand_i() + Merge;

          // '<S394>:1:56' v(i) = 0;
          Lifting_wing_HIL_model_dll_DW.v_j.data[rtb_lat] = 0.0;
        }

        // '<S394>:1:58' x_init  = gyro_nbg_var_am_rand;
        Lifting_wing_HIL_model_dll_DW.x_init_e.size[0] =
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0];
        Lifting_wing_HIL_model_dll_DW.x_init_e.size[1] = 3;
        rtb_lat = Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0] * 3;
        if (rtb_lat - 1 >= 0) {
          std::memcpy(&Lifting_wing_HIL_model_dll_DW.x_init_e.data[0],
                      &gyro_ng_var_am_rand_data[0], static_cast<uint32_T>
                      (rtb_lat) * sizeof(real_T));
        }
      }

      // '<S394>:1:61' if gyro_nbg_var_en
      if (Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_en != 0.0) {
        // 
        // '<S394>:1:63' runtime = timestamp - timestart;
        Merge = rtb_DataTypeConversion1_tmp_tmp -
          Lifting_wing_HIL_model_dll_DW.timestart_n;

        // '<S394>:1:64' gyro_nbg_var(1)= param_gen(runtime, x(1), x_init(:, 1) , gyro_nbg_var_T, v , gyro_nbg_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memcpy(&tmp_data[0],
                      &Lifting_wing_HIL_model_dll_DW.x_init_e.data[0],
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[0] = tmp_data_0;

        // '<S394>:1:65' gyro_nbg_var(2)= param_gen(runtime, x(2), x_init(:, 2) , gyro_nbg_var_T, v , gyro_nbg_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_e.data[i +
            Lifting_wing_HIL_model_dll_DW.x_init_e.size[0]];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[1] = tmp_data_0;

        // '<S394>:1:66' gyro_nbg_var(3)= param_gen(runtime, x(3), x_init(:, 3) , gyro_nbg_var_T, v , gyro_nbg_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_e.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_e.data
            [(Lifting_wing_HIL_model_dll_DW.x_init_e.size[0] << 1) + i];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.data,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size,
          Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[2] = tmp_data_0;
      } else {
        // '<S394>:1:67' else
        // '<S394>:1:68' gyro_nbg_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_init = 0.0;

        // '<S394>:1:69' gyro_nbg_var= gyro_nbg_var_default;
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[0] = 1.0;
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[1] = 1.0;
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[2] = 1.0;
      }

      // End of MATLAB Function: '<S381>/failture_gyro_nbg_var'

      // Product: '<S92>/Product4'
      Lifting_wing_HIL_model_dll_B.Product4[0] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[0] *
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[0];
      Lifting_wing_HIL_model_dll_B.Product4[1] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[1] *
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[1];
      Lifting_wing_HIL_model_dll_B.Product4[2] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_e1[2] *
        Lifting_wing_HIL_model_dll_B.gyro_nbg_var[2];
    }

    // Gain: '<S163>/2*zeta * wn'
    rtb_Gain7 = 2.0 * Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_z_g *
      Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_w_g;

    // Gain: '<S163>/wn^2'
    Merge = Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_w_g *
      Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_w_g;

    // Gain: '<S159>/Zero-Order Hold' incorporates:
    //   Constant: '<S159>/Scale factors & Cross-coupling  errors '
    //   Product: '<S159>/Product'

    rtb_jxi = rtb_Product_d[0];
    rtb_Divide_idx_0 = rtb_Product_d[1];
    rtb_Gain1_idx_2 = rtb_Product_d[2];
    for (i = 0; i < 3; i++) {
      // Sum: '<S163>/Sum2' incorporates:
      //   Constant: '<S159>/Measurement bias'
      //   Constant: '<S159>/Scale factors & Cross-coupling  errors '
      //   Constant: '<S159>/g-sensitive bias'
      //   Gain: '<S159>/Zero-Order Hold'
      //   Gain: '<S159>/Zero-Order Hold1'
      //   Gain: '<S163>/2*zeta * wn'
      //   Gain: '<S163>/wn^2'
      //   Product: '<S159>/Product'
      //   Product: '<S159>/Product1'
      //   Sum: '<S159>/Sum4'
      //   Sum: '<S163>/Sum3'

      Lifting_wing_HIL_model_dll_B.Sum2_k[i] =
        (((((Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i4 * rtb_jxi *
             Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_g_sf_cc[i] +
             Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_g_sf_cc[i + 3] *
             (Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i4 *
              rtb_Divide_idx_0)) +
            Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_g_sf_cc[i + 6] *
            (Lifting_wing_HIL_model_dll_P.ZeroOrderHold_Gain_i4 *
             rtb_Gain1_idx_2)) +
           Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_g_bias[i]) +
          Lifting_wing_HIL_model_dll_P.ZeroOrderHold1_Gain_j *
          rtb_Saturation_c[i] *
          Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope0_g_sen[i]) -
         rtb_Integrator1_p[i]) * Merge - rtb_Gain7 * rtb_Fp[i];
    }

    // Gain: '<S166>/2*zeta * wn'
    rtb_Gain7 = 2.0 * Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_z_g *
      Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_w_g;

    // Gain: '<S166>/wn^2'
    Merge = Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_w_g *
      Lifting_wing_HIL_model_dll_P.ThreeaxisGyroscope1_w_g;

    // Sum: '<S166>/Sum2' incorporates:
    //   Gain: '<S166>/2*zeta * wn'
    //   Gain: '<S166>/wn^2'
    //   Sum: '<S166>/Sum3'

    Lifting_wing_HIL_model_dll_B.Sum2_h[0] = (rtb_Sum4_g[0] - rtb_Ma[0]) * Merge
      - rtb_Gain7 * rtb_IntegratorSecondOrderLimi_p[0];
    Lifting_wing_HIL_model_dll_B.Sum2_h[1] = (rtb_Sum4_g[1] - rtb_Ma[1]) * Merge
      - rtb_Gain7 * rtb_IntegratorSecondOrderLimi_p[1];
    Lifting_wing_HIL_model_dll_B.Sum2_h[2] = (rtb_Sum4_g[2] - rtb_Ma[2]) * Merge
      - rtb_Gain7 * rtb_IntegratorSecondOrderLimi_p[2];
    if (tmp) {
      // RandomNumber: '<S92>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_le[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_le[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_le[2];

      // MATLAB Function: '<S382>/failture_magl_km_cm' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_mag1/failture_magl_km_cm': '<S399>:1' 
      // '<S399>:1:5' if isempty(mag_init)
      // '<S399>:1:13' if type == 61
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 61.0F) {
        // '<S399>:1:14' mag_km_cm_en = data(1);
        Lifting_wing_HIL_model_dll_DW.mag_km_cm_en = DataTypeConversion1[0];

        // '<S399>:1:15' mag_km__N = data(2);
        // 
        // '<S399>:1:16' mag_km_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.mag_km_limit.size[0] = 2;

        // '<S399>:1:17' mag_cm_limit =  data(5: 6 );
        Lifting_wing_HIL_model_dll_DW.mag_cm_limit.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.mag_cm_limit.data[0] =
          DataTypeConversion1[4];
        Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[1] =
          DataTypeConversion1[3];
        Lifting_wing_HIL_model_dll_DW.mag_cm_limit.data[1] =
          DataTypeConversion1[5];
      }

      // '<S399>:1:22' if mag_km_cm_en
      if (Lifting_wing_HIL_model_dll_DW.mag_km_cm_en != 0.0) {
        // '<S399>:1:23' if ~mag_init
        if (!(Lifting_wing_HIL_model_dll_DW.mag_init != 0.0)) {
          // '<S399>:1:24' mag_init = 1;
          Lifting_wing_HIL_model_dll_DW.mag_init = 1.0;

          // '<S399>:1:25' mag_km(1) = data_gen1(mag_km_limit(1), mag_km_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.mag_km[0] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model__rand_iv() + Merge;

          // '<S399>:1:26' mag_km(2) = data_gen1(mag_km_limit(1), mag_km_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.mag_km[1] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model__rand_iv() + Merge;

          // '<S399>:1:27' mag_km(3) = data_gen1(mag_km_limit(1), mag_km_limit(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.mag_km[2] = (rtb_q3dot - Merge) *
            Lifting_wing_HIL_model__rand_iv() + Merge;

          // '<S399>:1:28' mag_cm(1) = data_gen1(mag_cm_limit(1), mag_cm_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_iv();

          // '<S399>:1:29' mag_cm(2) = data_gen1(mag_cm_limit(1), mag_cm_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_iv();

          // '<S399>:1:30' mag_cm(3) = data_gen1(mag_cm_limit(1), mag_cm_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S399>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_iv();
        }
      } else {
        // '<S399>:1:32' else
        // '<S399>:1:33' mag_init = 0;
        Lifting_wing_HIL_model_dll_DW.mag_init = 0.0;

        // '<S399>:1:34' mag_km = ones(3, 1);
        // '<S399>:1:35' mag_cm = zeros(3, 1);
        Lifting_wing_HIL_model_dll_DW.mag_km[0] = 1.0;
        Lifting_wing_HIL_model_dll_DW.mag_km[1] = 1.0;
        Lifting_wing_HIL_model_dll_DW.mag_km[2] = 1.0;
      }

      // End of MATLAB Function: '<S382>/failture_magl_km_cm'

      // MATLAB Function: '<S382>/failture_mag_nm_var' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Inport: '<Root>/inSILInts'

      // '<S399>:1:38' ymag_km = mag_km;
      // '<S399>:1:39' ymag_cm = mag_cm;
      //
      // MATLAB Function 'udp_receiver/failture_mag1/failture_mag_nm_var': '<S398>:1' 
      // '<S398>:1:4' if isempty(mag_nm_var_init)
      // '<S398>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d0) {
        // '<S398>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_d =
          rtb_DataTypeConversion1_tmp_tmp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d0 = true;
      }

      // '<S398>:1:20' mag_nm_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S398>:1:21' if type ==67
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 67.0F) {
        // '<S398>:1:22' mag_nm_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.mag_nm_var_en = DataTypeConversion1[0];

        // '<S398>:1:23' mag_nm_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S398>:1:24' mag_nm_var_T = data(3: 2+mag_nm_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S398>:1:25' N = length(mag_nm_var_T);
        // '<S398>:1:26' if  N~=mag_nm_var_N
        // '<S398>:1:30' mag_nm_var_dt = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S398>:1:31' if mag_nm_var_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S398>:1:32' mag_nm_var_dt(1:18 - mag_nm_var_N) = data(3+mag_nm_var_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.data[i] =
              DataTypeConversion1[rtb_lon + i];
          }
        } else {
          // '<S398>:1:33' else
          // '<S398>:1:34' mag_nm_var_dt(1:mag_nm_var_N) = data(3+mag_nm_var_N:2+2*mag_nm_var_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.data[i] =
              DataTypeConversion1[rtb_lat + i];
          }

          // '<S398>:1:35' mag_nm_var_am = data(3+2*mag_nm_var_N:4+2*mag_nm_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S398>:1:44' mag_nm_var_default = ones(3,1);
      // '<S398>:1:45' mag_nm_var = ones(3,1);
      // '<S398>:1:46' x = mag_nm_var_default;
      // 
      // '<S398>:1:48' if mag_nm_var_en && ~mag_nm_var_init
      if ((Lifting_wing_HIL_model_dll_DW.mag_nm_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.mag_nm_var_init != 0.0))) {
        // '<S398>:1:49' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_d =
          rtb_DataTypeConversion1_tmp_tmp;

        // '<S398>:1:50' mag_nm_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.mag_nm_var_init = 1.0;

        // '<S398>:1:51' N = length(mag_nm_var_T);
        // '<S398>:1:52' mag_nm_var_am_rand = ones(N, 3);
        Comega_tmp_0 = Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0] * 3;
        for (i = 0; i < Comega_tmp; i++) {
          gyro_ng_var_am_rand_data[i] = 1.0;
        }

        // '<S398>:1:53' v = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.v.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.v.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S398>:1:54' for i = 1 : mag_nm_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S398>:1:55' mag_nm_var_am_rand(i, 1) = data_gen1(mag_nm_var_am(1), mag_nm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S398>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model__rand_az() + Merge;

          // '<S398>:1:56' mag_nm_var_am_rand(i, 2) = data_gen1(mag_nm_var_am(1), mag_nm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S398>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + Comega_tmp_0] = (rtb_q3dot - Merge)
            * Lifting_wing_HIL_model__rand_az() + Merge;

          // '<S398>:1:57' mag_nm_var_am_rand(i, 3) = data_gen1(mag_nm_var_am(1), mag_nm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S398>:1:111' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + (Comega_tmp_0 << 1)] = (rtb_q3dot -
            Merge) * Lifting_wing_HIL_model__rand_az() + Merge;

          // '<S398>:1:58' v(i) = 0;
          Lifting_wing_HIL_model_dll_DW.v.data[rtb_lat] = 0.0;
        }

        // '<S398>:1:60' x_init  = mag_nm_var_am_rand;
        Lifting_wing_HIL_model_dll_DW.x_init.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0];
        Lifting_wing_HIL_model_dll_DW.x_init.size[1] = 3;
        rtb_lat = Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0] * 3;
        if (rtb_lat - 1 >= 0) {
          std::memcpy(&Lifting_wing_HIL_model_dll_DW.x_init.data[0],
                      &gyro_ng_var_am_rand_data[0], static_cast<uint32_T>
                      (rtb_lat) * sizeof(real_T));
        }
      }

      // '<S398>:1:63' if mag_nm_var_en
      if (!(Lifting_wing_HIL_model_dll_DW.mag_nm_var_en != 0.0)) {
        // '<S398>:1:69' else
        // '<S398>:1:70' mag_nm_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.mag_nm_var_init = 0.0;

        // '<S398>:1:71' mag_nm_var= mag_nm_var_default;
      } else {
        // 
        // '<S398>:1:65' runtime = timestamp - timestart;
        // '<S398>:1:66' mag_nm_var(1)= param_gen(runtime, x(1), x_init(:, 1) , mag_nm_var_T, v , mag_nm_var_dt ); 
      }

      // End of MATLAB Function: '<S382>/failture_mag_nm_var'
      // MATLAB Function 'Sensor Model/Magnetometer Hub/MATLAB Function2': '<S169>:1' 
      // '<S169>:1:3' y = [km(1) 0 0;
      // '<S169>:1:4'        0 km(2) 0;
      // '<S169>:1:5'        0 0 km(3)];
    }

    // MATLAB Function 'Sensor Model/Magnetometer Hub/MATLAB Function': '<S167>:1' 
    // '<S167>:1:3' Mag_means = K_m*DCM*mag_e + b_m + n_m;
    if (rEQ0) {
      // RandomNumber: '<S93>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_m[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ko[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_m[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ko[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber1_m[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ko[2];
    }

    if (tmp) {
      // MATLAB Function: '<S382>/failture_mag_nbm_var' incorporates:
      //   Clock: '<S5>/Clock1'
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_mag1/failture_mag_nbm_var': '<S397>:1' 
      // '<S397>:1:4' if isempty(mag_nbm_var_init)
      // '<S397>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_o4) {
        // '<S397>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_mr =
          rtb_DataTypeConversion1_tmp_tmp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_o4 = true;
      }

      // '<S397>:1:18' mag_nbm_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S397>:1:19' if type ==65
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 65.0F) {
        // '<S397>:1:20' mag_nbm_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.mag_nbm_var_en = DataTypeConversion1[0];

        // '<S397>:1:21' mag_nbm_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S397>:1:22' mag_nbm_var_T = data(3: 2+mag_nbm_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S397>:1:23' N = length(mag_nbm_var_T);
        // '<S397>:1:24' if  N~=mag_nbm_var_N
        // '<S397>:1:28' mag_nbm_var_dt = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S397>:1:29' if mag_nbm_var_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S397>:1:30' mag_nbm_var_dt(1:18 - mag_nbm_var_N) = data(3+mag_nbm_var_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data[i] =
              DataTypeConversion1[rtb_lon + i];
          }
        } else {
          // '<S397>:1:31' else
          // '<S397>:1:32' mag_nbm_var_dt(1:mag_nbm_var_N) = data(3+mag_nbm_var_N:2+2*mag_nbm_var_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data[i] =
              DataTypeConversion1[rtb_lat + i];
          }

          // '<S397>:1:33' mag_nbm_var_am = data(3+2*mag_nbm_var_N:4+2*mag_nbm_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S397>:1:42' mag_nbm_var_default = ones(3,1);
      // '<S397>:1:43' mag_nbm_var = ones(3,1);
      // '<S397>:1:44' x = mag_nbm_var_default;
      // 
      // '<S397>:1:46' if mag_nbm_var_en && ~mag_nbm_var_init
      if ((Lifting_wing_HIL_model_dll_DW.mag_nbm_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.mag_nbm_var_init != 0.0))) {
        // '<S397>:1:47' mag_nbm_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.mag_nbm_var_init = 1.0;

        // '<S397>:1:48' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_mr =
          rtb_DataTypeConversion1_tmp_tmp;

        // '<S397>:1:49' N = length(mag_nbm_var_T);
        // '<S397>:1:50' mag_nbm_var_am_rand = ones(N, 3);
        Comega_tmp_0 = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0] * 3;
        for (i = 0; i < Comega_tmp; i++) {
          gyro_ng_var_am_rand_data[i] = 1.0;
        }

        // '<S397>:1:51' v = zeros(N, 1);
        Lifting_wing_HIL_model_dll_DW.v_b.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memset(&Lifting_wing_HIL_model_dll_DW.v_b.data[0], 0,
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        // '<S397>:1:52' for i = 1 : mag_nbm_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S397>:1:53' mag_nbm_var_am_rand(i, 1) = data_gen1(mag_nbm_var_am(1), mag_nbm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S397>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat] = (rtb_Switch - Merge) *
            Lifting_wing_HIL_model__rand_d3() + Merge;

          // '<S397>:1:54' mag_nbm_var_am_rand(i, 2) = data_gen1(mag_nbm_var_am(1), mag_nbm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S397>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + Comega_tmp_0] = (rtb_q3dot - Merge)
            * Lifting_wing_HIL_model__rand_d3() + Merge;

          // '<S397>:1:55' mag_nbm_var_am_rand(i, 3) = data_gen1(mag_nbm_var_am(1), mag_nbm_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[0];
          rtb_q3dot = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S397>:1:108' y = data_min + (data_max - data_min)*rand;
          gyro_ng_var_am_rand_data[rtb_lat + (Comega_tmp_0 << 1)] = (rtb_q3dot -
            Merge) * Lifting_wing_HIL_model__rand_d3() + Merge;

          // '<S397>:1:56' v(i) = 0;
          Lifting_wing_HIL_model_dll_DW.v_b.data[rtb_lat] = 0.0;
        }

        // '<S397>:1:58' x_init  = mag_nbm_var_am_rand;
        Lifting_wing_HIL_model_dll_DW.x_init_k.size[0] =
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0];
        Lifting_wing_HIL_model_dll_DW.x_init_k.size[1] = 3;
        rtb_lat = Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0] * 3;
        if (rtb_lat - 1 >= 0) {
          std::memcpy(&Lifting_wing_HIL_model_dll_DW.x_init_k.data[0],
                      &gyro_ng_var_am_rand_data[0], static_cast<uint32_T>
                      (rtb_lat) * sizeof(real_T));
        }
      }

      // '<S397>:1:61' if mag_nbm_var_en
      if (Lifting_wing_HIL_model_dll_DW.mag_nbm_var_en != 0.0) {
        // 
        // '<S397>:1:63' runtime = timestamp - timestart;
        Merge = rtb_DataTypeConversion1_tmp_tmp -
          Lifting_wing_HIL_model_dll_DW.timestart_mr;

        // '<S397>:1:64' mag_nbm_var(1)= param_gen(runtime, x(1), x_init(:, 1) , mag_nbm_var_T, v , mag_nbm_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        if (Comega_tmp - 1 >= 0) {
          std::memcpy(&tmp_data[0],
                      &Lifting_wing_HIL_model_dll_DW.x_init_k.data[0],
                      static_cast<uint32_T>(Comega_tmp) * sizeof(real_T));
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.data,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[0] = tmp_data_0;

        // '<S397>:1:65' mag_nbm_var(2)= param_gen(runtime, x(2), x_init(:, 2) , mag_nbm_var_T, v , mag_nbm_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_k.data[i +
            Lifting_wing_HIL_model_dll_DW.x_init_k.size[0]];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.data,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[1] = tmp_data_0;

        // '<S397>:1:66' mag_nbm_var(3)= param_gen(runtime, x(3), x_init(:, 3) , mag_nbm_var_T, v , mag_nbm_var_dt ); 
        tmp_size[0] = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        Comega_tmp = Lifting_wing_HIL_model_dll_DW.x_init_k.size[0];
        for (i = 0; i < Comega_tmp; i++) {
          tmp_data[i] = Lifting_wing_HIL_model_dll_DW.x_init_k.data
            [(Lifting_wing_HIL_model_dll_DW.x_init_k.size[0] << 1) + i];
        }

        Lifting_wing_HIL_mo_param_gen_a(Merge, tmp_data, tmp_size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.data,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size,
          Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data, &tmp_data_0,
          tmp_size_0);
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[2] = tmp_data_0;
      } else {
        // '<S397>:1:67' else
        // '<S397>:1:68' mag_nbm_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.mag_nbm_var_init = 0.0;

        // '<S397>:1:69' mag_nbm_var= mag_nbm_var_default;
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[0] = 1.0;
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[1] = 1.0;
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[2] = 1.0;
      }

      // End of MATLAB Function: '<S382>/failture_mag_nbm_var'

      // Product: '<S93>/Product3'
      Lifting_wing_HIL_model_dll_B.Product3_p[0] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_m[0] *
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[0];

      // RandomNumber: '<S93>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3_f[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ld[0];

      // Product: '<S93>/Product3'
      Lifting_wing_HIL_model_dll_B.Product3_p[1] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_m[1] *
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[1];

      // RandomNumber: '<S93>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3_f[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ld[1];

      // Product: '<S93>/Product3'
      Lifting_wing_HIL_model_dll_B.Product3_p[2] =
        Lifting_wing_HIL_model_dll_B.RandomNumber1_m[2] *
        Lifting_wing_HIL_model_dll_B.mag_nbm_var[2];

      // RandomNumber: '<S93>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3_f[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_ld[2];
    }

    if (rEQ0) {
      // RandomNumber: '<S272>/Random Number'
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_c[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_c[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_c[2];

      // RandomNumber: '<S272>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_n[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_cd[0];

      // RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_im[0];

      // RandomNumber: '<S272>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_n[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_cd[1];

      // RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_im[1];

      // RandomNumber: '<S272>/Random Number1'
      Lifting_wing_HIL_model_dll_B.RandomNumber1_n[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_cd[2];

      // RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_im[2];

      // RandomNumber: '<S273>/Random Number3'
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[0] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_o[0];
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[1] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_o[1];
      Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[2] =
        Lifting_wing_HIL_model_dll_DW.NextOutput_o[2];
    }

    // Sum: '<S272>/Add' incorporates:
    //   Integrator: '<S272>/Integrator'

    Lifting_wing_HIL_model_dll_B.Add_d[0] =
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[0] +
      Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[0];
    Lifting_wing_HIL_model_dll_B.Add_d[1] =
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[1] +
      Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[1];
    Lifting_wing_HIL_model_dll_B.Add_d[2] =
      Lifting_wing_HIL_model_dll_B.RandomNumber_h[2] +
      Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[2];

    // Sum: '<S273>/Add2' incorporates:
    //   Integrator: '<S273>/Integrator1'

    Lifting_wing_HIL_model_dll_B.Add2[0] =
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[0] +
      Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[0];
    Lifting_wing_HIL_model_dll_B.Add2[1] =
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[1] +
      Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[1];
    Lifting_wing_HIL_model_dll_B.Add2[2] =
      Lifting_wing_HIL_model_dll_B.RandomNumber2_a[2] +
      Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[2];

    // Saturate: '<S174>/Signal_Saturation_7' incorporates:
    //   Constant: '<S9>/Constant1'
    //   Constant: '<S9>/Constant2'
    //   Gain: '<S9>/Gain1'
    //   Gain: '<S9>/Gain3'
    //   Sum: '<S9>/Sum2'
    //   Sum: '<S9>/Sum3'

    // MATLAB Function 'Subsystem Reference/Forces and Moments/b2l': '<S275>:1'
    // '<S275>:1:2' k = LW_ANGLE*pi/180;
    // '<S275>:1:3' Rm = [cos(k), 0 , -sin(k);
    // '<S275>:1:4'     0,     1 ,    0;
    // '<S275>:1:5'     sin(k), 0 ,  cos(k)];
    // '<S275>:1:6' Fa_l = Rm*F;
    // MATLAB Function 'Subsystem Reference/Forces and Moments/b2l1': '<S276>:1' 
    // '<S276>:1:2' kk = LW_ANGLE*pi/180;
    // '<S276>:1:3' Rm = [cos(kk), 0 , -sin(kk);
    // '<S276>:1:4'     0,     1 ,    0;
    // '<S276>:1:5'     sin(kk), 0 ,  cos(kk)];
    // '<S276>:1:6' Ma_l = Rm*Ma;
    tmp_5[0] = Lifting_wing_HIL_model_dll_P.Gain3_Gain_f *
      rtb_Signal_Saturation_7[0] +
      Lifting_wing_HIL_model_dll_P.Constant2_Value_om[0];
    tmp_5[1] = Lifting_wing_HIL_model_dll_P.Gain3_Gain_f *
      rtb_Signal_Saturation_7[1] +
      Lifting_wing_HIL_model_dll_P.Constant2_Value_om[1];
    tmp_5[2] = Lifting_wing_HIL_model_dll_P.Gain3_Gain_f *
      rtb_Signal_Saturation_7[2] +
      Lifting_wing_HIL_model_dll_P.Constant2_Value_om[2];
    tmp_5[3] = Lifting_wing_HIL_model_dll_P.Gain3_Gain_f *
      rtb_Signal_Saturation_7[3] +
      Lifting_wing_HIL_model_dll_P.Constant2_Value_om[3];
    tmp_5[4] = Lifting_wing_HIL_model_dll_P.Gain1_Gain_l *
      rtb_Signal_Saturation_7[4] +
      Lifting_wing_HIL_model_dll_P.Constant1_Value_i[0];
    tmp_5[5] = Lifting_wing_HIL_model_dll_P.Gain1_Gain_l *
      rtb_Signal_Saturation_7[5] +
      Lifting_wing_HIL_model_dll_P.Constant1_Value_i[1];
    for (i = 0; i < 6; i++) {
      lat = tmp_5[i];
      if (lat > Lifting_wing_HIL_model_dll_P.Signal_Saturation_7_UpperSat) {
        rtb_Signal_Saturation_7[i] =
          Lifting_wing_HIL_model_dll_P.Signal_Saturation_7_UpperSat;
      } else if (lat < Lifting_wing_HIL_model_dll_P.Signal_Saturation_7_LowerSat)
      {
        rtb_Signal_Saturation_7[i] =
          Lifting_wing_HIL_model_dll_P.Signal_Saturation_7_LowerSat;
      } else {
        rtb_Signal_Saturation_7[i] = lat;
      }
    }

    // End of Saturate: '<S174>/Signal_Saturation_7'

    // Gain: '<S281>/Gain1' incorporates:
    //   Constant: '<S281>/Constant2'
    //   Sum: '<S281>/Sum2'

    rtb_Divide_idx_0 = (rtb_Signal_Saturation_7[0] -
                        Lifting_wing_HIL_model_dll_P.Constant2_Value_g[0]) *
      Lifting_wing_HIL_model_dll_P.Gain1_Gain_lu;
    rtb_VectorConcatenate_a_idx_1 = (rtb_Signal_Saturation_7[1] -
      Lifting_wing_HIL_model_dll_P.Constant2_Value_g[1]) *
      Lifting_wing_HIL_model_dll_P.Gain1_Gain_lu;
    rtb_VectorConcatenate_a_idx_2 = (rtb_Signal_Saturation_7[2] -
      Lifting_wing_HIL_model_dll_P.Constant2_Value_g[2]) *
      Lifting_wing_HIL_model_dll_P.Gain1_Gain_lu;
    rtb_Lw_idx_1 = (rtb_Signal_Saturation_7[3] -
                    Lifting_wing_HIL_model_dll_P.Constant2_Value_g[3]) *
      Lifting_wing_HIL_model_dll_P.Gain1_Gain_lu;

    // Saturate: '<S174>/Signal_Saturation_1'
    // MATLAB Function 'Subsystem Reference/Motor and Servo Model/throttle2rads': '<S288>:1' 
    // '<S288>:1:3' throttle = throttle*ModelParam_efficiency*Ub;
    if (rtb_Divide_idx_0 >
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_1_UpperSat) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_1_UpperSat;
    } else if (rtb_Divide_idx_0 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_1_LowerSat) {
      rtb_Divide_idx_0 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_1_LowerSat;
    }

    // MATLAB Function: '<S174>/throttle2rads' incorporates:
    //   Constant: '<S171>/BatteryVol'
    //   Saturate: '<S174>/Signal_Saturation_1'

    Merge = rtb_Divide_idx_0 *
      Lifting_wing_HIL_model_dll_P.ModelParam_efficiency *
      Lifting_wing_HIL_model_dll_P.BatteryVol_Value;

    // '<S288>:1:5' y = ModelParam_motorUp1*throttle^2 + ModelParam_motorUp2*throttle + ModelParam_motorUp3; 
    lat = (Merge * Merge * Lifting_wing_HIL_model_dll_P.ModelParam_motorUp1 +
           Lifting_wing_HIL_model_dll_P.ModelParam_motorUp2 * Merge) +
      Lifting_wing_HIL_model_dll_P.ModelParam_motorUp3;

    // Saturate: '<S174>/motorSpeed'
    if (lat > Lifting_wing_HIL_model_dll_P.motorSpeed_UpperSat) {
      lat = Lifting_wing_HIL_model_dll_P.motorSpeed_UpperSat;
    } else if (lat < Lifting_wing_HIL_model_dll_P.motorSpeed_LowerSat) {
      lat = Lifting_wing_HIL_model_dll_P.motorSpeed_LowerSat;
    }

    // Product: '<S277>/Divide' incorporates:
    //   Constant: '<S277>/motorT'
    //   Saturate: '<S174>/motorSpeed'
    //   Sum: '<S277>/Sum'

    Lifting_wing_HIL_model_dll_B.Divide = (lat -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator) /
      Lifting_wing_HIL_model_dll_P.ModelParam_motorT;

    // Saturate: '<S174>/Signal_Saturation_2'
    // MATLAB Function 'Subsystem Reference/Motor and Servo Model/throttle2rads1': '<S289>:1' 
    // '<S289>:1:3' throttle = throttle*ModelParam_efficiency;
    if (rtb_VectorConcatenate_a_idx_1 >
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_2_UpperSat) {
      rtb_VectorConcatenate_a_idx_1 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_2_UpperSat;
    } else if (rtb_VectorConcatenate_a_idx_1 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_2_LowerSat) {
      rtb_VectorConcatenate_a_idx_1 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_2_LowerSat;
    }

    // MATLAB Function: '<S174>/throttle2rads1' incorporates:
    //   Saturate: '<S174>/Signal_Saturation_2'

    Merge = rtb_VectorConcatenate_a_idx_1 *
      Lifting_wing_HIL_model_dll_P.ModelParam_efficiency;

    // '<S289>:1:4' y = ModelParam_motorp1*throttle^2 + ModelParam_motorp2*throttle + ModelParam_motorp3; 
    lat = (Merge * Merge * Lifting_wing_HIL_model_dll_P.ModelParam_motorp1 +
           Lifting_wing_HIL_model_dll_P.ModelParam_motorp2 * Merge) +
      Lifting_wing_HIL_model_dll_P.ModelParam_motorp3;

    // Saturate: '<S174>/motorSpeed1'
    if (lat > Lifting_wing_HIL_model_dll_P.motorSpeed1_UpperSat) {
      lat = Lifting_wing_HIL_model_dll_P.motorSpeed1_UpperSat;
    } else if (lat < Lifting_wing_HIL_model_dll_P.motorSpeed1_LowerSat) {
      lat = Lifting_wing_HIL_model_dll_P.motorSpeed1_LowerSat;
    }

    // Product: '<S278>/Divide' incorporates:
    //   Constant: '<S278>/motorT'
    //   Saturate: '<S174>/motorSpeed1'
    //   Sum: '<S278>/Sum'

    Lifting_wing_HIL_model_dll_B.Divide_l = (lat -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_m) /
      Lifting_wing_HIL_model_dll_P.ModelParam_motorT;

    // Saturate: '<S174>/Signal_Saturation_3'
    if (rtb_VectorConcatenate_a_idx_2 >
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_3_UpperSat) {
      rtb_VectorConcatenate_a_idx_2 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_3_UpperSat;
    } else if (rtb_VectorConcatenate_a_idx_2 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_3_LowerSat) {
      rtb_VectorConcatenate_a_idx_2 =
        Lifting_wing_HIL_model_dll_P.Signal_Saturation_3_LowerSat;
    }

    // MATLAB Function: '<S174>/throttle2rads2' incorporates:
    //   Saturate: '<S174>/Signal_Saturation_3'

    Lifting_wing_HIL_throttle2rads2(rtb_VectorConcatenate_a_idx_2,
      &Lifting_wing_HIL_model_dll_B.sf_throttle2rads2);

    // Saturate: '<S174>/motorSpeed2'
    if (Lifting_wing_HIL_model_dll_B.sf_throttle2rads2.y >
        Lifting_wing_HIL_model_dll_P.motorSpeed2_UpperSat) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.motorSpeed2_UpperSat;
    } else if (Lifting_wing_HIL_model_dll_B.sf_throttle2rads2.y <
               Lifting_wing_HIL_model_dll_P.motorSpeed2_LowerSat) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.motorSpeed2_LowerSat;
    } else {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_B.sf_throttle2rads2.y;
    }

    // Product: '<S279>/Divide' incorporates:
    //   Constant: '<S279>/motorT'
    //   Saturate: '<S174>/motorSpeed2'
    //   Sum: '<S279>/Sum'

    Lifting_wing_HIL_model_dll_B.Divide_c = (rtb_Divide_idx_0 -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_k) /
      Lifting_wing_HIL_model_dll_P.ModelParam_motorT;

    // Saturate: '<S174>/Signal_Saturation_4'
    if (rtb_Lw_idx_1 > Lifting_wing_HIL_model_dll_P.Signal_Saturation_4_UpperSat)
    {
      rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_P.Signal_Saturation_4_UpperSat;
    } else if (rtb_Lw_idx_1 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_4_LowerSat) {
      rtb_Lw_idx_1 = Lifting_wing_HIL_model_dll_P.Signal_Saturation_4_LowerSat;
    }

    // MATLAB Function: '<S174>/throttle2rads3' incorporates:
    //   Saturate: '<S174>/Signal_Saturation_4'

    Lifting_wing_HIL_throttle2rads2(rtb_Lw_idx_1,
      &Lifting_wing_HIL_model_dll_B.sf_throttle2rads3);

    // Saturate: '<S174>/motorSpeed3'
    if (Lifting_wing_HIL_model_dll_B.sf_throttle2rads3.y >
        Lifting_wing_HIL_model_dll_P.motorSpeed3_UpperSat) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.motorSpeed3_UpperSat;
    } else if (Lifting_wing_HIL_model_dll_B.sf_throttle2rads3.y <
               Lifting_wing_HIL_model_dll_P.motorSpeed3_LowerSat) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.motorSpeed3_LowerSat;
    } else {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_B.sf_throttle2rads3.y;
    }

    // Product: '<S280>/Divide' incorporates:
    //   Constant: '<S280>/motorT'
    //   Saturate: '<S174>/motorSpeed3'
    //   Sum: '<S280>/Sum'

    Lifting_wing_HIL_model_dll_B.Divide_n = (rtb_Divide_idx_0 -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_o) /
      Lifting_wing_HIL_model_dll_P.ModelParam_motorT;

    // Sum: '<S281>/Add' incorporates:
    //   Constant: '<S281>/Constant'
    //   Constant: '<S281>/Constant1'
    //   Gain: '<S281>/Gain2'
    //   Sum: '<S281>/Sum3'

    rtb_Lw_idx_0 = (rtb_Signal_Saturation_7[4] -
                    Lifting_wing_HIL_model_dll_P.Constant1_Value_d[0]) *
      Lifting_wing_HIL_model_dll_P.Gain2_Gain_b -
      Lifting_wing_HIL_model_dll_P.Constant_Value_pq[0];
    rtb_Lw_idx_1 = (rtb_Signal_Saturation_7[5] -
                    Lifting_wing_HIL_model_dll_P.Constant1_Value_d[1]) *
      Lifting_wing_HIL_model_dll_P.Gain2_Gain_b -
      Lifting_wing_HIL_model_dll_P.Constant_Value_pq[1];

    // Saturate: '<S174>/Signal_Saturation_5'
    if (rtb_Lw_idx_0 > Lifting_wing_HIL_model_dll_P.Signal_Saturation_5_UpperSat)
    {
      fphi = Lifting_wing_HIL_model_dll_P.Signal_Saturation_5_UpperSat;
    } else if (rtb_Lw_idx_0 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_5_LowerSat) {
      fphi = Lifting_wing_HIL_model_dll_P.Signal_Saturation_5_LowerSat;
    } else {
      fphi = rtb_Lw_idx_0;
    }

    // End of Saturate: '<S174>/Signal_Saturation_5'

    // Switch: '<S286>/Switch' incorporates:
    //   Constant: '<S286>/Constant'
    //   Constant: '<S286>/Constant1'

    if (fphi > Lifting_wing_HIL_model_dll_P.Switch_Threshold_d) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.ModelParam_rDeltamax;
    } else {
      rtb_Divide_idx_0 = -Lifting_wing_HIL_model_dll_P.ModelParam_rDeltamin;
    }

    // Product: '<S282>/Divide' incorporates:
    //   Constant: '<S282>/motorT'
    //   Product: '<S286>/Product'
    //   Sum: '<S282>/Sum'
    //   Switch: '<S286>/Switch'

    Lifting_wing_HIL_model_dll_B.Divide_b = (rtb_Divide_idx_0 * fphi -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_kn) /
      Lifting_wing_HIL_model_dll_P.ModelParam_servoT;

    // Saturate: '<S174>/Signal_Saturation_6'
    if (rtb_Lw_idx_1 > Lifting_wing_HIL_model_dll_P.Signal_Saturation_6_UpperSat)
    {
      fphi = Lifting_wing_HIL_model_dll_P.Signal_Saturation_6_UpperSat;
    } else if (rtb_Lw_idx_1 <
               Lifting_wing_HIL_model_dll_P.Signal_Saturation_6_LowerSat) {
      fphi = Lifting_wing_HIL_model_dll_P.Signal_Saturation_6_LowerSat;
    } else {
      fphi = rtb_Lw_idx_1;
    }

    // End of Saturate: '<S174>/Signal_Saturation_6'

    // Switch: '<S287>/Switch' incorporates:
    //   Constant: '<S287>/Constant'
    //   Constant: '<S287>/Constant1'

    if (fphi > Lifting_wing_HIL_model_dll_P.Switch_Threshold_b) {
      rtb_Divide_idx_0 = Lifting_wing_HIL_model_dll_P.ModelParam_lDeltamax;
    } else {
      rtb_Divide_idx_0 = -Lifting_wing_HIL_model_dll_P.ModelParam_lDeltamin;
    }

    // Product: '<S283>/Divide' incorporates:
    //   Constant: '<S283>/motorT'
    //   Product: '<S287>/Product'
    //   Sum: '<S283>/Sum'
    //   Switch: '<S287>/Switch'

    Lifting_wing_HIL_model_dll_B.Divide_h = (rtb_Divide_idx_0 * fphi -
      Lifting_wing_HIL_model_dll_B.DiscreteTimeIntegrator_c) /
      Lifting_wing_HIL_model_dll_P.ModelParam_servoT;

    // Gain: '<S308>/High Gain Quaternion Normalization' incorporates:
    //   Constant: '<S308>/Constant'
    //   Sum: '<S308>/Sum'

    fphi = (Lifting_wing_HIL_model_dll_P.Constant_Value_f4 -
            VectorConcatenate_tmp) *
      Lifting_wing_HIL_model_dll_P.uDOFQuaternion_k_quat;

    // SignalConversion generated from: '<S297>/q0 q1 q2 q3' incorporates:
    //   Fcn: '<S308>/q0dot'
    //   Fcn: '<S308>/q1dot'
    //   Fcn: '<S308>/q2dot'
    //   Fcn: '<S308>/q3dot'

    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[0] =
      ((rtb_Product_d[0] * rtb_q0q1q2q3_idx_1 + rtb_Product_d[1] *
        rtb_q0q1q2q3_idx_2) + rtb_Product_d[2] * rtb_q0q1q2q3_idx_3) * -0.5 +
      fphi * rtb_q0q1q2q3_idx_0;
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[1] =
      ((rtb_q0q1q2q3_idx_0 * rtb_Product_d[0] + rtb_q0q1q2q3_idx_2 *
        rtb_Product_d[2]) - rtb_Product_d[1] * rtb_q0q1q2q3_idx_3) * 0.5 + fphi *
      rtb_q0q1q2q3_idx_1;
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[2] =
      ((rtb_q0q1q2q3_idx_0 * rtb_Product_d[1] + rtb_Product_d[0] *
        rtb_q0q1q2q3_idx_3) - rtb_q0q1q2q3_idx_1 * rtb_Product_d[2]) * 0.5 +
      fphi * rtb_q0q1q2q3_idx_2;
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[3] =
      ((rtb_q0q1q2q3_idx_0 * rtb_Product_d[2] + rtb_q0q1q2q3_idx_1 *
        rtb_Product_d[1]) - rtb_Product_d[0] * rtb_q0q1q2q3_idx_2) * 0.5 + fphi *
      rtb_q0q1q2q3_idx_3;
    if (tmp) {
      // If: '<S339>/If1' incorporates:
      //   Constant: '<S339>/Constant'

      rtAction = -1;
      if (tmp_0) {
        if (Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuater_n > 1) {
          rtAction = 0;
        }

        Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem_l = rtAction;
      } else {
        rtAction = Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem_l;
      }

      if (rtAction == 0) {
        // Outputs for IfAction SubSystem: '<S339>/If Warning//Error' incorporates:
        //   ActionPort: '<S363>/if'

        Lifting_wing_HIL_IfWarningError(VectorConcatenate,
          Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuater_n,
          Lifting_wing_HIL_model_dll_P.DirectionCosineMatrixtoQuater_f,
          &Lifting_wing_HIL_model_dll_P.IfWarningError_i);

        // End of Outputs for SubSystem: '<S339>/If Warning//Error'
      }

      // MATLAB Function: '<S379>/failture_baro_nb_var' incorporates:
      //   Inport: '<Root>/inSILInts'

      // global GPS_multipath_effect_en motor_stop_en battery_short_en
      // MATLAB Function 'udp_receiver/MATLAB Function': '<S378>:1'
      // '<S378>:1:5' if isempty(GPS_multipath_effect_en_)
      // '<S378>:1:13' index = 0;
      // '<S378>:1:14' motor_stop = 0;
      // '<S378>:1:15' time_r = timestamp;
      // '<S378>:1:16' if u(1) == 255 && u(4) == 250
      // '<S378>:1:43' GPS_multipath_effect_en = GPS_multipath_effect_en_;
      // '<S378>:1:44' motor_stop_en = motor_stop_en_;
      // '<S378>:1:45' battery_short_en = battery_short_en_;
      // '<S378>:1:46' GPS_search_failed_en = GPS_search_failed_en_;
      // '<S378>:1:47' GPS_communication_interrupted_en = GPS_communication_interrupted_en_; 
      // '<S378>:1:48' IMU_communication_interrupted_en = IMU_communication_interrupted_en_; 
      //
      // MATLAB Function 'udp_receiver/Subsystem/failture_baro_nb_var': '<S386>:1' 
      // '<S386>:1:4' if isempty(baro_nb_var_init)
      // '<S386>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_gj) {
        // '<S386>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_gj = true;
      }

      // '<S386>:1:20' baro_nb_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S386>:1:21' if type ==93
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 93.0F) {
        // '<S386>:1:22' baro_nb_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.baro_nb_var_en = DataTypeConversion1[0];

        // '<S386>:1:23' baro_nb_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S386>:1:24' baro_nb_var_T = data(3: 2+baro_nb_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.baro_nb_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.baro_nb_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S386>:1:25' N = length(baro_nb_var_T);
        // '<S386>:1:26' if  N~=baro_nb_var_N
        // '<S386>:1:30' baro_nb_var_dt = zeros(N, 1);
        // '<S386>:1:31' if baro_nb_var_N >= 9
        if (!(DataTypeConversion1[1] >= 9.0)) {
          // '<S386>:1:33' else
          // '<S386>:1:34' baro_nb_var_dt(1:baro_nb_var_N) = data(3+baro_nb_var_N:2+2*baro_nb_var_N); 
          // '<S386>:1:35' baro_nb_var_am = data(3+2*baro_nb_var_N:4+2*baro_nb_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.baro_nb_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.baro_nb_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.baro_nb_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        } else {
          // '<S386>:1:32' baro_nb_var_dt(1:18 - baro_nb_var_N) = data(3+baro_nb_var_N:20); 
        }
      }

      // '<S386>:1:44' baro_nb_var_default = 1;
      // '<S386>:1:45' baro_nb_var = 1;
      // '<S386>:1:46' x = baro_nb_var_default;
      // 
      // '<S386>:1:48' if baro_nb_var_en && ~baro_nb_var_init
      if ((Lifting_wing_HIL_model_dll_DW.baro_nb_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.baro_nb_var_init != 0.0))) {
        // '<S386>:1:49' timestart = timestamp;
        // '<S386>:1:50' baro_nb_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.baro_nb_var_init = 1.0;

        // '<S386>:1:51' N = length(baro_nb_var_T);
        // '<S386>:1:52' baro_nb_var_am_rand = ones(N, 1);
        // '<S386>:1:53' v = zeros(N, 1);
        // '<S386>:1:54' for i = 1 : baro_nb_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S386>:1:55' baro_nb_var_am_rand(i) = data_gen1(baro_nb_var_am(1), baro_nb_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S386>:1:107' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_d();

          // '<S386>:1:56' v(i) = 0;
        }

        // '<S386>:1:58' x_init  = baro_nb_var_am_rand;
      }

      // '<S386>:1:61' if baro_nb_var_en
      if (!(Lifting_wing_HIL_model_dll_DW.baro_nb_var_en != 0.0)) {
        // '<S386>:1:65' else
        // '<S386>:1:66' baro_nb_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.baro_nb_var_init = 0.0;

        // '<S386>:1:67' baro_nb_var= baro_nb_var_default;
      } else {
        // 
        // '<S386>:1:63' runtime = timestamp - timestart;
        // '<S386>:1:64' baro_nb_var(1)= param_gen(runtime, x, x_init, baro_nb_var_T, v , baro_nb_var_dt ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S386>:1:82' N = length(x_init);
        // '<S386>:1:84' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S379>/failture_baro_nb_var'

      // MATLAB Function: '<S379>/failture_baro_nbb_var' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/Subsystem/failture_baro_nbb_var': '<S387>:1' 
      // '<S387>:1:4' if isempty(baro_nbb_var_init)
      // '<S387>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_nr) {
        // '<S387>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_nr = true;
      }

      // '<S387>:1:20' baro_nbb_var_N = 1;
      // '<S387>:1:21' if type ==91
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 91.0F) {
        // '<S387>:1:22' baro_nbb_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.baro_nbb_var_en = DataTypeConversion1[0];

        // '<S387>:1:23' baro_nbb_var_N = data(2);
        // 
        // '<S387>:1:24' baro_nbb_var_T = data(3: 2+baro_nbb_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S387>:1:25' N = length(baro_nbb_var_T);
        // '<S387>:1:26' if  N~=baro_nbb_var_N
        // '<S387>:1:30' baro_nbb_var_dt = zeros(N, 1);
        // '<S387>:1:31' if baro_nbb_var_N >= 9
        if (!(DataTypeConversion1[1] >= 9.0)) {
          // '<S387>:1:33' else
          // '<S387>:1:34' baro_nbb_var_dt(1:baro_nbb_var_N) = data(3+baro_nbb_var_N:2+2*baro_nbb_var_N); 
          // '<S387>:1:35' baro_nbb_var_am = data(3+2*baro_nbb_var_N:4+2*baro_nbb_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        } else {
          // '<S387>:1:32' baro_nbb_var_dt(1:18 - baro_nbb_var_N) = data(3+baro_nbb_var_N:20); 
        }
      }

      // '<S387>:1:44' baro_nbb_var_default = 1;
      // '<S387>:1:45' baro_nbb_var = 1;
      // '<S387>:1:46' x = baro_nbb_var_default;
      // 
      // '<S387>:1:48' if baro_nbb_var_en && ~baro_nbb_var_init
      if ((Lifting_wing_HIL_model_dll_DW.baro_nbb_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.baro_nbb_var_init != 0.0))) {
        // '<S387>:1:49' timestart = timestamp;
        // '<S387>:1:50' baro_nbb_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.baro_nbb_var_init = 1.0;

        // '<S387>:1:51' N = length(baro_nbb_var_T);
        // '<S387>:1:52' baro_nbb_var_am_rand = ones(N, 1);
        Lifting_wing_HIL_model_dll_DW.x_init_hs.size[0] =
          Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.size[0];

        // '<S387>:1:53' v = zeros(N, 1);
        // '<S387>:1:54' for i = 1 : N
        rtb_lon = Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.size[0];
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S387>:1:55' baro_nbb_var_am_rand(i) = data_gen1(baro_nbb_var_am(1), baro_nbb_var_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S387>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_dll_DW.x_init_hs.data[rtb_lat] = (rtb_Switch -
            Merge) * Lifting_wing_HIL_model__rand_dm() + Merge;

          // '<S387>:1:56' v(i) = 0;
        }

        // '<S387>:1:58' x_init  = baro_nbb_var_am_rand;
      }

      // '<S387>:1:61' if baro_nbb_var_en
      if (!(Lifting_wing_HIL_model_dll_DW.baro_nbb_var_en != 0.0)) {
        // '<S387>:1:66' else
        // '<S387>:1:67' baro_nbb_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.baro_nbb_var_init = 0.0;

        // '<S387>:1:68' baro_nbb_var= baro_nbb_var_default;
      } else {
        // 
        // '<S387>:1:63' runtime = timestamp - timestart;
        // '<S387>:1:64' baro_nbb_var(1)= param_gen(runtime, x, x_init , baro_nbb_var_T, v , baro_nbb_var_dt ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S387>:1:83' N = length(x_init);
        // '<S387>:1:85' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S379>/failture_baro_nbb_var'

      // MATLAB Function: '<S380>/failture_accel_ka_ca' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_accel1/failture_accel_ka_ca': '<S388>:1' 
      // '<S388>:1:5' if isempty(accel_init)
      // '<S388>:1:13' if type == 31
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 31.0F) {
        // '<S388>:1:14' accel_kg_cg_en = data(1);
        Lifting_wing_HIL_model_dll_DW.accel_kg_cg_en = DataTypeConversion1[0];

        // '<S388>:1:15' accel_kg__N = data(2);
        // 
        // '<S388>:1:16' accel_kg_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.accel_kg_limit.size[0] = 2;

        // '<S388>:1:17' accel_cg_limit =  data(5: 6 );
        Lifting_wing_HIL_model_dll_DW.accel_cg_limit.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.accel_kg_limit.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.accel_cg_limit.data[0] =
          DataTypeConversion1[4];
        Lifting_wing_HIL_model_dll_DW.accel_kg_limit.data[1] =
          DataTypeConversion1[3];
        Lifting_wing_HIL_model_dll_DW.accel_cg_limit.data[1] =
          DataTypeConversion1[5];
      }

      // '<S388>:1:22' if accel_kg_cg_en
      if (Lifting_wing_HIL_model_dll_DW.accel_kg_cg_en != 0.0) {
        // '<S388>:1:23' if ~accel_init
        if (!(Lifting_wing_HIL_model_dll_DW.accel_init != 0.0)) {
          // '<S388>:1:24' accel_init = 1;
          Lifting_wing_HIL_model_dll_DW.accel_init = 1.0;

          // '<S388>:1:25' accel_kg(1) = data_gen1(accel_kg_limit(1), accel_kg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();

          // '<S388>:1:26' accel_kg(2) = data_gen1(accel_kg_limit(1), accel_kg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();

          // '<S388>:1:27' accel_kg(3) = data_gen1(accel_kg_limit(1), accel_kg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();

          // '<S388>:1:28' accel_cg(1) = data_gen1(accel_cg_limit(1), accel_cg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();

          // '<S388>:1:29' accel_cg(2) = data_gen1(accel_cg_limit(1), accel_cg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();

          // '<S388>:1:30' accel_cg(3) = data_gen1(accel_cg_limit(1), accel_cg_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S388>:1:52' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_b();
        }
      } else {
        // '<S388>:1:32' else
        // '<S388>:1:33' accel_init = 0;
        Lifting_wing_HIL_model_dll_DW.accel_init = 0.0;

        // '<S388>:1:34' accel_kg = ones(3, 1);
        // '<S388>:1:35' accel_cg = zeros(3, 1);
      }

      // End of MATLAB Function: '<S380>/failture_accel_ka_ca'

      // MATLAB Function: '<S380>/failture_accel_kap' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S388>:1:38' yaccel_kg = accel_kg;
      // '<S388>:1:39' yaccel_cg = accel_cg;
      //
      // MATLAB Function 'udp_receiver/failture_accel1/failture_accel_kap': '<S389>:1' 
      // '<S389>:1:4' if isempty(accel_kgp_init)
      // '<S389>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_mc) {
        // '<S389>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_mc = true;
      }

      // '<S389>:1:17' accel_kgp_N = 1;
      Merge = 1.0;

      // '<S389>:1:18' if type ==33
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 33.0F) {
        // '<S389>:1:19' accel_kgp_en = data(1);
        Lifting_wing_HIL_model_dll_DW.accel_kgp_en = DataTypeConversion1[0];

        // '<S389>:1:20' accel_kgp_N = data(2);
        Merge = DataTypeConversion1[1];

        // 
        // '<S389>:1:21' accel_kgp_T = data(3: 2+accel_kgp_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.accel_kgp_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.accel_kgp_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S389>:1:22' N = length(accel_kgp_T);
        // '<S389>:1:23' if  N~=accel_kgp_N
        // '<S389>:1:27' accel_kgp_dt = 0.01*ones(N, 1);
        // '<S389>:1:28' accel_kgp_am = data(3+accel_kgp_N:4+accel_kgp_N);
        Lifting_wing_HIL_model_dll_DW.accel_kgp_am.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.accel_kgp_am.data[0] =
          DataTypeConversion1[static_cast<int32_T>(DataTypeConversion1[1] + 3.0)
          - 1];
        Lifting_wing_HIL_model_dll_DW.accel_kgp_am.data[1] =
          DataTypeConversion1[static_cast<int32_T>((DataTypeConversion1[1] + 3.0)
          + 1.0) - 1];

        //           if accel_kgp_N < 16
        //                  accel_kgp_dt(1:18 - accel_kgp_N) = data(3+accel_kgp_N:20); 
        //           else
        //                  accel_kgp_dt(1:accel_kgp_N) = data(3+accel_kgp_N:2+2*accel_kgp_N); 
        //                  accel_kgp_am = data(3+2*accel_kgp_N:4+2*accel_kgp_N); 
        //           end
      }

      // '<S389>:1:42' accel_kgp_default = ones(3,1);
      // '<S389>:1:43' accel_kgp = ones(3,1);
      // '<S389>:1:44' x = accel_kgp_default;
      // 
      // '<S389>:1:46' if accel_kgp_en && ~accel_kgp_init
      if ((Lifting_wing_HIL_model_dll_DW.accel_kgp_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.accel_kgp_init != 0.0))) {
        // '<S389>:1:47' accel_kgp_init = 1;
        Lifting_wing_HIL_model_dll_DW.accel_kgp_init = 1.0;

        // '<S389>:1:48' timestart = timestamp;
        // '<S389>:1:49' N = length(accel_kgp_T);
        // '<S389>:1:50' accel_kgp_am_rand = ones(N, 3);
        // '<S389>:1:51' v = zeros(N, 1);
        // '<S389>:1:52' for i = 1 : accel_kgp_N
        rtb_lat = static_cast<int32_T>(Merge);
        for (rtb_lon = 0; rtb_lon < rtb_lat; rtb_lon++) {
          // '<S389>:1:53' accel_kgp_am_rand(i, 1) = data_gen1(accel_kgp_am(1), accel_kgp_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S389>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_k();

          // '<S389>:1:54' accel_kgp_am_rand(i, 2) = data_gen1(accel_kgp_am(1), accel_kgp_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S389>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_k();

          // '<S389>:1:55' accel_kgp_am_rand(i, 3) = data_gen1(accel_kgp_am(1), accel_kgp_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S389>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_k();

          // '<S389>:1:56' v(i) = 0;
        }

        // '<S389>:1:58' x_init  = accel_kgp_am_rand;
      }

      // '<S389>:1:61' if accel_kgp_en
      if (!(Lifting_wing_HIL_model_dll_DW.accel_kgp_en != 0.0)) {
        // '<S389>:1:67' else
        // '<S389>:1:68' accel_kgp_init = 0;
        Lifting_wing_HIL_model_dll_DW.accel_kgp_init = 0.0;

        // '<S389>:1:69' accel_kgp= accel_kgp_default;
      } else {
        // 
        // '<S389>:1:63' runtime = timestamp - timestart;
        // '<S389>:1:64' accel_kgp(1)= param_gen(runtime, x(1), x_init(:, 1) , accel_kgp_T, v , accel_kgp_dt ); 
        // '<S389>:1:65' accel_kgp(2)= param_gen(runtime, x(2), x_init(:, 2) , accel_kgp_T, v , accel_kgp_dt ); 
        // '<S389>:1:66' accel_kgp(3)= param_gen(runtime, x(3), x_init(:, 3) , accel_kgp_T, v , accel_kgp_dt ); 
      }

      // End of MATLAB Function: '<S380>/failture_accel_kap'

      // MATLAB Function: '<S380>/failture_accel_na_var' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_accel1/failture_accel_na_var': '<S390>:1' 
      // '<S390>:1:4' if isempty(accel_na_var_init)
      // '<S390>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_ca) {
        // '<S390>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_ca = true;
      }

      // '<S390>:1:20' accel_na_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S390>:1:21' if type ==37
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 37.0F) {
        // '<S390>:1:22' accel_na_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.accel_na_var_en = DataTypeConversion1[0];

        // '<S390>:1:23' accel_na_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S390>:1:24' accel_na_var_T = data(3: 2+accel_na_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.accel_na_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.accel_na_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S390>:1:25' N = length(accel_na_var_T);
        // '<S390>:1:26' if  N~=accel_na_var_N
        // '<S390>:1:30' accel_na_var_dt = zeros(N, 1);
        // '<S390>:1:31' if accel_na_var_N >= 9
        if (!(DataTypeConversion1[1] >= 9.0)) {
          // '<S390>:1:33' else
          // '<S390>:1:34' accel_na_var_dt(1:accel_na_var_N) = data(3+accel_na_var_N:2+2*accel_na_var_N); 
          // '<S390>:1:35' accel_na_var_am = data(3+2*accel_na_var_N:4+2*accel_na_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.accel_na_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.accel_na_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.accel_na_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        } else {
          // '<S390>:1:32' accel_na_var_dt(1:18 - accel_na_var_N) = data(3+accel_na_var_N:20); 
        }
      }

      // '<S390>:1:44' accel_na_var_default = ones(3,1);
      // '<S390>:1:45' accel_na_var = ones(3,1);
      // '<S390>:1:46' x = accel_na_var_default;
      // 
      // '<S390>:1:48' if accel_na_var_en && ~accel_na_var_init
      if ((Lifting_wing_HIL_model_dll_DW.accel_na_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.accel_na_var_init != 0.0))) {
        // '<S390>:1:49' timestart = timestamp;
        // '<S390>:1:50' accel_na_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.accel_na_var_init = 1.0;

        // '<S390>:1:51' N = length(accel_na_var_T);
        // '<S390>:1:52' accel_na_var_am_rand = ones(N, 3);
        // '<S390>:1:53' v = zeros(N, 1);
        // '<S390>:1:54' for i = 1 : accel_na_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S390>:1:55' accel_na_var_am_rand(i, 1) = data_gen1(accel_na_var_am(1), accel_na_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S390>:1:111' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_h();

          // '<S390>:1:56' accel_na_var_am_rand(i, 2) = data_gen1(accel_na_var_am(1), accel_na_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S390>:1:111' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_h();

          // '<S390>:1:57' accel_na_var_am_rand(i, 3) = data_gen1(accel_na_var_am(1), accel_na_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S390>:1:111' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_h();

          // '<S390>:1:58' v(i) = 0;
        }

        // '<S390>:1:60' x_init  = accel_na_var_am_rand;
      }

      // '<S390>:1:63' if accel_na_var_en
      if (!(Lifting_wing_HIL_model_dll_DW.accel_na_var_en != 0.0)) {
        // '<S390>:1:69' else
        // '<S390>:1:70' accel_na_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.accel_na_var_init = 0.0;

        // '<S390>:1:71' accel_na_var= accel_na_var_default;
      } else {
        // 
        // '<S390>:1:65' runtime = timestamp - timestart;
        // '<S390>:1:66' accel_na_var(1)= param_gen(runtime, x(1), x_init(:, 1) , accel_na_var_T, v , accel_na_var_dt ); 
        // '<S390>:1:67' accel_na_var(2)= param_gen(runtime, x(2), x_init(:, 2) , accel_na_var_T, v , accel_na_var_dt ); 
        // '<S390>:1:68' accel_na_var(3)= param_gen(runtime, x(3), x_init(:, 3) , accel_na_var_T, v , accel_na_var_dt ); 
      }

      // End of MATLAB Function: '<S380>/failture_accel_na_var'

      // MATLAB Function: '<S380>/failture_accel_nba_var' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_accel1/failture_accel_nba_var': '<S391>:1' 
      // '<S391>:1:4' if isempty(accel_nbg_var_init)
      // '<S391>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d4) {
        // '<S391>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d4 = true;
      }

      // '<S391>:1:18' accel_nbg_var_N = 1;
      rtb_q3dot = 1.0;

      // '<S391>:1:19' if type ==35
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 35.0F) {
        // '<S391>:1:20' accel_nbg_var_en = data(1);
        Lifting_wing_HIL_model_dll_DW.accel_nbg_var_en = DataTypeConversion1[0];

        // '<S391>:1:21' accel_nbg_var_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S391>:1:22' accel_nbg_var_T = data(3: 2+accel_nbg_var_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.accel_nbg_var_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.accel_nbg_var_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S391>:1:23' N = length(accel_nbg_var_T);
        // '<S391>:1:24' if  N~=accel_nbg_var_N
        // '<S391>:1:28' accel_nbg_var_dt = zeros(N, 1);
        // '<S391>:1:29' if accel_nbg_var_N >= 9
        if (!(DataTypeConversion1[1] >= 9.0)) {
          // '<S391>:1:31' else
          // '<S391>:1:32' accel_nbg_var_dt(1:accel_nbg_var_N) = data(3+accel_nbg_var_N:2+2*accel_nbg_var_N); 
          // '<S391>:1:33' accel_nbg_var_am = data(3+2*accel_nbg_var_N:4+2*accel_nbg_var_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.accel_nbg_var_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.accel_nbg_var_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.accel_nbg_var_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        } else {
          // '<S391>:1:30' accel_nbg_var_dt(1:18 - accel_nbg_var_N) = data(3+accel_nbg_var_N:20); 
        }
      }

      // '<S391>:1:42' accel_nbg_var_default = ones(3,1);
      // '<S391>:1:43' accel_nbg_var = ones(3,1);
      // '<S391>:1:44' x = accel_nbg_var_default;
      // 
      // '<S391>:1:46' if accel_nbg_var_en && ~accel_nbg_var_init
      if ((Lifting_wing_HIL_model_dll_DW.accel_nbg_var_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.accel_nbg_var_init != 0.0))) {
        // '<S391>:1:47' accel_nbg_var_init = 1;
        Lifting_wing_HIL_model_dll_DW.accel_nbg_var_init = 1.0;

        // '<S391>:1:48' timestart = timestamp;
        // '<S391>:1:49' N = length(accel_nbg_var_T);
        // '<S391>:1:50' accel_nbg_var_am_rand = ones(N, 3);
        // '<S391>:1:51' v = zeros(N, 1);
        // '<S391>:1:52' for i = 1 : accel_nbg_var_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S391>:1:53' accel_nbg_var_am_rand(i, 1) = data_gen1(accel_nbg_var_am(1), accel_nbg_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S391>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_g();

          // '<S391>:1:54' accel_nbg_var_am_rand(i, 2) = data_gen1(accel_nbg_var_am(1), accel_nbg_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S391>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_g();

          // '<S391>:1:55' accel_nbg_var_am_rand(i, 3) = data_gen1(accel_nbg_var_am(1), accel_nbg_var_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S391>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_g();

          // '<S391>:1:56' v(i) = 0;
        }

        // '<S391>:1:58' x_init  = accel_nbg_var_am_rand;
      }

      // '<S391>:1:61' if accel_nbg_var_en
      if (!(Lifting_wing_HIL_model_dll_DW.accel_nbg_var_en != 0.0)) {
        // '<S391>:1:67' else
        // '<S391>:1:68' accel_nbg_var_init = 0;
        Lifting_wing_HIL_model_dll_DW.accel_nbg_var_init = 0.0;

        // '<S391>:1:69' accel_nbg_var= accel_nbg_var_default;
      } else {
        // 
        // '<S391>:1:63' runtime = timestamp - timestart;
        // '<S391>:1:64' accel_nbg_var(1)= param_gen(runtime, x(1), x_init(:, 1) , accel_nbg_var_T, v , accel_nbg_var_dt ); 
        // '<S391>:1:65' accel_nbg_var(2)= param_gen(runtime, x(2), x_init(:, 2) , accel_nbg_var_T, v , accel_nbg_var_dt ); 
        // '<S391>:1:66' accel_nbg_var(3)= param_gen(runtime, x(3), x_init(:, 3) , accel_nbg_var_T, v , accel_nbg_var_dt ); 
      }

      // End of MATLAB Function: '<S380>/failture_accel_nba_var'

      // MATLAB Function: '<S382>/failture_mag_dm' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_mag1/failture_mag_dm': '<S396>:1' 
      // '<S396>:1:4' if isempty(mag_dm_init)
      // '<S396>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_b) {
        // '<S396>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_b = true;
      }

      // '<S396>:1:18' mag_dm_N = 1;
      rtb_q3dot = 1.0;

      // '<S396>:1:19' if type ==63
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 63.0F) {
        // '<S396>:1:20' mag_dm_en = data(1);
        Lifting_wing_HIL_model_dll_DW.mag_dm_en = DataTypeConversion1[0];

        // '<S396>:1:21' mag_dm_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S396>:1:22' mag_dm_T = data(3: 2+mag_dm_N);
        if (DataTypeConversion1[1] + 2.0 < 3.0) {
          rtb_lat = 0;
          rtb_lon = 0;
        } else {
          rtb_lat = 2;
          rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 2.0);
        }

        Comega_tmp = rtb_lon - rtb_lat;
        Lifting_wing_HIL_model_dll_DW.mag_dm_T.size[0] = Comega_tmp;
        for (i = 0; i < Comega_tmp; i++) {
          Lifting_wing_HIL_model_dll_DW.mag_dm_T.data[i] =
            DataTypeConversion1[rtb_lat + i];
        }

        // '<S396>:1:23' N = length(mag_dm_T);
        // '<S396>:1:24' if  N~=mag_dm_N
        // '<S396>:1:28' mag_dm_dt = zeros(N, 1);
        // '<S396>:1:29' if mag_dm_N >= 9
        if (!(DataTypeConversion1[1] >= 9.0)) {
          // '<S396>:1:31' else
          // '<S396>:1:32' mag_dm_dt(1:mag_dm_N) = data(3+mag_dm_N:2+2*mag_dm_N); 
          // '<S396>:1:33' mag_dm_am = data(3+2*mag_dm_N:4+2*mag_dm_N);
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.mag_dm_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.mag_dm_am.data[0] = DataTypeConversion1[
            static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.mag_dm_am.data[1] = DataTypeConversion1[
            static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        } else {
          // '<S396>:1:30' mag_dm_dt(1:18 - mag_dm_N) = data(3+mag_dm_N:20);
        }
      }

      // '<S396>:1:42' mag_dm_default = zeros(3,1);
      // '<S396>:1:43' mag_dm = zeros(3,1);
      // '<S396>:1:44' x = mag_dm_default;
      // 
      // '<S396>:1:46' if mag_dm_en && ~mag_dm_init
      if ((Lifting_wing_HIL_model_dll_DW.mag_dm_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.mag_dm_init != 0.0))) {
        // '<S396>:1:47' mag_dm_init = 1;
        Lifting_wing_HIL_model_dll_DW.mag_dm_init = 1.0;

        // '<S396>:1:48' timestart = timestamp;
        // '<S396>:1:49' N = length(mag_dm_T);
        // '<S396>:1:50' mag_dm_am_rand = ones(N, 3);
        // '<S396>:1:51' v = zeros(N, 1);
        // '<S396>:1:52' for i = 1 : mag_dm_N
        rtb_lon = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < rtb_lon; rtb_lat++) {
          // '<S396>:1:53' mag_dm_am_rand(i, 1) = data_gen1(mag_dm_am(1), mag_dm_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S396>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_j();

          // '<S396>:1:54' mag_dm_am_rand(i, 2) = data_gen1(mag_dm_am(1), mag_dm_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S396>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_j();

          // '<S396>:1:55' mag_dm_am_rand(i, 3) = data_gen1(mag_dm_am(1), mag_dm_am(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S396>:1:108' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_j();

          // '<S396>:1:56' v(i) = 0;
        }

        // '<S396>:1:58' x_init  = mag_dm_am_rand;
      }

      // '<S396>:1:61' if mag_dm_en
      if (!(Lifting_wing_HIL_model_dll_DW.mag_dm_en != 0.0)) {
        // '<S396>:1:67' else
        // '<S396>:1:68' mag_dm_init = 0;
        Lifting_wing_HIL_model_dll_DW.mag_dm_init = 0.0;

        // '<S396>:1:69' mag_dm= mag_dm_default;
      } else {
        // 
        // '<S396>:1:63' runtime = timestamp - timestart;
        // '<S396>:1:64' mag_dm(1)= param_gen(runtime, x(1), x_init(:, 1) , mag_dm_T, v , mag_dm_dt ); 
        // '<S396>:1:65' mag_dm(2)= param_gen(runtime, x(2), x_init(:, 2) , mag_dm_T, v , mag_dm_dt ); 
        // '<S396>:1:66' mag_dm(3)= param_gen(runtime, x(3), x_init(:, 3) , mag_dm_T, v , mag_dm_dt ); 
      }

      // End of MATLAB Function: '<S382>/failture_mag_dm'

      // MATLAB Function: '<S383>/failture_motor1' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor1': '<S400>:1' 
      // '<S400>:1:5' if isempty(motor_init)
      // '<S400>:1:15' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_m) {
        // '<S400>:1:16' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_m = true;
      }

      // coder.varsize('motor_speed_dt',[1 20]);
      // coder.varsize('motor_speed_am',[1 20]);
      // coder.varsize('motor_speed_T',[1 20]);
      // '<S400>:1:21' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S400>:1:23' if type == 181
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 181.0F) {
        // '<S400>:1:24' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_i = DataTypeConversion1[0];

        // '<S400>:1:25' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S400>:1:26' assert (motor_speed_N <= 20);
        // '<S400>:1:27' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S400>:1:28' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S400>:1:29' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o = tmp_data_0;
        } else {
          // '<S400>:1:30' else
          // '<S400>:1:31' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o = tmp_data_0;

          // '<S400>:1:32' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S400>:1:35' if type == 182
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 182.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S400>:1:36' if motor_speed_N >= 9
        // '<S400>:1:37' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_o = tmp_data_0;

        // '<S400>:1:38' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S400>:1:42' motor_speed_default = 1;
      // '<S400>:1:43' motor_speed = 1;
      // '<S400>:1:44' x = motor_speed_default;
      // 
      // '<S400>:1:46' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_i != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_a2 != 0.0))) {
        // '<S400>:1:47' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_a2 = 1.0;

        // '<S400>:1:48' timestart = timestamp;
        // '<S400>:1:49' N = size(motor_speed_T, 2);
        // '<S400>:1:50' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S400>:1:52' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S400>:1:53' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S400>:1:107' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model_d_rand_l();

          // '<S400>:1:54' v(i) = 0;
        }

        // '<S400>:1:56' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_pc;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_pc =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S400>:1:59' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_i != 0.0)) {
        // '<S400>:1:63' else
        // '<S400>:1:64' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_a2 = 0.0;

        // '<S400>:1:65' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S400>:1:61' runtime = timestamp - timestart;
        // '<S400>:1:62' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S400>:1:82' N = length(x_init);
        // '<S400>:1:84' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor1'

      // MATLAB Function: '<S383>/failture_motor2' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor2': '<S401>:1' 
      // '<S401>:1:4' if isempty(motor_init)
      // '<S401>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_e) {
        // '<S401>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_e = true;
      }

      // '<S401>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S401>:1:19' if type == 186
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 186.0F) {
        // '<S401>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_d = DataTypeConversion1[0];

        // '<S401>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S401>:1:22' assert (motor_speed_N <= 20);
        // '<S401>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S401>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S401>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1 = tmp_data_0;
        } else {
          // '<S401>:1:26' else
          // '<S401>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1 = tmp_data_0;

          // '<S401>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S401>:1:31' if type == 187
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 187.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S401>:1:32' if motor_speed_N >= 9
        // '<S401>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c1 = tmp_data_0;

        // '<S401>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S401>:1:38' motor_speed_default = 1;
      // '<S401>:1:39' motor_speed = 1;
      // '<S401>:1:40' x = motor_speed_default;
      // 
      // '<S401>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_d != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_c4 != 0.0))) {
        // '<S401>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_c4 = 1.0;

        // '<S401>:1:44' timestart = timestamp;
        // '<S401>:1:45' N = size(motor_speed_T, 2);
        // '<S401>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S401>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S401>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S401>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_lh();

          // '<S401>:1:50' v(i) = 0;
        }

        // '<S401>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_lu;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_lu =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S401>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_d != 0.0)) {
        // '<S401>:1:59' else
        // '<S401>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_c4 = 0.0;

        // '<S401>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S401>:1:57' runtime = timestamp - timestart;
        // '<S401>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S401>:1:78' N = length(x_init);
        // '<S401>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor2'

      // MATLAB Function: '<S383>/failture_motor3' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor3': '<S402>:1' 
      // '<S402>:1:4' if isempty(motor_init)
      // '<S402>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_n) {
        // '<S402>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_n = true;
      }

      // '<S402>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S402>:1:19' if type == 191
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 191.0F) {
        // '<S402>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_o = DataTypeConversion1[0];

        // '<S402>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S402>:1:22' assert (motor_speed_N <= 20);
        // '<S402>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S402>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S402>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c = tmp_data_0;
        } else {
          // '<S402>:1:26' else
          // '<S402>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c = tmp_data_0;

          // '<S402>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S402>:1:31' if type == 192
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 192.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S402>:1:32' if motor_speed_N >= 9
        // '<S402>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_c = tmp_data_0;

        // '<S402>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S402>:1:38' motor_speed_default = 1;
      // '<S402>:1:39' motor_speed = 1;
      // '<S402>:1:40' x = motor_speed_default;
      // 
      // '<S402>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_o != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_m != 0.0))) {
        // '<S402>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_m = 1.0;

        // '<S402>:1:44' timestart = timestamp;
        // '<S402>:1:45' N = size(motor_speed_T, 2);
        // '<S402>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S402>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S402>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S402>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_kb();

          // '<S402>:1:50' v(i) = 0;
        }

        // '<S402>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_pt;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_pt =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S402>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_o != 0.0)) {
        // '<S402>:1:59' else
        // '<S402>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_m = 0.0;

        // '<S402>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S402>:1:57' runtime = timestamp - timestart;
        // '<S402>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S402>:1:78' N = length(x_init);
        // '<S402>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor3'

      // MATLAB Function: '<S383>/failture_motor4' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor4': '<S403>:1' 
      // '<S403>:1:4' if isempty(motor_init)
      // '<S403>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_ax) {
        // '<S403>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_ax = true;
      }

      // '<S403>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S403>:1:19' if type == 196
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 196.0F) {
        // '<S403>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_p = DataTypeConversion1[0];

        // '<S403>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S403>:1:22' assert (motor_speed_N <= 20);
        // '<S403>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S403>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S403>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be = tmp_data_0;
        } else {
          // '<S403>:1:26' else
          // '<S403>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be = tmp_data_0;

          // '<S403>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S403>:1:31' if type == 197
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 197.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S403>:1:32' if motor_speed_N >= 9
        // '<S403>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_be = tmp_data_0;

        // '<S403>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S403>:1:38' motor_speed_default = 1;
      // '<S403>:1:39' motor_speed = 1;
      // '<S403>:1:40' x = motor_speed_default;
      // 
      // '<S403>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_p != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_g != 0.0))) {
        // '<S403>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_g = 1.0;

        // '<S403>:1:44' timestart = timestamp;
        // '<S403>:1:45' N = size(motor_speed_T, 2);
        // '<S403>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S403>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S403>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S403>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_p0();

          // '<S403>:1:50' v(i) = 0;
        }

        // '<S403>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_bz;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_bz =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S403>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_p != 0.0)) {
        // '<S403>:1:59' else
        // '<S403>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_g = 0.0;

        // '<S403>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S403>:1:57' runtime = timestamp - timestart;
        // '<S403>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S403>:1:78' N = length(x_init);
        // '<S403>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor4'

      // MATLAB Function: '<S383>/failture_motor5' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor5': '<S404>:1' 
      // '<S404>:1:4' if isempty(motor_init)
      // '<S404>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_a) {
        // '<S404>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_a = true;
      }

      // '<S404>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S404>:1:19' if type == 201
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 201.0F) {
        // '<S404>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_h = DataTypeConversion1[0];

        // '<S404>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S404>:1:22' assert (motor_speed_N <= 20);
        // '<S404>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S404>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S404>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah = tmp_data_0;
        } else {
          // '<S404>:1:26' else
          // '<S404>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah = tmp_data_0;

          // '<S404>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S404>:1:31' if type == 202
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 202.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S404>:1:32' if motor_speed_N >= 9
        // '<S404>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_ah = tmp_data_0;

        // '<S404>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S404>:1:38' motor_speed_default = 1;
      // '<S404>:1:39' motor_speed = 1;
      // '<S404>:1:40' x = motor_speed_default;
      // 
      // '<S404>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_h != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_ci != 0.0))) {
        // '<S404>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_ci = 1.0;

        // '<S404>:1:44' timestart = timestamp;
        // '<S404>:1:45' N = size(motor_speed_T, 2);
        // '<S404>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S404>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S404>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S404>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model_d_rand_n();

          // '<S404>:1:50' v(i) = 0;
        }

        // '<S404>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_pa;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_pa =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S404>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_h != 0.0)) {
        // '<S404>:1:59' else
        // '<S404>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_ci = 0.0;

        // '<S404>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S404>:1:57' runtime = timestamp - timestart;
        // '<S404>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S404>:1:78' N = length(x_init);
        // '<S404>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor5'

      // MATLAB Function: '<S383>/failture_motor6' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor6': '<S405>:1' 
      // '<S405>:1:4' if isempty(motor_init)
      // '<S405>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fv) {
        // '<S405>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fv = true;
      }

      // '<S405>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S405>:1:19' if type == 206
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 206.0F) {
        // '<S405>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_m = DataTypeConversion1[0];

        // '<S405>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S405>:1:22' assert (motor_speed_N <= 20);
        // '<S405>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S405>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S405>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b = tmp_data_0;
        } else {
          // '<S405>:1:26' else
          // '<S405>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b = tmp_data_0;

          // '<S405>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S405>:1:31' if type == 207
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 207.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S405>:1:32' if motor_speed_N >= 9
        // '<S405>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_b = tmp_data_0;

        // '<S405>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S405>:1:38' motor_speed_default = 1;
      // '<S405>:1:39' motor_speed = 1;
      // '<S405>:1:40' x = motor_speed_default;
      // 
      // '<S405>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_m != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_n != 0.0))) {
        // '<S405>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_n = 1.0;

        // '<S405>:1:44' timestart = timestamp;
        // '<S405>:1:45' N = size(motor_speed_T, 2);
        // '<S405>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S405>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S405>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S405>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_ig();

          // '<S405>:1:50' v(i) = 0;
        }

        // '<S405>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_m;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_m = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S405>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_m != 0.0)) {
        // '<S405>:1:59' else
        // '<S405>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_n = 0.0;

        // '<S405>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S405>:1:57' runtime = timestamp - timestart;
        // '<S405>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S405>:1:78' N = length(x_init);
        // '<S405>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor6'

      // MATLAB Function: '<S383>/failture_motor7' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor7': '<S406>:1' 
      // '<S406>:1:4' if isempty(motor_init)
      // '<S406>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_k) {
        // '<S406>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_k = true;
      }

      // '<S406>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S406>:1:19' if type == 211
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 211.0F) {
        // '<S406>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en_l = DataTypeConversion1[0];

        // '<S406>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S406>:1:22' assert (motor_speed_N <= 20);
        // '<S406>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S406>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S406>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a = tmp_data_0;
        } else {
          // '<S406>:1:26' else
          // '<S406>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a = tmp_data_0;

          // '<S406>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S406>:1:31' if type == 212
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 212.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S406>:1:32' if motor_speed_N >= 9
        // '<S406>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt_a = tmp_data_0;

        // '<S406>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S406>:1:38' motor_speed_default = 1;
      // '<S406>:1:39' motor_speed = 1;
      // '<S406>:1:40' x = motor_speed_default;
      // 
      // '<S406>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en_l != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_d != 0.0))) {
        // '<S406>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_d = 1.0;

        // '<S406>:1:44' timestart = timestamp;
        // '<S406>:1:45' N = size(motor_speed_T, 2);
        // '<S406>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S406>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S406>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S406>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model_d_rand_f();

          // '<S406>:1:50' v(i) = 0;
        }

        // '<S406>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_l;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_l = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S406>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en_l != 0.0)) {
        // '<S406>:1:59' else
        // '<S406>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_d = 0.0;

        // '<S406>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S406>:1:57' runtime = timestamp - timestart;
        // '<S406>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S406>:1:78' N = length(x_init);
        // '<S406>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor7'

      // MATLAB Function: '<S383>/failture_motor8' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor8': '<S407>:1' 
      // '<S407>:1:4' if isempty(motor_init)
      // '<S407>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d) {
        // '<S407>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_d = true;
      }

      // '<S407>:1:18' motor_speed_N = 1;
      rtb_q3dot = 1.0;

      // '<S407>:1:19' if type == 216
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 216.0F) {
        // '<S407>:1:20' motor_speed_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_speed_en = DataTypeConversion1[0];

        // '<S407>:1:21' motor_speed_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S407>:1:22' assert (motor_speed_N <= 20);
        // '<S407>:1:23' motor_speed_T = data(3: 2+motor_speed_N);
        // '<S407>:1:24' if motor_speed_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S407>:1:25' motor_speed_dt(1:18 - motor_speed_N) = data(3+motor_speed_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt = tmp_data_0;
        } else {
          // '<S407>:1:26' else
          // '<S407>:1:27' motor_speed_dt(1:motor_speed_N) = data(3+motor_speed_N:2+2*motor_speed_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.motor_speed_dt = tmp_data_0;

          // '<S407>:1:28' motor_speed_am = data(3+2*motor_speed_N:4+2*motor_speed_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S407>:1:31' if type == 217
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 217.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S407>:1:32' if motor_speed_N >= 9
        // '<S407>:1:33' motor_speed_dt(19 - motor_speed_N : motor_speed_N) = data(1:2*motor_speed_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.motor_speed_dt;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.motor_speed_dt = tmp_data_0;

        // '<S407>:1:34' motor_speed_am = data(2*motor_speed_N -17: 2*motor_speed_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S407>:1:38' motor_speed_default = 1;
      // '<S407>:1:39' motor_speed = 1;
      // '<S407>:1:40' x = motor_speed_default;
      // 
      // '<S407>:1:42' if motor_speed_en && ~motor_init
      if ((Lifting_wing_HIL_model_dll_DW.motor_speed_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.motor_init_h != 0.0))) {
        // '<S407>:1:43' motor_init = 1;
        Lifting_wing_HIL_model_dll_DW.motor_init_h = 1.0;

        // '<S407>:1:44' timestart = timestamp;
        // '<S407>:1:45' N = size(motor_speed_T, 2);
        // '<S407>:1:46' motor_speed_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S407>:1:48' for i = 1 : motor_speed_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S407>:1:49' motor_speed_am_rand(i) = data_gen1(motor_speed_am(1), motor_speed_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S407>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_bt();

          // '<S407>:1:50' v(i) = 0;
        }

        // '<S407>:1:52' x_init(1:motor_speed_N)  = motor_speed_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_bp;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_bp =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S407>:1:55' if motor_speed_en
      if (!(Lifting_wing_HIL_model_dll_DW.motor_speed_en != 0.0)) {
        // '<S407>:1:59' else
        // '<S407>:1:60' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_h = 0.0;

        // '<S407>:1:61' motor_speed(1) = motor_speed_default;
      } else {
        // 
        // '<S407>:1:57' runtime = timestamp - timestart;
        // '<S407>:1:58' motor_speed(1)= param_gen(runtime, x, x_init(1:motor_speed_N) , motor_speed_T(1:motor_speed_N), v(1:motor_speed_N) , motor_speed_dt(1:motor_speed_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S407>:1:78' N = length(x_init);
        // '<S407>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S383>/failture_motor8'

      // MATLAB Function: '<S383>/failture_motor_ktc1' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc1': '<S408>:1' 
      // '<S408>:1:5' if isempty(motor_init)
      // '<S408>:1:11' if type == 183
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 183.0F) {
        // '<S408>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_l = DataTypeConversion1[0];

        // '<S408>:1:13' motor_ktc_N = data(2);
        // 
        // '<S408>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_iq.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_iq.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_iq.data[1] =
          DataTypeConversion1[3];
      }

      // '<S408>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_l != 0.0) {
        // '<S408>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_ao != 0.0)) {
          // '<S408>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_ao = 1.0;

          // '<S408>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S408>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fv();

          // '<S408>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S408>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fv();

          // '<S408>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S408>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fv();
        }
      } else {
        // '<S408>:1:27' else
        // '<S408>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_ao = 0.0;

        // '<S408>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc1'

      // MATLAB Function: '<S383>/failture_motor_ktc2' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S408>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc2': '<S409>:1' 
      // '<S409>:1:5' if isempty(motor_init)
      // '<S409>:1:11' if type == 188
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 188.0F) {
        // '<S409>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_k = DataTypeConversion1[0];

        // '<S409>:1:13' motor_ktc__N = data(2);
        // 
        // '<S409>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_mf.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_mf.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_mf.data[1] =
          DataTypeConversion1[3];
      }

      // '<S409>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_k != 0.0) {
        // '<S409>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_aq != 0.0)) {
          // '<S409>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_aq = 1.0;

          // '<S409>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S409>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_m();

          // '<S409>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S409>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_m();

          // '<S409>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S409>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model_d_rand_m();
        }
      } else {
        // '<S409>:1:27' else
        // '<S409>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_aq = 0.0;

        // '<S409>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc2'

      // MATLAB Function: '<S383>/failture_motor_ktc3' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S409>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc3': '<S410>:1' 
      // '<S410>:1:5' if isempty(motor_init)
      // '<S410>:1:11' if type == 193
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 193.0F) {
        // '<S410>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_i = DataTypeConversion1[0];

        // '<S410>:1:13' motor_ktc__N = data(2);
        // 
        // '<S410>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_p.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_p.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_p.data[1] =
          DataTypeConversion1[3];
      }

      // '<S410>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_i != 0.0) {
        // '<S410>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_c != 0.0)) {
          // '<S410>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_c = 1.0;

          // '<S410>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S410>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ir();

          // '<S410>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S410>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ir();

          // '<S410>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S410>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ir();
        }
      } else {
        // '<S410>:1:27' else
        // '<S410>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_c = 0.0;

        // '<S410>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc3'

      // MATLAB Function: '<S383>/failture_motor_ktc4' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S410>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc4': '<S411>:1' 
      // '<S411>:1:5' if isempty(motor_init)
      // '<S411>:1:11' if type == 198
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 198.0F) {
        // '<S411>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_c = DataTypeConversion1[0];

        // '<S411>:1:13' motor_ktc__N = data(2);
        // 
        // '<S411>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_a.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_a.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_a.data[1] =
          DataTypeConversion1[3];
      }

      // '<S411>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_c != 0.0) {
        // '<S411>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_a != 0.0)) {
          // '<S411>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_a = 1.0;

          // '<S411>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S411>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_gk();

          // '<S411>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S411>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_gk();

          // '<S411>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S411>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_gk();
        }
      } else {
        // '<S411>:1:27' else
        // '<S411>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_a = 0.0;

        // '<S411>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc4'

      // MATLAB Function: '<S383>/failture_motor_ktc5' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S411>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc5': '<S412>:1' 
      // '<S412>:1:5' if isempty(motor_init)
      // '<S412>:1:11' if type == 203
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 203.0F) {
        // '<S412>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_f = DataTypeConversion1[0];

        // '<S412>:1:13' motor_ktc__N = data(2);
        // 
        // '<S412>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_i.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_i.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_i.data[1] =
          DataTypeConversion1[3];
      }

      // '<S412>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_f != 0.0) {
        // '<S412>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_e != 0.0)) {
          // '<S412>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_e = 1.0;

          // '<S412>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S412>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_os();

          // '<S412>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S412>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_os();

          // '<S412>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S412>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_os();
        }
      } else {
        // '<S412>:1:27' else
        // '<S412>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_e = 0.0;

        // '<S412>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc5'

      // MATLAB Function: '<S383>/failture_motor_ktc6' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S412>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc6': '<S413>:1' 
      // '<S413>:1:5' if isempty(motor_init)
      // '<S413>:1:11' if type == 208
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 208.0F) {
        // '<S413>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_j = DataTypeConversion1[0];

        // '<S413>:1:13' motor_ktc__N = data(2);
        // 
        // '<S413>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_o.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_o.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_o.data[1] =
          DataTypeConversion1[3];
      }

      // '<S413>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_j != 0.0) {
        // '<S413>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_l != 0.0)) {
          // '<S413>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_l = 1.0;

          // '<S413>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S413>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fi();

          // '<S413>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S413>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fi();

          // '<S413>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S413>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_fi();
        }
      } else {
        // '<S413>:1:27' else
        // '<S413>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_l = 0.0;

        // '<S413>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc6'

      // MATLAB Function: '<S383>/failture_motor_ktc7' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S413>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc7': '<S414>:1' 
      // '<S414>:1:5' if isempty(motor_init)
      // '<S414>:1:11' if type == 213
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 213.0F) {
        // '<S414>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en_h = DataTypeConversion1[0];

        // '<S414>:1:13' motor_ktc__N = data(2);
        // 
        // '<S414>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_m.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_m.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_m.data[1] =
          DataTypeConversion1[3];
      }

      // '<S414>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en_h != 0.0) {
        // '<S414>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init_o != 0.0)) {
          // '<S414>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init_o = 1.0;

          // '<S414>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S414>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_o0();

          // '<S414>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S414>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_o0();

          // '<S414>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S414>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_o0();
        }
      } else {
        // '<S414>:1:27' else
        // '<S414>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init_o = 0.0;

        // '<S414>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc7'

      // MATLAB Function: '<S383>/failture_motor_ktc8' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S414>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_motor/failture_motor_ktc8': '<S415>:1' 
      // '<S415>:1:5' if isempty(motor_init)
      // '<S415>:1:11' if type == 218
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 218.0F) {
        // '<S415>:1:12' motor_ktc_en = data(1);
        Lifting_wing_HIL_model_dll_DW.motor_ktc_en = DataTypeConversion1[0];

        // '<S415>:1:13' motor_ktc__N = data(2);
        // 
        // '<S415>:1:14' motor_ktc_limit = data(3: 4 );
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit.data[0] =
          DataTypeConversion1[2];
        Lifting_wing_HIL_model_dll_DW.motor_ktc_limit.data[1] =
          DataTypeConversion1[3];
      }

      // '<S415>:1:20' if motor_ktc_en
      if (Lifting_wing_HIL_model_dll_DW.motor_ktc_en != 0.0) {
        // '<S415>:1:21' if ~motor_init
        if (!(Lifting_wing_HIL_model_dll_DW.motor_init != 0.0)) {
          // '<S415>:1:22' motor_init = 1;
          Lifting_wing_HIL_model_dll_DW.motor_init = 1.0;

          // '<S415>:1:23' motor_ktc(1) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S415>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ly();

          // '<S415>:1:24' motor_ktc(2) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S415>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ly();

          // '<S415>:1:25' motor_ktc(3) = data_gen1(motor_ktc_limit(1), motor_ktc_limit(2)); 
          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S415>:1:44' y = data_min + (data_max - data_min)*rand;
          Lifting_wing_HIL_model__rand_ly();
        }
      } else {
        // '<S415>:1:27' else
        // '<S415>:1:28' motor_init = 0;
        Lifting_wing_HIL_model_dll_DW.motor_init = 0.0;

        // '<S415>:1:29' motor_ktc = ones(3, 1);
      }

      // End of MATLAB Function: '<S383>/failture_motor_ktc8'

      // MATLAB Function: '<S384>/failture_propeller1' incorporates:
      //   Inport: '<Root>/inSILInts'

      // '<S415>:1:32' ymotor_ktc = motor_ktc;
      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller1': '<S416>:1' 
      // '<S416>:1:4' if isempty(propeller_init)
      // '<S416>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fc) {
        // '<S416>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fc = true;
      }

      // '<S416>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S416>:1:19' if type == 221
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 221.0F) {
        // '<S416>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_o = DataTypeConversion1[0];

        // '<S416>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S416>:1:22' assert (propeller_kct_N <= 20);
        // '<S416>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S416>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S416>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n = tmp_data_0;
        } else {
          // '<S416>:1:26' else
          // '<S416>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n = tmp_data_0;

          // '<S416>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S416>:1:31' if type == 222
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 222.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S416>:1:32' if propeller_kct_N >= 9
        // '<S416>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_n = tmp_data_0;

        // '<S416>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S416>:1:38' propeller_kct_default = 1;
      // '<S416>:1:39' propeller_kct = 1;
      // '<S416>:1:40' x = propeller_kct_default;
      // 
      // '<S416>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_o != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_a != 0.0))) {
        // '<S416>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_a = 1.0;

        // '<S416>:1:44' timestart = timestamp;
        // '<S416>:1:45' N = size(propeller_kct_T, 2);
        // '<S416>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S416>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S416>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S416>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_p4();

          // '<S416>:1:50' v(i) = 0;
        }

        // '<S416>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_a;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_a = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S416>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_o != 0.0)) {
        // '<S416>:1:59' else
        // '<S416>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_a = 0.0;

        // '<S416>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S416>:1:57' runtime = timestamp - timestart;
        // '<S416>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S416>:1:78' N = length(x_init);
        // '<S416>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller1'

      // MATLAB Function: '<S384>/failture_propeller2' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller2': '<S417>:1' 
      // '<S417>:1:4' if isempty(propeller_init)
      // '<S417>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_g) {
        // '<S417>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_g = true;
      }

      // '<S417>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S417>:1:19' if type == 226
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 226.0F) {
        // '<S417>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_h = DataTypeConversion1[0];

        // '<S417>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S417>:1:22' assert (propeller_kct_N <= 20);
        // '<S417>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S417>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S417>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c = tmp_data_0;
        } else {
          // '<S417>:1:26' else
          // '<S417>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c = tmp_data_0;

          // '<S417>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S417>:1:31' if type == 227
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 227.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S417>:1:32' if propeller_kct_N >= 9
        // '<S417>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_c = tmp_data_0;

        // '<S417>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S417>:1:38' propeller_kct_default = 1;
      // '<S417>:1:39' propeller_kct = 1;
      // '<S417>:1:40' x = propeller_kct_default;
      // 
      // '<S417>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_h != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_dn != 0.0))) {
        // '<S417>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_dn = 1.0;

        // '<S417>:1:44' timestart = timestamp;
        // '<S417>:1:45' N = size(propeller_kct_T, 2);
        // '<S417>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S417>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S417>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S417>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_jc();

          // '<S417>:1:50' v(i) = 0;
        }

        // '<S417>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_b;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_b = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S417>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_h != 0.0)) {
        // '<S417>:1:59' else
        // '<S417>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_dn = 0.0;

        // '<S417>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S417>:1:57' runtime = timestamp - timestart;
        // '<S417>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S417>:1:78' N = length(x_init);
        // '<S417>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller2'

      // MATLAB Function: '<S384>/failture_propeller3' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller3': '<S418>:1' 
      // '<S418>:1:4' if isempty(propeller_init)
      // '<S418>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_l) {
        // '<S418>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_l = true;
      }

      // '<S418>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S418>:1:19' if type == 231
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 231.0F) {
        // '<S418>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_i = DataTypeConversion1[0];

        // '<S418>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S418>:1:22' assert (propeller_kct_N <= 20);
        // '<S418>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S418>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S418>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm = tmp_data_0;
        } else {
          // '<S418>:1:26' else
          // '<S418>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm = tmp_data_0;

          // '<S418>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S418>:1:31' if type == 232
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 232.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S418>:1:32' if propeller_kct_N >= 9
        // '<S418>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_jm = tmp_data_0;

        // '<S418>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S418>:1:38' propeller_kct_default = 1;
      // '<S418>:1:39' propeller_kct = 1;
      // '<S418>:1:40' x = propeller_kct_default;
      // 
      // '<S418>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_i != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_d != 0.0))) {
        // '<S418>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_d = 1.0;

        // '<S418>:1:44' timestart = timestamp;
        // '<S418>:1:45' N = size(propeller_kct_T, 2);
        // '<S418>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S418>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S418>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S418>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_fl();

          // '<S418>:1:50' v(i) = 0;
        }

        // '<S418>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_ee;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_ee =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S418>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_i != 0.0)) {
        // '<S418>:1:59' else
        // '<S418>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_d = 0.0;

        // '<S418>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S418>:1:57' runtime = timestamp - timestart;
        // '<S418>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S418>:1:78' N = length(x_init);
        // '<S418>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller3'

      // MATLAB Function: '<S384>/failture_propeller4' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller4': '<S419>:1' 
      // '<S419>:1:4' if isempty(propeller_init)
      // '<S419>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fy) {
        // '<S419>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_fy = true;
      }

      // '<S419>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S419>:1:19' if type == 236
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 236.0F) {
        // '<S419>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_d = DataTypeConversion1[0];

        // '<S419>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S419>:1:22' assert (propeller_kct_N <= 20);
        // '<S419>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S419>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S419>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j = tmp_data_0;
        } else {
          // '<S419>:1:26' else
          // '<S419>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j = tmp_data_0;

          // '<S419>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S419>:1:31' if type == 237
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 237.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S419>:1:32' if propeller_kct_N >= 9
        // '<S419>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_j = tmp_data_0;

        // '<S419>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S419>:1:38' propeller_kct_default = 1;
      // '<S419>:1:39' propeller_kct = 1;
      // '<S419>:1:40' x = propeller_kct_default;
      // 
      // '<S419>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_d != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_b != 0.0))) {
        // '<S419>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_b = 1.0;

        // '<S419>:1:44' timestart = timestamp;
        // '<S419>:1:45' N = size(propeller_kct_T, 2);
        // '<S419>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S419>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S419>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S419>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_oi();

          // '<S419>:1:50' v(i) = 0;
        }

        // '<S419>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_cr;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_cr =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S419>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_d != 0.0)) {
        // '<S419>:1:59' else
        // '<S419>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_b = 0.0;

        // '<S419>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S419>:1:57' runtime = timestamp - timestart;
        // '<S419>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S419>:1:78' N = length(x_init);
        // '<S419>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller4'

      // MATLAB Function: '<S384>/failture_propeller5' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller5': '<S420>:1' 
      // '<S420>:1:4' if isempty(propeller_init)
      // '<S420>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_h) {
        // '<S420>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_h = true;
      }

      // '<S420>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S420>:1:19' if type == 241
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 241.0F) {
        // '<S420>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_a = DataTypeConversion1[0];

        // '<S420>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S420>:1:22' assert (propeller_kct_N <= 20);
        // '<S420>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S420>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S420>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m = tmp_data_0;
        } else {
          // '<S420>:1:26' else
          // '<S420>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m = tmp_data_0;

          // '<S420>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S420>:1:31' if type == 242
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 242.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S420>:1:32' if propeller_kct_N >= 9
        // '<S420>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_m = tmp_data_0;

        // '<S420>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S420>:1:38' propeller_kct_default = 1;
      // '<S420>:1:39' propeller_kct = 1;
      // '<S420>:1:40' x = propeller_kct_default;
      // 
      // '<S420>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_a != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_m != 0.0))) {
        // '<S420>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_m = 1.0;

        // '<S420>:1:44' timestart = timestamp;
        // '<S420>:1:45' N = size(propeller_kct_T, 2);
        // '<S420>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S420>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S420>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S420>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_jg();

          // '<S420>:1:50' v(i) = 0;
        }

        // '<S420>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_oi;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_oi =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S420>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_a != 0.0)) {
        // '<S420>:1:59' else
        // '<S420>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_m = 0.0;

        // '<S420>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S420>:1:57' runtime = timestamp - timestart;
        // '<S420>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S420>:1:78' N = length(x_init);
        // '<S420>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller5'

      // MATLAB Function: '<S384>/failture_propeller6' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller6': '<S421>:1' 
      // '<S421>:1:4' if isempty(propeller_init)
      // '<S421>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_f) {
        // '<S421>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_f = true;
      }

      // '<S421>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S421>:1:19' if type == 246
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 246.0F) {
        // '<S421>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_k = DataTypeConversion1[0];

        // '<S421>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S421>:1:22' assert (propeller_kct_N <= 20);
        // '<S421>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S421>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S421>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a = tmp_data_0;
        } else {
          // '<S421>:1:26' else
          // '<S421>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a = tmp_data_0;

          // '<S421>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S421>:1:31' if type == 247
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 247.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S421>:1:32' if propeller_kct_N >= 9
        // '<S421>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_a = tmp_data_0;

        // '<S421>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S421>:1:38' propeller_kct_default = 1;
      // '<S421>:1:39' propeller_kct = 1;
      // '<S421>:1:40' x = propeller_kct_default;
      // 
      // '<S421>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_k != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_p != 0.0))) {
        // '<S421>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_p = 1.0;

        // '<S421>:1:44' timestart = timestamp;
        // '<S421>:1:45' N = size(propeller_kct_T, 2);
        // '<S421>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S421>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S421>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S421>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_c5();

          // '<S421>:1:50' v(i) = 0;
        }

        // '<S421>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp =
          Lifting_wing_HIL_model_dll_DW.x_init_i1;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_i1 =
          rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S421>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_k != 0.0)) {
        // '<S421>:1:59' else
        // '<S421>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_p = 0.0;

        // '<S421>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S421>:1:57' runtime = timestamp - timestart;
        // '<S421>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S421>:1:78' N = length(x_init);
        // '<S421>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller6'

      // MATLAB Function: '<S384>/failture_propeller7' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller7': '<S422>:1' 
      // '<S422>:1:4' if isempty(propeller_init)
      // '<S422>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty_o) {
        // '<S422>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty_o = true;
      }

      // '<S422>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S422>:1:19' if type == 251
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 251.0F) {
        // '<S422>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en_p = DataTypeConversion1[0];

        // '<S422>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S422>:1:22' assert (propeller_kct_N <= 20);
        // '<S422>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S422>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S422>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k = tmp_data_0;
        } else {
          // '<S422>:1:26' else
          // '<S422>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k = tmp_data_0;

          // '<S422>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S422>:1:31' if type == 252
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 252.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S422>:1:32' if propeller_kct_N >= 9
        // '<S422>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt_k = tmp_data_0;

        // '<S422>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S422>:1:38' propeller_kct_default = 1;
      // '<S422>:1:39' propeller_kct = 1;
      // '<S422>:1:40' x = propeller_kct_default;
      // 
      // '<S422>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en_p != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init_i != 0.0))) {
        // '<S422>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init_i = 1.0;

        // '<S422>:1:44' timestart = timestamp;
        // '<S422>:1:45' N = size(propeller_kct_T, 2);
        // '<S422>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S422>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S422>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S422>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_nm();

          // '<S422>:1:50' v(i) = 0;
        }

        // '<S422>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_o;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_o = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S422>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en_p != 0.0)) {
        // '<S422>:1:59' else
        // '<S422>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init_i = 0.0;

        // '<S422>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S422>:1:57' runtime = timestamp - timestart;
        // '<S422>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S422>:1:78' N = length(x_init);
        // '<S422>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller7'

      // MATLAB Function: '<S384>/failture_propeller8' incorporates:
      //   Inport: '<Root>/inSILInts'

      //
      // MATLAB Function 'udp_receiver/failture_propeller/failture_propeller8': '<S423>:1' 
      // '<S423>:1:4' if isempty(propeller_init)
      // '<S423>:1:14' if isempty(timestart)
      if (!Lifting_wing_HIL_model_dll_DW.timestart_not_empty) {
        // '<S423>:1:15' timestart = timestamp;
        Lifting_wing_HIL_model_dll_DW.timestart_not_empty = true;
      }

      // '<S423>:1:18' propeller_kct_N = 1;
      rtb_q3dot = 1.0;

      // '<S423>:1:19' if type == 256
      if (Lifting_wing_HIL_model_dll_U.inSILInts[0] == 256.0F) {
        // '<S423>:1:20' propeller_kct_en = data(1);
        Lifting_wing_HIL_model_dll_DW.propeller_kct_en = DataTypeConversion1[0];

        // '<S423>:1:21' propeller_kct_N = data(2);
        rtb_q3dot = DataTypeConversion1[1];

        // 
        // '<S423>:1:22' assert (propeller_kct_N <= 20);
        // '<S423>:1:23' propeller_kct_T = data(3: 2+propeller_kct_N);
        // '<S423>:1:24' if propeller_kct_N >= 9
        if (DataTypeConversion1[1] >= 9.0) {
          // '<S423>:1:25' propeller_kct_dt(1:18 - propeller_kct_N) = data(3+propeller_kct_N:20); 
          if (DataTypeConversion1[1] + 3.0 > 20.0) {
            rtb_lon = 0;
            rtb_lat = -1;
          } else {
            rtb_lon = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lat = 19;
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt;
          Comega_tmp = rtb_lat - rtb_lon;
          for (i = 0; i <= Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lon + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt = tmp_data_0;
        } else {
          // '<S423>:1:26' else
          // '<S423>:1:27' propeller_kct_dt(1:propeller_kct_N) = data(3+propeller_kct_N:2+2*propeller_kct_N); 
          Merge = 2.0 * DataTypeConversion1[1] + 2.0;
          if (DataTypeConversion1[1] + 3.0 > Merge) {
            rtb_lat = 0;
            rtb_lon = 0;
          } else {
            rtb_lat = static_cast<int32_T>(DataTypeConversion1[1] + 3.0) - 1;
            rtb_lon = static_cast<int32_T>(Merge);
          }

          tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt;
          Comega_tmp = rtb_lon - rtb_lat;
          for (i = 0; i < Comega_tmp; i++) {
            tmp_data_0 = DataTypeConversion1[rtb_lat + i];
          }

          Lifting_wing_HIL_model_dll_DW.propeller_kct_dt = tmp_data_0;

          // '<S423>:1:28' propeller_kct_am = data(3+2*propeller_kct_N:4+2*propeller_kct_N); 
          rtb_Divide_idx_0 = 2.0 * DataTypeConversion1[1] + 3.0;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am.size[0] = 2;
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[0] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
          Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[1] =
            DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
        }
      }

      // '<S423>:1:31' if type == 257
      if ((Lifting_wing_HIL_model_dll_U.inSILInts[0] == 257.0F) && (rtb_q3dot >=
           9.0)) {
        // '<S423>:1:32' if propeller_kct_N >= 9
        // '<S423>:1:33' propeller_kct_dt(19 - propeller_kct_N : propeller_kct_N) = data(1:2*propeller_kct_N - 18); 
        Merge = 2.0 * rtb_q3dot - 18.0;
        if (!(19.0 - rtb_q3dot > rtb_q3dot)) {
          // Check node always fails. would cause program termination and was eliminated 
        }

        tmp_data_0 = Lifting_wing_HIL_model_dll_DW.propeller_kct_dt;
        if (Merge < 1.0) {
          Comega_tmp = -1;
        } else {
          Comega_tmp = static_cast<int32_T>(Merge) - 1;
        }

        if (Comega_tmp >= 0) {
          std::memcpy(&tmp_data_0, &DataTypeConversion1[0], static_cast<uint32_T>
                      (Comega_tmp + 1) * sizeof(real_T));
        }

        Lifting_wing_HIL_model_dll_DW.propeller_kct_dt = tmp_data_0;

        // '<S423>:1:34' propeller_kct_am = data(2*propeller_kct_N -17: 2*propeller_kct_N -16); 
        rtb_Divide_idx_0 = 2.0 * rtb_q3dot - 17.0;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am.size[0] = 2;
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[0] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0) - 1];
        Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[1] =
          DataTypeConversion1[static_cast<int32_T>(rtb_Divide_idx_0 + 1.0) - 1];
      }

      // '<S423>:1:38' propeller_kct_default = 1;
      // '<S423>:1:39' propeller_kct = 1;
      // '<S423>:1:40' x = propeller_kct_default;
      // 
      // '<S423>:1:42' if propeller_kct_en && ~propeller_init
      if ((Lifting_wing_HIL_model_dll_DW.propeller_kct_en != 0.0) &&
          (!(Lifting_wing_HIL_model_dll_DW.propeller_init != 0.0))) {
        // '<S423>:1:43' propeller_init = 1;
        Lifting_wing_HIL_model_dll_DW.propeller_init = 1.0;

        // '<S423>:1:44' timestart = timestamp;
        // '<S423>:1:45' N = size(propeller_kct_T, 2);
        // '<S423>:1:46' propeller_kct_am_rand = ones(N, 1);
        Merge = 1.0;

        // '<S423>:1:48' for i = 1 : propeller_kct_N
        i = static_cast<int32_T>(rtb_q3dot);
        for (rtb_lat = 0; rtb_lat < i; rtb_lat++) {
          // '<S423>:1:49' propeller_kct_am_rand(i) = data_gen1(propeller_kct_am(1), propeller_kct_am(2)); 
          Merge = Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[0];
          rtb_Switch = Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[1];

          // (data_min,data_max)
          // data_min: 
          // data_max: 
          // '<S423>:1:103' y = data_min + (data_max - data_min)*rand;
          Merge += (rtb_Switch - Merge) * Lifting_wing_HIL_model__rand_nb();

          // '<S423>:1:50' v(i) = 0;
        }

        // '<S423>:1:52' x_init(1:propeller_kct_N)  = propeller_kct_am_rand;
        if (rtb_q3dot < 1.0) {
          i = -1;
        } else {
          i = 0;
        }

        rtb_DataTypeConversion1_tmp_tmp = Lifting_wing_HIL_model_dll_DW.x_init_c;
        if (i >= 0) {
          rtb_DataTypeConversion1_tmp_tmp = Merge;
        }

        Lifting_wing_HIL_model_dll_DW.x_init_c = rtb_DataTypeConversion1_tmp_tmp;
      }

      // '<S423>:1:55' if propeller_kct_en
      if (!(Lifting_wing_HIL_model_dll_DW.propeller_kct_en != 0.0)) {
        // '<S423>:1:59' else
        // '<S423>:1:60' propeller_init = 0;
        Lifting_wing_HIL_model_dll_DW.propeller_init = 0.0;

        // '<S423>:1:61' propeller_kct(1) = propeller_kct_default;
      } else {
        // 
        // '<S423>:1:57' runtime = timestamp - timestart;
        // '<S423>:1:58' propeller_kct(1)= param_gen(runtime, x, x_init(1:propeller_kct_N) , propeller_kct_T(1:propeller_kct_N), v(1:propeller_kct_N) , propeller_kct_dt(1:propeller_kct_N) ); 
        // timestamp:
        // x: 
        // x_init: 
        // Ti: 
        // v
        // dt: 
        // %%%%%%%%%%%%%%%%
        // '<S423>:1:78' N = length(x_init);
        // '<S423>:1:80' n = find(runtime <=Ti,1,'first');
      }

      // End of MATLAB Function: '<S384>/failture_propeller8'
    }
  }

  if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep()) {
    real_T NextOutput_k_tmp;
    int32_T Delay_DSTATE_tmp;
    int32_T iU;
    boolean_T tmp;
    boolean_T tmp_0;
    boolean_T tmp_1;
    tmp = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
           (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0);
    if (tmp) {
      // Update for DiscreteIntegrator: '<S277>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainval *
        Lifting_wing_HIL_model_dll_B.Divide;

      // Update for DiscreteIntegrator: '<S278>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_e +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainva_i *
        Lifting_wing_HIL_model_dll_B.Divide_l;

      // Update for DiscreteIntegrator: '<S279>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_o +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainva_g *
        Lifting_wing_HIL_model_dll_B.Divide_c;

      // Update for DiscreteIntegrator: '<S280>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_c +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainva_o *
        Lifting_wing_HIL_model_dll_B.Divide_n;
    }

    // Update for Integrator: '<S297>/q0 q1 q2 q3'
    Lifting_wing_HIL_model_dll_DW.q0q1q2q3_DWORK1 = false;

    // Update for Atomic SubSystem: '<S172>/Wind Models'
    if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
        (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[1] == 0) {
      // Update for RandomNumber: '<S233>/White Noise'
      Lifting_wing_HIL_model_dll_DW.NextOutput_ia[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_kb[0])
        * Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
        Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
      Lifting_wing_HIL_model_dll_DW.NextOutput_ia[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_kb[1])
        * Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
        Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
      Lifting_wing_HIL_model_dll_DW.NextOutput_ia[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_kb[2])
        * Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
        Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
      Lifting_wing_HIL_model_dll_DW.NextOutput_ia[3] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_kb[3])
        * Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
        Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
    }

    // End of Update for SubSystem: '<S172>/Wind Models'
    if (tmp) {
      // Update for DiscreteIntegrator: '<S282>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_f +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainva_j *
        Lifting_wing_HIL_model_dll_B.Divide_b;

      // Update for UnitDelay: '<S284>/Unit Delay'
      Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE = rtb_DigitalClock;

      // Update for DiscreteIntegrator: '<S283>/Discrete-Time Integrator'
      Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_j +=
        Lifting_wing_HIL_model_dll_P.DiscreteTimeIntegrator_gainva_p *
        Lifting_wing_HIL_model_dll_B.Divide_h;

      // Update for UnitDelay: '<S285>/Unit Delay'
      Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE_h = rtb_DigitalClock_e;
    }

    tmp_0 = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
             (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[2] == 0);
    if (tmp_0) {
      // Update for RandomNumber: '<S89>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput[0] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[0] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[0]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;
      Lifting_wing_HIL_model_dll_DW.NextOutput[1] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[1] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[1]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;
      Lifting_wing_HIL_model_dll_DW.NextOutput[2] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[2] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[2]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;

      // Update for RandomNumber: '<S90>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_h = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNm * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_p) +
        Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean;
    }

    if (tmp) {
      // Update for Delay: '<S89>/Delay' incorporates:
      //   Constant: '<S89>/Enable0'

      if (Lifting_wing_HIL_model_dll_P.Enable0_Value > 0.0) {
        for (iU = 0; iU < 99; iU++) {
          Delay_DSTATE_tmp = (iU + 1) * 3;
          Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[iU * 3] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[Delay_DSTATE_tmp];
          Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[iU * 3 + 1] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[Delay_DSTATE_tmp + 1];
          Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[iU * 3 + 2] =
            Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[Delay_DSTATE_tmp + 2];
        }

        Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[297] =
          Lifting_wing_HIL_model_dll_B.Sum[0];
        Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[298] =
          Lifting_wing_HIL_model_dll_B.Sum[1];
        Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[299] =
          Lifting_wing_HIL_model_dll_B.Sum[2];
      }

      // End of Update for Delay: '<S89>/Delay'

      // Update for Delay: '<S92>/Delay1' incorporates:
      //   Constant: '<S92>/Enable1'

      if (Lifting_wing_HIL_model_dll_P.Enable1_Value > 0.0) {
        for (iU = 0; iU < 99; iU++) {
          Delay_DSTATE_tmp = (iU + 1) * 3;
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[iU * 3] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[Delay_DSTATE_tmp];
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[iU * 3 + 1] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[Delay_DSTATE_tmp + 1];
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[iU * 3 + 2] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[Delay_DSTATE_tmp + 2];
        }

        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[297] =
          Lifting_wing_HIL_model_dll_B.Saturation_n[0];
        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[298] =
          Lifting_wing_HIL_model_dll_B.Saturation_n[1];
        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[299] =
          Lifting_wing_HIL_model_dll_B.Saturation_n[2];
      }

      // End of Update for Delay: '<S92>/Delay1'

      // Update for RandomNumber: '<S93>/Random Number2'
      Lifting_wing_HIL_model_dll_DW.NextOutput_j[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[0]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[0] +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[0];
      Lifting_wing_HIL_model_dll_DW.NextOutput_j[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[1]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[1] +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[1];
      Lifting_wing_HIL_model_dll_DW.NextOutput_j[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[2]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[2] +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[2];

      // Update for Delay: '<S93>/Delay1' incorporates:
      //   Constant: '<S93>/Enable1'

      if (Lifting_wing_HIL_model_dll_P.Enable1_Value_a > 0.0) {
        for (iU = 0; iU < 99; iU++) {
          Delay_DSTATE_tmp = (iU + 1) * 3;
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[iU * 3] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[Delay_DSTATE_tmp];
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[iU * 3 + 1] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[Delay_DSTATE_tmp + 1];
          Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[iU * 3 + 2] =
            Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[Delay_DSTATE_tmp + 2];
        }

        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[297] =
          Lifting_wing_HIL_model_dll_B.Product1[0];
        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[298] =
          Lifting_wing_HIL_model_dll_B.Product1[1];
        Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[299] =
          Lifting_wing_HIL_model_dll_B.Product1[2];
      }

      // End of Update for Delay: '<S93>/Delay1'
    }

    tmp_1 = ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep() &&
             (&Lifting_wing_HIL_model_dll_M)->Timing.TaskCounters.TID[3] == 0);
    if (tmp_1) {
      // Update for UniformRandomNumber: '<S91>/Uniform Random Number1'
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[0] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[0] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[0]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[0])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[0];
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[1] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[1] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[1]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[1])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[1];
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[2] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[2] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[2]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[2])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[2];
    }

    if (tmp_0) {
      // Update for RandomNumber: '<S89>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_g[0] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[0] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[0])
        + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;
      Lifting_wing_HIL_model_dll_DW.NextOutput_g[1] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[1] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[1])
        + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;
      Lifting_wing_HIL_model_dll_DW.NextOutput_g[2] = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[2] * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[2])
        + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;

      // Update for RandomNumber: '<S90>/Random Number2'
      Lifting_wing_HIL_model_dll_DW.NextOutput_l = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNbm * 1.0E-5) *
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_g) +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_a;
    }

    if (tmp) {
      // Update for RandomNumber: '<S89>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_b[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[0]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[0] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[0];
      Lifting_wing_HIL_model_dll_DW.NextOutput_b[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[1]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[1] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[1];
      Lifting_wing_HIL_model_dll_DW.NextOutput_b[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[2]) *
        Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[2] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[2];
    }

    if (tmp_1) {
      // Update for UniformRandomNumber: '<S91>/Uniform Random Number4'
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[0] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[0] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[0]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[0])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[0];
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[1] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[1] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[1]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[1])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[1];
      Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[2] =
        (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[2] -
         Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[2]) *
        rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[2])
        + Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[2];
    }

    if (tmp_0) {
      // Update for RandomNumber: '<S92>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_i[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[0]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[0]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

      // Update for RandomNumber: '<S92>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_gk[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_p5[0])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[0]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

      // Update for RandomNumber: '<S92>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_i[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[1]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[1]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

      // Update for RandomNumber: '<S92>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_gk[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_p5[1])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[1]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

      // Update for RandomNumber: '<S92>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_i[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[2]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[2]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

      // Update for RandomNumber: '<S92>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_gk[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_p5[2])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[2]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

      // Update for RandomNumber: '<S93>/Random Number' incorporates:
      //   RandomNumber: '<S93>/Random Number1'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[0]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_k[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[0]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

      // Update for RandomNumber: '<S93>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_ko[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_g1[0])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

      // Update for RandomNumber: '<S93>/Random Number' incorporates:
      //   RandomNumber: '<S93>/Random Number1'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[1]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_k[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[1]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

      // Update for RandomNumber: '<S93>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_ko[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_g1[1])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

      // Update for RandomNumber: '<S93>/Random Number' incorporates:
      //   RandomNumber: '<S93>/Random Number1'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[2]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_k[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[2]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

      // Update for RandomNumber: '<S93>/Random Number1'
      Lifting_wing_HIL_model_dll_DW.NextOutput_ko[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_g1[2])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

      // Update for RandomNumber: '<S272>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_c[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[0]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[0]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

      // Update for RandomNumber: '<S272>/Random Number1' incorporates:
      //   RandomNumber: '<S273>/Random Number3'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[0]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_cd[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_k[0])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

      // Update for RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_DW.NextOutput_im[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_ld[0])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[0]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

      // Update for RandomNumber: '<S273>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_o[0] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[0]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;

      // Update for RandomNumber: '<S272>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_c[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[1]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[1]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

      // Update for RandomNumber: '<S272>/Random Number1' incorporates:
      //   RandomNumber: '<S273>/Random Number3'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[1]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_cd[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_k[1])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

      // Update for RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_DW.NextOutput_im[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_ld[1])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[1]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

      // Update for RandomNumber: '<S273>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_o[1] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[1]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;

      // Update for RandomNumber: '<S272>/Random Number'
      Lifting_wing_HIL_model_dll_DW.NextOutput_c[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[2]) * std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[2]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

      // Update for RandomNumber: '<S272>/Random Number1' incorporates:
      //   RandomNumber: '<S273>/Random Number3'

      NextOutput_k_tmp = std::sqrt
        (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[2]);
      Lifting_wing_HIL_model_dll_DW.NextOutput_cd[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_k[2])
        * NextOutput_k_tmp + Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

      // Update for RandomNumber: '<S273>/Random Number2'
      Lifting_wing_HIL_model_dll_DW.NextOutput_im[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_ld[2])
        * std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[2]) +
        Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

      // Update for RandomNumber: '<S273>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_o[2] = rt_nrand_Upu32_Yd_f_pw_snf
        (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[2]) * NextOutput_k_tmp +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;
    }

    if (tmp) {
      // Update for RandomNumber: '<S92>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_le[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_c[0])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[0] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[0];
      Lifting_wing_HIL_model_dll_DW.NextOutput_le[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_c[1])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[1] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[1];
      Lifting_wing_HIL_model_dll_DW.NextOutput_le[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_c[2])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[2] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[2];

      // Update for RandomNumber: '<S93>/Random Number3'
      Lifting_wing_HIL_model_dll_DW.NextOutput_ld[0] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_go[0])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[0] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[0];
      Lifting_wing_HIL_model_dll_DW.NextOutput_ld[1] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_go[1])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[1] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[1];
      Lifting_wing_HIL_model_dll_DW.NextOutput_ld[2] =
        rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_go[2])
        * Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[2] +
        Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[2];
    }
  }                                    // end MajorTimeStep

  if ((&Lifting_wing_HIL_model_dll_M)->isMajorTimeStep()) {
    rt_ertODEUpdateContinuousStates(&(&Lifting_wing_HIL_model_dll_M)->solverInfo);

    // Update absolute time for base rate
    // The "clockTick0" counts the number of times the code of this task has
    //  been executed. The absolute time is the multiplication of "clockTick0"
    //  and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
    //  overflow during the application lifespan selected.

    ++(&Lifting_wing_HIL_model_dll_M)->Timing.clockTick0;
    (&Lifting_wing_HIL_model_dll_M)->Timing.t[0] = rtsiGetSolverStopTime
      (&(&Lifting_wing_HIL_model_dll_M)->solverInfo);

    {
      // Update absolute timer for sample time: [0.001s, 0.0s]
      // The "clockTick1" counts the number of times the code of this task has
      //  been executed. The resolution of this integer timer is 0.001, which is the step size
      //  of the task. Size of "clockTick1" ensures timer will not overflow during the
      //  application lifespan selected.

      (&Lifting_wing_HIL_model_dll_M)->Timing.clockTick1++;
    }

    rate_scheduler((&Lifting_wing_HIL_model_dll_M));
  }                                    // end MajorTimeStep
}

// Derivatives for root system: '<Root>'
void MulticopterModelClass::Lifting_wing_HIL_model_dll_derivatives()
{
  MulticopterModelClass::XDot_Lifting_wing_HIL_model_d_T *_rtXdot;
  boolean_T lsat;
  boolean_T usat;
  _rtXdot = ((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M
             )->derivs);

  // Derivatives for SecondOrderIntegrator: '<S100>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited_MO[0] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_CS[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[3];
    _rtXdot->IntegratorSecondOrderLimited_CS[3] =
      Lifting_wing_HIL_model_dll_B.Sum2[0];
  }

  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited_MO[1] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_CS[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[4];
    _rtXdot->IntegratorSecondOrderLimited_CS[4] =
      Lifting_wing_HIL_model_dll_B.Sum2[1];
  }

  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited_MO[2] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_CS[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[5];
    _rtXdot->IntegratorSecondOrderLimited_CS[5] =
      Lifting_wing_HIL_model_dll_B.Sum2[2];
  }

  // End of Derivatives for SecondOrderIntegrator: '<S100>/Integrator, Second-Order Limited' 

  // Derivatives for Integrator: '<S297>/q0 q1 q2 q3'
  _rtXdot->q0q1q2q3_CSTATE[0] =
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[0];
  _rtXdot->q0q1q2q3_CSTATE[1] =
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[1];
  _rtXdot->q0q1q2q3_CSTATE[2] =
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[2];
  _rtXdot->q0q1q2q3_CSTATE[3] =
    Lifting_wing_HIL_model_dll_B.TmpSignalConversionAtq0q1q2q3_c[3];

  // Derivatives for Integrator: '<S295>/ub,vb,wb' incorporates:
  //   Sum: '<S295>/Sum'

  _rtXdot->ubvbwb_CSTATE[0] = Lifting_wing_HIL_model_dll_B.Sum_p[0];

  // Derivatives for Integrator: '<S295>/xe,ye,ze'
  _rtXdot->xeyeze_CSTATE[0] = Lifting_wing_HIL_model_dll_B.Product[0];

  // Derivatives for Integrator: '<S295>/ub,vb,wb' incorporates:
  //   Sum: '<S295>/Sum'

  _rtXdot->ubvbwb_CSTATE[1] = Lifting_wing_HIL_model_dll_B.Sum_p[1];

  // Derivatives for Integrator: '<S295>/xe,ye,ze'
  _rtXdot->xeyeze_CSTATE[1] = Lifting_wing_HIL_model_dll_B.Product[1];

  // Derivatives for Integrator: '<S295>/ub,vb,wb' incorporates:
  //   Sum: '<S295>/Sum'

  _rtXdot->ubvbwb_CSTATE[2] = Lifting_wing_HIL_model_dll_B.Sum_p[2];

  // Derivatives for Integrator: '<S295>/xe,ye,ze'
  _rtXdot->xeyeze_CSTATE[2] = Lifting_wing_HIL_model_dll_B.Product[2];

  // Derivatives for Atomic SubSystem: '<S172>/Wind Models'
  // Derivatives for Enabled SubSystem: '<S215>/Distance into gust (x)'
  if (Lifting_wing_HIL_model_dll_DW.Distanceintogustx_MODE) {
    // Derivatives for Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)' incorporates:
    //   Constant: '<S180>/Constant'

    lsat = (Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n <=
            Lifting_wing_HIL_model_dll_P.DistanceintoGustxLimitedtogus_g);

    // Derivatives for Enabled SubSystem: '<S215>/Distance into gust (x)'
    usat = (Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n >=
            Lifting_wing_HIL_model_dll_P.Distanceintogustx_d_m);

    // End of Derivatives for SubSystem: '<S215>/Distance into gust (x)'
    if (((!lsat) && (!usat)) || (lsat &&
         (Lifting_wing_HIL_model_dll_P.Constant_Value_d > 0.0)) || (usat &&
         (Lifting_wing_HIL_model_dll_P.Constant_Value_d < 0.0))) {
      _rtXdot->DistanceintoGustxLimitedtogus_n =
        Lifting_wing_HIL_model_dll_P.Constant_Value_d;
    } else {
      // in saturation
      _rtXdot->DistanceintoGustxLimitedtogus_n = 0.0;
    }

    // End of Derivatives for Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)' 
  } else {
    ((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)->derivs)
      ->DistanceintoGustxLimitedtogus_n = 0.0;
  }

  // End of Derivatives for SubSystem: '<S215>/Distance into gust (x)'

  // Derivatives for Enabled SubSystem: '<S215>/Distance into gust (y)'
  // Outputs for Enabled SubSystem: '<S215>/Distance into gust (y)'
  // Constant: '<S180>/Constant'
  Lifting_Distanceintogusty_Deriv(Lifting_wing_HIL_model_dll_P.Constant_Value_d,
    Lifting_wing_HIL_model_dll_P.Distanceintogusty_d_m,
    &Lifting_wing_HIL_model_dll_DW.Distanceintogusty,
    &Lifting_wing_HIL_model_dll_P.Distanceintogusty,
    &Lifting_wing_HIL_model_dll_X.Distanceintogusty, &_rtXdot->Distanceintogusty);

  // End of Outputs for SubSystem: '<S215>/Distance into gust (y)'
  // End of Derivatives for SubSystem: '<S215>/Distance into gust (y)'

  // Derivatives for Enabled SubSystem: '<S215>/Distance into gust (z)'
  // Outputs for Enabled SubSystem: '<S215>/Distance into gust (z)'
  Lifting_Distanceintogusty_Deriv(Lifting_wing_HIL_model_dll_P.Constant_Value_d,
    Lifting_wing_HIL_model_dll_P.Distanceintogustz_d_m,
    &Lifting_wing_HIL_model_dll_DW.Distanceintogustz,
    &Lifting_wing_HIL_model_dll_P.Distanceintogustz,
    &Lifting_wing_HIL_model_dll_X.Distanceintogustz, &_rtXdot->Distanceintogustz);

  // End of Outputs for SubSystem: '<S215>/Distance into gust (z)'
  // End of Derivatives for SubSystem: '<S215>/Distance into gust (z)'

  // Derivatives for Enabled SubSystem: '<S223>/Hpgw'
  if (Lifting_wing_HIL_model_dll_DW.Hpgw_MODE) {
    // Derivatives for Integrator: '<S234>/pgw_p'
    _rtXdot->pgw_p_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_h[0];
    _rtXdot->pgw_p_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_h[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->pgw_p_CSTATE[0]);
      for (i1=0; i1 < 2; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S223>/Hpgw'

  // Derivatives for Enabled SubSystem: '<S224>/Hwgw(s)'
  if (Lifting_wing_HIL_model_dll_DW.Hwgws_MODE) {
    // Derivatives for Integrator: '<S239>/wg_p1'
    _rtXdot->wg_p1_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w[0];

    // Derivatives for Integrator: '<S239>/wg_p2'
    _rtXdot->wg_p2_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_e[0];

    // Derivatives for Integrator: '<S239>/wg_p1'
    _rtXdot->wg_p1_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w[1];

    // Derivatives for Integrator: '<S239>/wg_p2'
    _rtXdot->wg_p2_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_e[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->wg_p1_CSTATE[0]);
      for (i1=0; i1 < 4; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S224>/Hwgw(s)'

  // Derivatives for Enabled SubSystem: '<S223>/Hqgw'
  if (Lifting_wing_HIL_model_dll_DW.Hqgw_MODE) {
    // Derivatives for Integrator: '<S235>/qgw_p'
    _rtXdot->qgw_p_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_b5[0];
    _rtXdot->qgw_p_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_b5[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->qgw_p_CSTATE[0]);
      for (i1=0; i1 < 2; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S223>/Hqgw'

  // Derivatives for Enabled SubSystem: '<S224>/Hvgw(s)'
  if (Lifting_wing_HIL_model_dll_DW.Hvgws_MODE) {
    // Derivatives for Integrator: '<S238>/vg_p1'
    _rtXdot->vg_p1_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_d[0];

    // Derivatives for Integrator: '<S238>/vgw_p2'
    _rtXdot->vgw_p2_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_b[0];

    // Derivatives for Integrator: '<S238>/vg_p1'
    _rtXdot->vg_p1_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_d[1];

    // Derivatives for Integrator: '<S238>/vgw_p2'
    _rtXdot->vgw_p2_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_b[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->vg_p1_CSTATE[0]);
      for (i1=0; i1 < 4; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S224>/Hvgw(s)'

  // Derivatives for Enabled SubSystem: '<S223>/Hrgw'
  if (Lifting_wing_HIL_model_dll_DW.Hrgw_MODE) {
    // Derivatives for Integrator: '<S236>/rgw_p'
    _rtXdot->rgw_p_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_a[0];
    _rtXdot->rgw_p_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_a[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->rgw_p_CSTATE[0]);
      for (i1=0; i1 < 2; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S223>/Hrgw'

  // Derivatives for Enabled SubSystem: '<S224>/Hugw(s)'
  if (Lifting_wing_HIL_model_dll_DW.Hugws_MODE) {
    // Derivatives for Integrator: '<S237>/ug_p'
    _rtXdot->ug_p_CSTATE[0] = Lifting_wing_HIL_model_dll_B.w_b2[0];
    _rtXdot->ug_p_CSTATE[1] = Lifting_wing_HIL_model_dll_B.w_b2[1];
  } else {
    {
      real_T *dx;
      int_T i1;
      dx = &(((XDot_Lifting_wing_HIL_model_d_T *) (&Lifting_wing_HIL_model_dll_M)
              ->derivs)->ug_p_CSTATE[0]);
      for (i1=0; i1 < 2; i1++) {
        dx[i1] = 0.0;
      }
    }
  }

  // End of Derivatives for SubSystem: '<S224>/Hugw(s)'
  // End of Derivatives for SubSystem: '<S172>/Wind Models'

  // Derivatives for TransferFcn: '<S272>/Transfer Fcn'
  _rtXdot->TransferFcn_CSTATE = 0.0;
  _rtXdot->TransferFcn_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn_CSTATE;
  _rtXdot->TransferFcn_CSTATE += Lifting_wing_HIL_model_dll_B.Add_d[0];

  // Derivatives for TransferFcn: '<S272>/Transfer Fcn1'
  _rtXdot->TransferFcn1_CSTATE = 0.0;
  _rtXdot->TransferFcn1_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn1_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE;
  _rtXdot->TransferFcn1_CSTATE += Lifting_wing_HIL_model_dll_B.Add_d[1];

  // Derivatives for TransferFcn: '<S272>/Transfer Fcn2'
  _rtXdot->TransferFcn2_CSTATE = 0.0;
  _rtXdot->TransferFcn2_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn2_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE;
  _rtXdot->TransferFcn2_CSTATE += Lifting_wing_HIL_model_dll_B.Add_d[2];

  // Derivatives for TransferFcn: '<S273>/Transfer Fcn3'
  _rtXdot->TransferFcn3_CSTATE = 0.0;
  _rtXdot->TransferFcn3_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn3_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn3_CSTATE;
  _rtXdot->TransferFcn3_CSTATE += Lifting_wing_HIL_model_dll_B.Add2[0];

  // Derivatives for TransferFcn: '<S273>/Transfer Fcn4'
  _rtXdot->TransferFcn4_CSTATE = 0.0;
  _rtXdot->TransferFcn4_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn4_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE;
  _rtXdot->TransferFcn4_CSTATE += Lifting_wing_HIL_model_dll_B.Add2[1];

  // Derivatives for TransferFcn: '<S273>/Transfer Fcn5'
  _rtXdot->TransferFcn5_CSTATE = 0.0;
  _rtXdot->TransferFcn5_CSTATE += Lifting_wing_HIL_model_dll_P.TransferFcn5_A *
    Lifting_wing_HIL_model_dll_X.TransferFcn5_CSTATE;
  _rtXdot->TransferFcn5_CSTATE += Lifting_wing_HIL_model_dll_B.Add2[2];

  // Derivatives for Integrator: '<S295>/p,q,r '
  _rtXdot->pqr_CSTATE[0] = Lifting_wing_HIL_model_dll_B.Product2[0];

  // Derivatives for Integrator: '<S89>/Integrator'
  _rtXdot->Integrator_CSTATE[0] = Lifting_wing_HIL_model_dll_B.RandomNumber1_e[0];

  // Derivatives for SecondOrderIntegrator: '<S166>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__n[0] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__f[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[3];
    _rtXdot->IntegratorSecondOrderLimited__f[3] =
      Lifting_wing_HIL_model_dll_B.Sum2_h[0];
  }

  // Derivatives for Integrator: '<S93>/Integrator1'
  _rtXdot->Integrator1_CSTATE[0] = Lifting_wing_HIL_model_dll_B.RandomNumber3_f
    [0];

  // Derivatives for Integrator: '<S295>/p,q,r '
  _rtXdot->pqr_CSTATE[1] = Lifting_wing_HIL_model_dll_B.Product2[1];

  // Derivatives for Integrator: '<S89>/Integrator'
  _rtXdot->Integrator_CSTATE[1] = Lifting_wing_HIL_model_dll_B.RandomNumber1_e[1];

  // Derivatives for SecondOrderIntegrator: '<S166>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__n[1] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__f[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[4];
    _rtXdot->IntegratorSecondOrderLimited__f[4] =
      Lifting_wing_HIL_model_dll_B.Sum2_h[1];
  }

  // Derivatives for Integrator: '<S93>/Integrator1'
  _rtXdot->Integrator1_CSTATE[1] = Lifting_wing_HIL_model_dll_B.RandomNumber3_f
    [1];

  // Derivatives for Integrator: '<S295>/p,q,r '
  _rtXdot->pqr_CSTATE[2] = Lifting_wing_HIL_model_dll_B.Product2[2];

  // Derivatives for Integrator: '<S89>/Integrator'
  _rtXdot->Integrator_CSTATE[2] = Lifting_wing_HIL_model_dll_B.RandomNumber1_e[2];

  // Derivatives for SecondOrderIntegrator: '<S166>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__n[2] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__f[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[5];
    _rtXdot->IntegratorSecondOrderLimited__f[5] =
      Lifting_wing_HIL_model_dll_B.Sum2_h[2];
  }

  // Derivatives for Integrator: '<S93>/Integrator1'
  _rtXdot->Integrator1_CSTATE[2] = Lifting_wing_HIL_model_dll_B.RandomNumber3_f
    [2];

  // Derivatives for Integrator: '<S90>/Integrator1'
  _rtXdot->Integrator1_CSTATE_m = Lifting_wing_HIL_model_dll_B.RandomNumber2_o;

  // Derivatives for TransferFcn: '<S127>/Transfer Fcn4'
  _rtXdot->TransferFcn4_CSTATE_l = 0.0;
  _rtXdot->TransferFcn4_CSTATE_l +=
    Lifting_wing_HIL_model_dll_P.TransferFcn4_A_j *
    Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE_l;
  _rtXdot->TransferFcn4_CSTATE_l += Lifting_wing_HIL_model_dll_B.BiasGain1[0];

  // Derivatives for TransferFcn: '<S127>/Transfer Fcn1'
  _rtXdot->TransferFcn1_CSTATE_o = 0.0;
  _rtXdot->TransferFcn1_CSTATE_o +=
    Lifting_wing_HIL_model_dll_P.TransferFcn1_A_k *
    Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE_o;
  _rtXdot->TransferFcn1_CSTATE_o += Lifting_wing_HIL_model_dll_B.BiasGain1[1];

  // Derivatives for TransferFcn: '<S127>/Transfer Fcn2'
  _rtXdot->TransferFcn2_CSTATE_j = 0.0;
  _rtXdot->TransferFcn2_CSTATE_j +=
    Lifting_wing_HIL_model_dll_P.TransferFcn2_A_b *
    Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE_j;
  _rtXdot->TransferFcn2_CSTATE_j += Lifting_wing_HIL_model_dll_B.BiasGain1[2];

  // Derivatives for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__h[0] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_fi[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[3];
    _rtXdot->IntegratorSecondOrderLimited_fi[3] =
      Lifting_wing_HIL_model_dll_B.Sum2_b[0];
  }

  // Derivatives for Integrator: '<S89>/Integrator1'
  _rtXdot->Integrator1_CSTATE_f[0] = Lifting_wing_HIL_model_dll_B.RandomNumber3
    [0];

  // Derivatives for Integrator: '<S92>/Integrator'
  _rtXdot->Integrator_CSTATE_l[0] = Lifting_wing_HIL_model_dll_B.Product4[0];

  // Derivatives for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__h[1] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_fi[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[4];
    _rtXdot->IntegratorSecondOrderLimited_fi[4] =
      Lifting_wing_HIL_model_dll_B.Sum2_b[1];
  }

  // Derivatives for Integrator: '<S89>/Integrator1'
  _rtXdot->Integrator1_CSTATE_f[1] = Lifting_wing_HIL_model_dll_B.RandomNumber3
    [1];

  // Derivatives for Integrator: '<S92>/Integrator'
  _rtXdot->Integrator_CSTATE_l[1] = Lifting_wing_HIL_model_dll_B.Product4[1];

  // Derivatives for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__h[2] == 0) {
    _rtXdot->IntegratorSecondOrderLimited_fi[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[5];
    _rtXdot->IntegratorSecondOrderLimited_fi[5] =
      Lifting_wing_HIL_model_dll_B.Sum2_b[2];
  }

  // Derivatives for Integrator: '<S89>/Integrator1'
  _rtXdot->Integrator1_CSTATE_f[2] = Lifting_wing_HIL_model_dll_B.RandomNumber3
    [2];

  // Derivatives for Integrator: '<S92>/Integrator'
  _rtXdot->Integrator_CSTATE_l[2] = Lifting_wing_HIL_model_dll_B.Product4[2];

  // Derivatives for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__c[0] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__j[0] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[3];
    _rtXdot->IntegratorSecondOrderLimited__j[3] =
      Lifting_wing_HIL_model_dll_B.Sum2_k[0];
  }

  // Derivatives for Integrator: '<S92>/Integrator1'
  _rtXdot->Integrator1_CSTATE_d[0] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a[0];

  // Derivatives for Integrator: '<S93>/Integrator'
  _rtXdot->Integrator_CSTATE_n[0] = Lifting_wing_HIL_model_dll_B.Product3_p[0];

  // Derivatives for Integrator: '<S272>/Integrator'
  _rtXdot->Integrator_CSTATE_o[0] =
    Lifting_wing_HIL_model_dll_B.RandomNumber1_n[0];

  // Derivatives for Integrator: '<S273>/Integrator1'
  _rtXdot->Integrator1_CSTATE_e[0] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[0];

  // Derivatives for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__c[1] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__j[1] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[4];
    _rtXdot->IntegratorSecondOrderLimited__j[4] =
      Lifting_wing_HIL_model_dll_B.Sum2_k[1];
  }

  // Derivatives for Integrator: '<S92>/Integrator1'
  _rtXdot->Integrator1_CSTATE_d[1] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a[1];

  // Derivatives for Integrator: '<S93>/Integrator'
  _rtXdot->Integrator_CSTATE_n[1] = Lifting_wing_HIL_model_dll_B.Product3_p[1];

  // Derivatives for Integrator: '<S272>/Integrator'
  _rtXdot->Integrator_CSTATE_o[1] =
    Lifting_wing_HIL_model_dll_B.RandomNumber1_n[1];

  // Derivatives for Integrator: '<S273>/Integrator1'
  _rtXdot->Integrator1_CSTATE_e[1] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[1];

  // Derivatives for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
  if (Lifting_wing_HIL_model_dll_DW.IntegratorSecondOrderLimited__c[2] == 0) {
    _rtXdot->IntegratorSecondOrderLimited__j[2] =
      Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[5];
    _rtXdot->IntegratorSecondOrderLimited__j[5] =
      Lifting_wing_HIL_model_dll_B.Sum2_k[2];
  }

  // Derivatives for Integrator: '<S92>/Integrator1'
  _rtXdot->Integrator1_CSTATE_d[2] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a[2];

  // Derivatives for Integrator: '<S93>/Integrator'
  _rtXdot->Integrator_CSTATE_n[2] = Lifting_wing_HIL_model_dll_B.Product3_p[2];

  // Derivatives for Integrator: '<S272>/Integrator'
  _rtXdot->Integrator_CSTATE_o[2] =
    Lifting_wing_HIL_model_dll_B.RandomNumber1_n[2];

  // Derivatives for Integrator: '<S273>/Integrator1'
  _rtXdot->Integrator1_CSTATE_e[2] =
    Lifting_wing_HIL_model_dll_B.RandomNumber3_a0[2];
}

// Model initialize function
void MulticopterModelClass::initialize()
{
  // Registration code
  {
    // Setup solver object
    rtsiSetSimTimeStepPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                          &(&Lifting_wing_HIL_model_dll_M)->Timing.simTimeStep);
    rtsiSetTPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                (&Lifting_wing_HIL_model_dll_M)->getTPtrPtr());
    rtsiSetStepSizePtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                       &(&Lifting_wing_HIL_model_dll_M)->Timing.stepSize0);
    rtsiSetdXPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                 &(&Lifting_wing_HIL_model_dll_M)->derivs);
    rtsiSetContStatesPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo, (real_T **)
                         &(&Lifting_wing_HIL_model_dll_M)->contStates);
    rtsiSetNumContStatesPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
      &(&Lifting_wing_HIL_model_dll_M)->Sizes.numContStates);
    rtsiSetNumPeriodicContStatesPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
      &(&Lifting_wing_HIL_model_dll_M)->Sizes.numPeriodicContStates);
    rtsiSetPeriodicContStateIndicesPtr(&(&Lifting_wing_HIL_model_dll_M)
      ->solverInfo, &(&Lifting_wing_HIL_model_dll_M)->periodicContStateIndices);
    rtsiSetPeriodicContStateRangesPtr(&(&Lifting_wing_HIL_model_dll_M)
      ->solverInfo, &(&Lifting_wing_HIL_model_dll_M)->periodicContStateRanges);
    rtsiSetContStateDisabledPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
      (boolean_T**) &(&Lifting_wing_HIL_model_dll_M)->contStateDisabled);
    rtsiSetErrorStatusPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                          (&Lifting_wing_HIL_model_dll_M)->getErrorStatusPtr());
    rtsiSetRTModelPtr(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                      (&Lifting_wing_HIL_model_dll_M));
  }

  rtsiSetSimTimeStep(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,
                     MAJOR_TIME_STEP);
  rtsiSetIsMinorTimeStepWithModeChange(&(&Lifting_wing_HIL_model_dll_M)
    ->solverInfo, false);
  rtsiSetIsContModeFrozen(&(&Lifting_wing_HIL_model_dll_M)->solverInfo, false);
  (&Lifting_wing_HIL_model_dll_M)->intgData.y = (&Lifting_wing_HIL_model_dll_M
    )->odeY;
  (&Lifting_wing_HIL_model_dll_M)->intgData.f[0] =
    (&Lifting_wing_HIL_model_dll_M)->odeF[0];
  (&Lifting_wing_HIL_model_dll_M)->intgData.f[1] =
    (&Lifting_wing_HIL_model_dll_M)->odeF[1];
  (&Lifting_wing_HIL_model_dll_M)->intgData.f[2] =
    (&Lifting_wing_HIL_model_dll_M)->odeF[2];
  (&Lifting_wing_HIL_model_dll_M)->intgData.f[3] =
    (&Lifting_wing_HIL_model_dll_M)->odeF[3];
  (&Lifting_wing_HIL_model_dll_M)->contStates = ((X_Lifting_wing_HIL_model_dll_T
    *) &Lifting_wing_HIL_model_dll_X);
  (&Lifting_wing_HIL_model_dll_M)->contStateDisabled =
    ((XDis_Lifting_wing_HIL_model_d_T *) &Lifting_wing_HIL_model_dll_XDis);
  (&Lifting_wing_HIL_model_dll_M)->Timing.tStart = (0.0);
  rtsiSetSolverData(&(&Lifting_wing_HIL_model_dll_M)->solverInfo, static_cast<
                    void *>(&(&Lifting_wing_HIL_model_dll_M)->intgData));
  rtsiSetSolverName(&(&Lifting_wing_HIL_model_dll_M)->solverInfo,"ode4");
  (&Lifting_wing_HIL_model_dll_M)->setTPtr(&(&Lifting_wing_HIL_model_dll_M)
    ->Timing.tArray[0]);
  (&Lifting_wing_HIL_model_dll_M)->Timing.stepSize0 = 0.001;
  (&Lifting_wing_HIL_model_dll_M)->setFirstInitCond(1);

  {
    real_T Init_Rads;
    real_T Init_Rads_b;
    real_T Init_Rads_f;
    real_T Init_Rads_fh;
    real_T Init_Rads_g;
    real_T Init_Rads_h;
    int32_T i;
    int32_T t;
    uint32_T tseed;
    static const uint32_T tmp[625]{ 5489U, 1301868182U, 2938499221U, 2950281878U,
      1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U, 219885934U,
      2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,
      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,
      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,
      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,
      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,
      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,
      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,
      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,
      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,
      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,
      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,
      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,
      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,
      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,
      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,
      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,
      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,
      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,
      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,
      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,
      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,
      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,
      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,
      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,
      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,
      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,
      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,
      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,
      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,
      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,
      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,
      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,
      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,
      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,
      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,
      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,
      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,
      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,
      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,
      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,
      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,
      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,
      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,
      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,
      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,
      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,
      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,
      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,
      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,
      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,
      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,
      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,
      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,
      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,
      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,
      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,
      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,
      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,
      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,
      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,
      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,
      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,
      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,
      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,
      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,
      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,
      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,
      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,
      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,
      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,
      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,
      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,
      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,
      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,
      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,
      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,
      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,
      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,
      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,
      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,
      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,
      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,
      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,
      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,
      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,
      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,
      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,
      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,
      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,
      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,
      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,
      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,
      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,
      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,
      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,
      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,
      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,
      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,
      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,
      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,
      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,
      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,
      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,
      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,
      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,
      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,
      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,
      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,
      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,
      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,
      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,
      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };

    // Start for Constant: '<S277>/Init_Rads'
    Init_Rads = Lifting_wing_HIL_model_dll_P.ModelInit_Rads;

    // Start for Constant: '<S278>/Init_Rads'
    Init_Rads_h = Lifting_wing_HIL_model_dll_P.ModelInit_Rads;

    // Start for Constant: '<S279>/Init_Rads'
    Init_Rads_f = Lifting_wing_HIL_model_dll_P.ModelInit_Rads;

    // Start for Constant: '<S280>/Init_Rads'
    Init_Rads_b = Lifting_wing_HIL_model_dll_P.ModelInit_Rads;

    // Start for If: '<S198>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem = -1;

    // Start for If: '<S189>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f = -1;

    // Start for S-Function (saeroatmos): '<S263>/S-Function'
    {
      real_T *temp_table = (real_T *)
        &Lifting_wing_HIL_model_dll_DW.SFunction_temp_table[0];
      real_T *pres_table = (real_T *)
        &Lifting_wing_HIL_model_dll_DW.SFunction_pres_table[0];

      // COESA
      //
      //  Initialize COESA pressure and temperature tables.

      InitCalcAtmosCOESA( temp_table, pres_table );
    }

    // Start for If: '<S296>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_p = -1;

    // Start for If: '<S324>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_l = -1;

    // Start for Constant: '<S282>/Init_Rads'
    Init_Rads_g = Lifting_wing_HIL_model_dll_P.ModelInit_servoRads;

    // Start for Constant: '<S283>/Init_Rads'
    Init_Rads_fh = Lifting_wing_HIL_model_dll_P.ModelInit_servoRads;

    // Start for If: '<S35>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_m = -1;

    // Start for If: '<S26>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_f4 = -1;

    // Start for If: '<S144>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_j = -1;

    // Start for If: '<S135>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_g = -1;

    // Start for If: '<S47>/If'
    Lifting_wing_HIL_model_dll_DW.If_ActiveSubsystem_a = -1;

    // Start for If: '<S50>/If1'
    Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem = -1;

    // Start for If: '<S339>/If1'
    Lifting_wing_HIL_model_dll_DW.If1_ActiveSubsystem_l = -1;

    // InitializeConditions for SecondOrderIntegrator: '<S100>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[0] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited_IC;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[1] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited_IC;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[2] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited_IC;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[3] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__h;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[4] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__h;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_CS[5] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__h;

    // InitializeConditions for DiscreteIntegrator: '<S277>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE = Init_Rads;

    // InitializeConditions for DiscreteIntegrator: '<S278>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_e = Init_Rads_h;

    // InitializeConditions for DiscreteIntegrator: '<S279>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_o = Init_Rads_f;

    // InitializeConditions for DiscreteIntegrator: '<S280>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_c = Init_Rads_b;

    // InitializeConditions for Integrator: '<S297>/q0 q1 q2 q3'
    if ((&Lifting_wing_HIL_model_dll_M)->isFirstInitCond()) {
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[0] = 0.0;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[1] = 0.0;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[2] = 0.0;
      Lifting_wing_HIL_model_dll_X.q0q1q2q3_CSTATE[3] = 0.0;
    }

    Lifting_wing_HIL_model_dll_DW.q0q1q2q3_DWORK1 = true;

    // End of InitializeConditions for Integrator: '<S297>/q0 q1 q2 q3'

    // InitializeConditions for DiscreteIntegrator: '<S282>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_f = Init_Rads_g;

    // InitializeConditions for UnitDelay: '<S284>/Unit Delay'
    Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE =
      Lifting_wing_HIL_model_dll_P.UnitDelay_InitialCondition;

    // InitializeConditions for DiscreteIntegrator: '<S283>/Discrete-Time Integrator' 
    Lifting_wing_HIL_model_dll_DW.DiscreteTimeIntegrator_DSTATE_j = Init_Rads_fh;

    // InitializeConditions for UnitDelay: '<S285>/Unit Delay'
    Lifting_wing_HIL_model_dll_DW.UnitDelay_DSTATE_h =
      Lifting_wing_HIL_model_dll_P.UnitDelay_InitialCondition_n;

    // InitializeConditions for TransferFcn: '<S272>/Transfer Fcn'
    Lifting_wing_HIL_model_dll_X.TransferFcn_CSTATE = 0.0;

    // InitializeConditions for TransferFcn: '<S272>/Transfer Fcn1'
    Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE = 0.0;

    // InitializeConditions for TransferFcn: '<S272>/Transfer Fcn2'
    Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE = 0.0;

    // InitializeConditions for TransferFcn: '<S273>/Transfer Fcn3'
    Lifting_wing_HIL_model_dll_X.TransferFcn3_CSTATE = 0.0;

    // InitializeConditions for TransferFcn: '<S273>/Transfer Fcn4'
    Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE = 0.0;

    // InitializeConditions for TransferFcn: '<S273>/Transfer Fcn5'
    Lifting_wing_HIL_model_dll_X.TransferFcn5_CSTATE = 0.0;

    // InitializeConditions for Integrator: '<S295>/ub,vb,wb'
    Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.ModelInit_VelB[0];

    // InitializeConditions for Integrator: '<S295>/xe,ye,ze'
    Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.ModelInit_PosE[0];

    // InitializeConditions for Integrator: '<S295>/p,q,r '
    Lifting_wing_HIL_model_dll_X.pqr_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.ModelInit_RateB[0];

    // InitializeConditions for RandomNumber: '<S89>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNaSeed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput[0] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[0] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;

    // InitializeConditions for Integrator: '<S89>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC;

    // InitializeConditions for Integrator: '<S295>/ub,vb,wb'
    Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.ModelInit_VelB[1];

    // InitializeConditions for Integrator: '<S295>/xe,ye,ze'
    Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.ModelInit_PosE[1];

    // InitializeConditions for Integrator: '<S295>/p,q,r '
    Lifting_wing_HIL_model_dll_X.pqr_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.ModelInit_RateB[1];

    // InitializeConditions for RandomNumber: '<S89>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNaSeed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput[1] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[1] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;

    // InitializeConditions for Integrator: '<S89>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC;

    // InitializeConditions for Integrator: '<S295>/ub,vb,wb'
    Lifting_wing_HIL_model_dll_X.ubvbwb_CSTATE[2] =
      Lifting_wing_HIL_model_dll_P.ModelInit_VelB[2];

    // InitializeConditions for Integrator: '<S295>/xe,ye,ze'
    Lifting_wing_HIL_model_dll_X.xeyeze_CSTATE[2] =
      Lifting_wing_HIL_model_dll_P.ModelInit_PosE[2];

    // InitializeConditions for Integrator: '<S295>/p,q,r '
    Lifting_wing_HIL_model_dll_X.pqr_CSTATE[2] =
      Lifting_wing_HIL_model_dll_P.ModelInit_RateB[2];

    // InitializeConditions for RandomNumber: '<S89>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNaSeed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput[2] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelNa[2] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean;

    // InitializeConditions for Integrator: '<S89>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE[2] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC;

    // InitializeConditions for SecondOrderIntegrator: '<S166>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[0] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__m;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[1] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__m;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[2] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__m;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[3] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__b;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[4] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__b;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__f[5] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__b;
    for (i = 0; i < 300; i++) {
      // InitializeConditions for Delay: '<S89>/Delay'
      Lifting_wing_HIL_model_dll_DW.Delay_DSTATE[i] =
        Lifting_wing_HIL_model_dll_P.Delay_InitialCondition;

      // InitializeConditions for Delay: '<S92>/Delay1'
      Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE[i] =
        Lifting_wing_HIL_model_dll_P.Delay1_InitialCondition;
    }

    // InitializeConditions for Integrator: '<S93>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC;

    // InitializeConditions for RandomNumber: '<S93>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber2_Seed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_d[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_j[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[0]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[0] +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[0];

    // InitializeConditions for Integrator: '<S93>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC;

    // InitializeConditions for RandomNumber: '<S93>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber2_Seed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_d[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_j[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[1]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[1] +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[1];

    // InitializeConditions for Integrator: '<S93>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE[2] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC;

    // InitializeConditions for RandomNumber: '<S93>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber2_Seed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_d[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_j[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_d[2]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber2_StdDev[2] +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean[2];

    // InitializeConditions for Delay: '<S93>/Delay1'
    for (i = 0; i < 300; i++) {
      Lifting_wing_HIL_model_dll_DW.Delay1_DSTATE_l[i] =
        Lifting_wing_HIL_model_dll_P.Delay1_InitialCondition_l;
    }

    // End of InitializeConditions for Delay: '<S93>/Delay1'

    // InitializeConditions for RandomNumber: '<S90>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNmSeed);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_p = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_h = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNm * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_p) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean;

    // End of InitializeConditions for RandomNumber: '<S90>/Random Number1'

    // InitializeConditions for Integrator: '<S90>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_m =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_i;

    // InitializeConditions for UniformRandomNumber: '<S91>/Uniform Random Number1' 
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Seed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_h[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[0] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[0] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[0]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[0]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[0];
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Seed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_h[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[1] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[1] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[1]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[1]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[1];
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Seed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_h[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber1_NextOutput[2] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Maximum[2] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[2]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_h[2]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber1_Minimum[2];

    // End of InitializeConditions for UniformRandomNumber: '<S91>/Uniform Random Number1' 

    // InitializeConditions for TransferFcn: '<S127>/Transfer Fcn4'
    Lifting_wing_HIL_model_dll_X.TransferFcn4_CSTATE_l = 0.0;

    // InitializeConditions for TransferFcn: '<S127>/Transfer Fcn1'
    Lifting_wing_HIL_model_dll_X.TransferFcn1_CSTATE_o = 0.0;

    // InitializeConditions for TransferFcn: '<S127>/Transfer Fcn2'
    Lifting_wing_HIL_model_dll_X.TransferFcn2_CSTATE_j = 0.0;

    // InitializeConditions for RandomNumber: '<S89>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBaSeed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_a[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_g[0] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[0] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;

    // InitializeConditions for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[0] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__j;

    // InitializeConditions for RandomNumber: '<S89>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBaSeed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_a[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_g[1] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[1] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;

    // InitializeConditions for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[1] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__j;

    // InitializeConditions for RandomNumber: '<S89>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBaSeed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_a[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_g[2] = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseAccelBa[2] * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_a[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_b;

    // InitializeConditions for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[2] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__j;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[3] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__l;

    // InitializeConditions for Integrator: '<S89>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_f[0] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_g;

    // InitializeConditions for RandomNumber: '<S89>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_n[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_b[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[0]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[0] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[0];

    // InitializeConditions for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[4] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__l;

    // InitializeConditions for Integrator: '<S89>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_f[1] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_g;

    // InitializeConditions for RandomNumber: '<S89>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_n[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_b[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[1]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[1] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[1];

    // InitializeConditions for SecondOrderIntegrator: '<S113>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited_fi[5] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__l;

    // InitializeConditions for Integrator: '<S89>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_f[2] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_g;

    // InitializeConditions for RandomNumber: '<S89>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_n[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_b[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_n[2]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev[2] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean[2];

    // InitializeConditions for RandomNumber: '<S90>/Random Number2'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNbmSeed);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_g = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_l = std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseBaroNbm * 1.0E-5) *
      rt_nrand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_g) +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_a;

    // End of InitializeConditions for RandomNumber: '<S90>/Random Number2'

    // InitializeConditions for UniformRandomNumber: '<S91>/Uniform Random Number4' 
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Seed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_l[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[0] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[0] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[0]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[0]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[0];

    // InitializeConditions for RandomNumber: '<S92>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNgSeed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_nm[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_i[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[0]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

    // InitializeConditions for Integrator: '<S92>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_l[0] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_h;

    // InitializeConditions for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[0] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__c;

    // InitializeConditions for UniformRandomNumber: '<S91>/Uniform Random Number4' 
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Seed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_l[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[1] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[1] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[1]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[1]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[1];

    // InitializeConditions for RandomNumber: '<S92>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNgSeed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_nm[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_i[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[1]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

    // InitializeConditions for Integrator: '<S92>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_l[1] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_h;

    // InitializeConditions for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[1] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__c;

    // InitializeConditions for UniformRandomNumber: '<S91>/Uniform Random Number4' 
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Seed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_l[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.UniformRandomNumber4_NextOutput[2] =
      (Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Maximum[2] -
       Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[2]) *
      rt_urand_Upu32_Yd_f_pw_snf(&Lifting_wing_HIL_model_dll_DW.RandSeed_l[2]) +
      Lifting_wing_HIL_model_dll_P.UniformRandomNumber4_Minimum[2];

    // InitializeConditions for RandomNumber: '<S92>/Random Number'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNgSeed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_nm[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_i[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_nm[2]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNg[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_g;

    // InitializeConditions for Integrator: '<S92>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_l[2] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_h;

    // InitializeConditions for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[2] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__c;
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[3] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__f;

    // InitializeConditions for RandomNumber: '<S92>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbgSeed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_p5[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_gk[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_p5[0]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

    // InitializeConditions for Integrator: '<S92>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_d[0] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o;

    // InitializeConditions for RandomNumber: '<S92>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_b[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_c[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_le[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_c[0]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[0] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[0];

    // InitializeConditions for Integrator: '<S93>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_n[0] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_b;

    // InitializeConditions for RandomNumber: '<S93>/Random Number' incorporates:
    //   RandomNumber: '<S93>/Random Number1'

    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNmSeed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_i[0] = tseed;
    Init_Rads_h = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[0]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_k[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[0]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

    // InitializeConditions for RandomNumber: '<S93>/Random Number1'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber1_Seed[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_g1[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ko[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_g1[0]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

    // InitializeConditions for RandomNumber: '<S93>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_a[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_go[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ld[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_go[0]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[0] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[0];

    // InitializeConditions for RandomNumber: '<S272>/Random Number'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNaSeed
      [0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_m[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_c[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[0]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

    // InitializeConditions for Integrator: '<S272>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[0] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_o;

    // InitializeConditions for RandomNumber: '<S272>/Random Number1' incorporates:
    //   RandomNumber: '<S273>/Random Number3'

    Init_Rads_h = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBaSeed[0]);
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_k[0] = tseed;
    Init_Rads_f = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[0]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_cd[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_k[0]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

    // InitializeConditions for RandomNumber: '<S273>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNaSeed
      [0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_ld[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_im[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_ld[0]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[0]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

    // InitializeConditions for Integrator: '<S273>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[0] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o2;

    // InitializeConditions for RandomNumber: '<S273>/Random Number3'
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_o[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_o[0] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[0]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;

    // InitializeConditions for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[4] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__f;

    // InitializeConditions for RandomNumber: '<S92>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbgSeed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_p5[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_gk[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_p5[1]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

    // InitializeConditions for Integrator: '<S92>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_d[1] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o;

    // InitializeConditions for RandomNumber: '<S92>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_b[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_c[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_le[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_c[1]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[1] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[1];

    // InitializeConditions for Integrator: '<S93>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_n[1] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_b;

    // InitializeConditions for RandomNumber: '<S93>/Random Number' incorporates:
    //   RandomNumber: '<S93>/Random Number1'

    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNmSeed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_i[1] = tseed;
    Init_Rads_h = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[1]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_k[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[1]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

    // InitializeConditions for RandomNumber: '<S93>/Random Number1'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber1_Seed[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_g1[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ko[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_g1[1]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

    // InitializeConditions for RandomNumber: '<S93>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_a[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_go[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ld[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_go[1]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[1] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[1];

    // InitializeConditions for RandomNumber: '<S272>/Random Number'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNaSeed
      [1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_m[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_c[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[1]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

    // InitializeConditions for Integrator: '<S272>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[1] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_o;

    // InitializeConditions for RandomNumber: '<S272>/Random Number1' incorporates:
    //   RandomNumber: '<S273>/Random Number3'

    Init_Rads_h = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBaSeed[1]);
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_k[1] = tseed;
    Init_Rads_f = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[1]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_cd[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_k[1]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

    // InitializeConditions for RandomNumber: '<S273>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNaSeed
      [1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_ld[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_im[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_ld[1]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[1]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

    // InitializeConditions for Integrator: '<S273>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[1] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o2;

    // InitializeConditions for RandomNumber: '<S273>/Random Number3'
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_o[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_o[1] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[1]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;

    // InitializeConditions for SecondOrderIntegrator: '<S163>/Integrator, Second-Order Limited' 
    Lifting_wing_HIL_model_dll_X.IntegratorSecondOrderLimited__j[5] =
      Lifting_wing_HIL_model_dll_P.IntegratorSecondOrderLimited__f;

    // InitializeConditions for RandomNumber: '<S92>/Random Number1'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbgSeed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_p5[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_gk[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_p5[2]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseGyroNbg[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_d;

    // InitializeConditions for Integrator: '<S92>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_d[2] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o;

    // InitializeConditions for RandomNumber: '<S92>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_b[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_c[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_le[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_c[2]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_e[2] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_e[2];

    // InitializeConditions for Integrator: '<S93>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_n[2] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_b;

    // InitializeConditions for RandomNumber: '<S93>/Random Number' incorporates:
    //   RandomNumber: '<S93>/Random Number1'

    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNmSeed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_i[2] = tseed;
    Init_Rads_h = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMagNm[2]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_k[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_i[2]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_l;

    // InitializeConditions for RandomNumber: '<S93>/Random Number1'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber1_Seed[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_g1[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ko[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_g1[2]) * Init_Rads_h +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_p;

    // InitializeConditions for RandomNumber: '<S93>/Random Number3'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.RandomNumber3_Seed_a[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_go[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ld[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_go[2]) *
      Lifting_wing_HIL_model_dll_P.RandomNumber3_StdDev_d[2] +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_p[2];

    // InitializeConditions for RandomNumber: '<S272>/Random Number'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNaSeed
      [2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_m[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_c[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_m[2]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFNa[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber_Mean_h;

    // InitializeConditions for Integrator: '<S272>/Integrator'
    Lifting_wing_HIL_model_dll_X.Integrator_CSTATE_o[2] =
      Lifting_wing_HIL_model_dll_P.Integrator_IC_o;

    // InitializeConditions for RandomNumber: '<S272>/Random Number1' incorporates:
    //   RandomNumber: '<S273>/Random Number3'

    Init_Rads_h = std::floor
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBaSeed[2]);
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_k[2] = tseed;
    Init_Rads_f = std::sqrt(Lifting_wing_HIL_model_dll_P.ModelParam_noiseFBa[2]);
    Lifting_wing_HIL_model_dll_DW.NextOutput_cd[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_k[2]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber1_Mean_pz;

    // InitializeConditions for RandomNumber: '<S273>/Random Number2'
    Init_Rads = std::floor(Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNaSeed
      [2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_ld[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_im[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_ld[2]) * std::sqrt
      (Lifting_wing_HIL_model_dll_P.ModelParam_noiseMNa[2]) +
      Lifting_wing_HIL_model_dll_P.RandomNumber2_Mean_g;

    // InitializeConditions for Integrator: '<S273>/Integrator1'
    Lifting_wing_HIL_model_dll_X.Integrator1_CSTATE_e[2] =
      Lifting_wing_HIL_model_dll_P.Integrator1_IC_o2;

    // InitializeConditions for RandomNumber: '<S273>/Random Number3'
    if (std::isnan(Init_Rads_h) || std::isinf(Init_Rads_h)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads_h, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_o[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_o[2] = rt_nrand_Upu32_Yd_f_pw_snf
      (&Lifting_wing_HIL_model_dll_DW.RandSeed_o[2]) * Init_Rads_f +
      Lifting_wing_HIL_model_dll_P.RandomNumber3_Mean_h;

    // SystemInitialize for MATLAB Function: '<S172>/Ground Model'
    // '<S178>:1:6' takeoffFlag=int8(0);
    // '<S178>:1:11' landFlag=int8(1);
    Lifting_wing_HIL_model_dll_DW.landFlag = 1;

    // SystemInitialize for Merge: '<S189>/Merge'
    Lifting_wing_HIL_model_dll_B.Merge_m =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_h;

    // SystemInitialize for Atomic SubSystem: '<S172>/Wind Models'
    // Start for If: '<S228>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' 
    Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifHei = -1;

    // Start for If: '<S229>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' 
    Lifting_wing_HIL_model_dll_DW.ifHeightMaxlowaltitudeelseifH_f = -1;

    // InitializeConditions for RandomNumber: '<S233>/White Noise'
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_a[0]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_kb[0] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ia[0] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_kb[0]) *
      Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
      Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_a[1]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_kb[1] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ia[1] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_kb[1]) *
      Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
      Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_a[2]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_kb[2] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ia[2] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_kb[2]) *
      Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
      Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;
    Init_Rads = std::floor
      (Lifting_wing_HIL_model_dll_P.DrydenWindTurbulenceModelCont_a[3]);
    if (std::isnan(Init_Rads) || std::isinf(Init_Rads)) {
      Init_Rads = 0.0;
    } else {
      Init_Rads = std::fmod(Init_Rads, 4.294967296E+9);
    }

    tseed = Init_Rads < 0.0 ? static_cast<uint32_T>(-static_cast<int32_T>(
      static_cast<uint32_T>(-Init_Rads))) : static_cast<uint32_T>(Init_Rads);
    i = static_cast<int32_T>(tseed >> 16U);
    t = static_cast<int32_T>(tseed & 32768U);
    tseed = ((((tseed - (static_cast<uint32_T>(i) << 16U)) +
               static_cast<uint32_T>(t)) << 16U) + static_cast<uint32_T>(t)) +
      static_cast<uint32_T>(i);
    if (tseed < 1U) {
      tseed = 1144108930U;
    } else if (tseed > 2147483646U) {
      tseed = 2147483646U;
    }

    Lifting_wing_HIL_model_dll_DW.RandSeed_kb[3] = tseed;
    Lifting_wing_HIL_model_dll_DW.NextOutput_ia[3] = rt_nrand_Upu32_Yd_f_pw_snf(
      &Lifting_wing_HIL_model_dll_DW.RandSeed_kb[3]) *
      Lifting_wing_HIL_model_dll_P.WhiteNoise_StdDev +
      Lifting_wing_HIL_model_dll_P.WhiteNoise_Mean;

    // End of InitializeConditions for RandomNumber: '<S233>/White Noise'

    // SystemInitialize for Enabled SubSystem: '<S215>/Distance into gust (x)'
    // InitializeConditions for Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)' 
    Lifting_wing_HIL_model_dll_X.DistanceintoGustxLimitedtogus_n =
      Lifting_wing_HIL_model_dll_P.DistanceintoGustxLimitedtogustl;

    // SystemInitialize for Integrator: '<S218>/Distance into Gust (x) (Limited to gust length d)' incorporates:
    //   Outport: '<S218>/x'

    Lifting_wing_HIL_model_dll_B.DistanceintoGustxLimitedtogustl =
      Lifting_wing_HIL_model_dll_P.x_Y0;

    // End of SystemInitialize for SubSystem: '<S215>/Distance into gust (x)'

    // SystemInitialize for Enabled SubSystem: '<S215>/Distance into gust (y)'
    Lifting__Distanceintogusty_Init
      (&Lifting_wing_HIL_model_dll_B.Distanceintogusty,
       &Lifting_wing_HIL_model_dll_P.Distanceintogusty,
       &Lifting_wing_HIL_model_dll_X.Distanceintogusty);

    // End of SystemInitialize for SubSystem: '<S215>/Distance into gust (y)'

    // SystemInitialize for Enabled SubSystem: '<S215>/Distance into gust (z)'
    Lifting__Distanceintogusty_Init
      (&Lifting_wing_HIL_model_dll_B.Distanceintogustz,
       &Lifting_wing_HIL_model_dll_P.Distanceintogustz,
       &Lifting_wing_HIL_model_dll_X.Distanceintogustz);

    // End of SystemInitialize for SubSystem: '<S215>/Distance into gust (z)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hpgw'
    // InitializeConditions for Integrator: '<S234>/pgw_p'
    Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.pgw_p_IC;

    // End of SystemInitialize for SubSystem: '<S223>/Hpgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hwgw(s)'
    // InitializeConditions for Integrator: '<S239>/wg_p1'
    Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.wg_p1_IC;

    // InitializeConditions for Integrator: '<S239>/wg_p2'
    Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.wg_p2_IC;

    // SystemInitialize for Product: '<S239>/Lwg//V 1' incorporates:
    //   Outport: '<S239>/wgw'

    Lifting_wing_HIL_model_dll_B.LwgV1[0] = Lifting_wing_HIL_model_dll_P.wgw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hwgw(s)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hqgw'
    // InitializeConditions for Integrator: '<S235>/qgw_p'
    Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.qgw_p_IC;

    // SystemInitialize for Product: '<S235>/w' incorporates:
    //   Outport: '<S235>/qgw'

    Lifting_wing_HIL_model_dll_B.w_b5[0] = Lifting_wing_HIL_model_dll_P.qgw_Y0;

    // End of SystemInitialize for SubSystem: '<S223>/Hqgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hvgw(s)'
    // InitializeConditions for Integrator: '<S238>/vg_p1'
    Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.vg_p1_IC;

    // InitializeConditions for Integrator: '<S238>/vgw_p2'
    Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.vgw_p2_IC;

    // SystemInitialize for Product: '<S238>/w 1' incorporates:
    //   Outport: '<S238>/vgw'

    Lifting_wing_HIL_model_dll_B.w1[0] = Lifting_wing_HIL_model_dll_P.vgw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hvgw(s)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hrgw'
    // InitializeConditions for Integrator: '<S236>/rgw_p'
    Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.rgw_p_IC;

    // End of SystemInitialize for SubSystem: '<S223>/Hrgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hugw(s)'
    // InitializeConditions for Integrator: '<S237>/ug_p'
    Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[0] =
      Lifting_wing_HIL_model_dll_P.ug_p_IC;

    // SystemInitialize for Product: '<S237>/w1' incorporates:
    //   Outport: '<S237>/ugw'

    Lifting_wing_HIL_model_dll_B.w1_h[0] = Lifting_wing_HIL_model_dll_P.ugw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hugw(s)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hpgw'
    // InitializeConditions for Integrator: '<S234>/pgw_p'
    Lifting_wing_HIL_model_dll_X.pgw_p_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.pgw_p_IC;

    // End of SystemInitialize for SubSystem: '<S223>/Hpgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hwgw(s)'
    // InitializeConditions for Integrator: '<S239>/wg_p1'
    Lifting_wing_HIL_model_dll_X.wg_p1_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.wg_p1_IC;

    // InitializeConditions for Integrator: '<S239>/wg_p2'
    Lifting_wing_HIL_model_dll_X.wg_p2_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.wg_p2_IC;

    // SystemInitialize for Product: '<S239>/Lwg//V 1' incorporates:
    //   Outport: '<S239>/wgw'

    Lifting_wing_HIL_model_dll_B.LwgV1[1] = Lifting_wing_HIL_model_dll_P.wgw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hwgw(s)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hqgw'
    // InitializeConditions for Integrator: '<S235>/qgw_p'
    Lifting_wing_HIL_model_dll_X.qgw_p_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.qgw_p_IC;

    // SystemInitialize for Product: '<S235>/w' incorporates:
    //   Outport: '<S235>/qgw'

    Lifting_wing_HIL_model_dll_B.w_b5[1] = Lifting_wing_HIL_model_dll_P.qgw_Y0;

    // End of SystemInitialize for SubSystem: '<S223>/Hqgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hvgw(s)'
    // InitializeConditions for Integrator: '<S238>/vg_p1'
    Lifting_wing_HIL_model_dll_X.vg_p1_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.vg_p1_IC;

    // InitializeConditions for Integrator: '<S238>/vgw_p2'
    Lifting_wing_HIL_model_dll_X.vgw_p2_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.vgw_p2_IC;

    // SystemInitialize for Product: '<S238>/w 1' incorporates:
    //   Outport: '<S238>/vgw'

    Lifting_wing_HIL_model_dll_B.w1[1] = Lifting_wing_HIL_model_dll_P.vgw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hvgw(s)'

    // SystemInitialize for Enabled SubSystem: '<S223>/Hrgw'
    // InitializeConditions for Integrator: '<S236>/rgw_p'
    Lifting_wing_HIL_model_dll_X.rgw_p_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.rgw_p_IC;

    // End of SystemInitialize for SubSystem: '<S223>/Hrgw'

    // SystemInitialize for Enabled SubSystem: '<S224>/Hugw(s)'
    // InitializeConditions for Integrator: '<S237>/ug_p'
    Lifting_wing_HIL_model_dll_X.ug_p_CSTATE[1] =
      Lifting_wing_HIL_model_dll_P.ug_p_IC;

    // SystemInitialize for Product: '<S237>/w1' incorporates:
    //   Outport: '<S237>/ugw'

    Lifting_wing_HIL_model_dll_B.w1_h[1] = Lifting_wing_HIL_model_dll_P.ugw_Y0;

    // End of SystemInitialize for SubSystem: '<S224>/Hugw(s)'
    // End of SystemInitialize for SubSystem: '<S172>/Wind Models'

    // SystemInitialize for IfAction SubSystem: '<S296>/Negative Trace'
    Lifting_wing_NegativeTrace_Init
      (&Lifting_wing_HIL_model_dll_DW.NegativeTrace_h);

    // End of SystemInitialize for SubSystem: '<S296>/Negative Trace'

    // SystemInitialize for Merge: '<S296>/Merge'
    Lifting_wing_HIL_model_dll_B.Merge_p[0] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_i[0];
    Lifting_wing_HIL_model_dll_B.Merge_p[1] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_i[1];
    Lifting_wing_HIL_model_dll_B.Merge_p[2] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_i[2];
    Lifting_wing_HIL_model_dll_B.Merge_p[3] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_i[3];

    // SystemInitialize for Merge: '<S26>/Merge'
    Lifting_wing_HIL_model_dll_B.Merge_c =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_p;

    // SystemInitialize for Merge: '<S135>/Merge'
    Lifting_wing_HIL_model_dll_B.Merge_pz =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_ee;

    // SystemInitialize for IfAction SubSystem: '<S47>/Negative Trace'
    Lifting_wing_NegativeTrace_Init(&Lifting_wing_HIL_model_dll_DW.NegativeTrace);

    // End of SystemInitialize for SubSystem: '<S47>/Negative Trace'

    // SystemInitialize for Merge: '<S47>/Merge'
    Lifting_wing_HIL_model_dll_B.Merge_k[0] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_d[0];
    Lifting_wing_HIL_model_dll_B.Merge_k[1] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_d[1];
    Lifting_wing_HIL_model_dll_B.Merge_k[2] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_d[2];
    Lifting_wing_HIL_model_dll_B.Merge_k[3] =
      Lifting_wing_HIL_model_dll_P.Merge_InitialOutput_d[3];

    // SystemInitialize for MATLAB Function: '<Root>/CollisionDetection'
    Lifting_wing_HIL_model_dll_DW.method = 7U;
    Lifting_wing_HIL_model_dll_DW.state_gk = 1144108930U;
    Lifting_wing_HIL_model_dll_DW.state_as[0] = 362436069U;
    Lifting_wing_HIL_model_dll_DW.state_as[1] = 521288629U;

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_ng_var'
    // '<S1>:1:7' isCol = int8(0);
    // '<S1>:1:13' fOut = [0; 0; 0; 0; 0; 0];
    // '<S1>:1:19' mv0 = [0; 0; 0];
    // '<S1>:1:25' tColi = 0;
    // '<S2>:1:6' lastZ=0;
    // '<S17>:1:5' xTemp=zeros(8,1);
    // '<S17>:1:10' kk=0;
    // '<S17>:1:15' ss=zeros(6,1);
    // '<S395>:1:5' gyro_ng_var_init = 0;
    // '<S395>:1:6' gyro_ng_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_T.data[0] = 0.0;

    // '<S395>:1:7' gyro_ng_var_dt = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_dt.data[0] = 0.0;

    // '<S395>:1:8' gyro_ng_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_ng_var_am.data[0] = 1.0;

    // '<S395>:1:9' gyro_ng_var_en = 0;
    // '<S395>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_i.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_i.size[1] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_i.data[0] = 1.0;

    // '<S395>:1:11' v = 0;
    Lifting_wing_HIL_model_dll_DW.v_n.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.v_n.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_kgp'
    // '<S393>:1:5' gyro_kgp_init = 0;
    // '<S393>:1:6' gyro_kgp_T = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_T.data[0] = 0.0;

    // '<S393>:1:7' gyro_kgp_dt = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_dt.data[0] = 0.0;

    // '<S393>:1:8' gyro_kgp_am = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_kgp_am.data[0] = 1.0;

    // '<S393>:1:9' gyro_kgp_en = 0;
    // '<S393>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_n.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_n.size[1] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_n.data[0] = 1.0;

    // '<S393>:1:11' v = 0;
    Lifting_wing_HIL_model_dll_DW.v_bm.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.v_bm.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_kg_cg'
    // '<S392>:1:6' gyro_init = 0;
    // '<S392>:1:7' gyro_kg_limit = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_kg_limit.data[0] = 0.0;

    // '<S392>:1:8' gyro_kg_cg_en = 0;
    // '<S392>:1:9' gyro_cg_limit = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_cg_limit.data[0] = 0.0;

    // '<S392>:1:10' gyro_kg = ones(3, 1);
    // '<S392>:1:11' gyro_cg = zeros(3, 1);
    Lifting_wing_HIL_model_dll_DW.gyro_kg[0] = 1.0;
    Lifting_wing_HIL_model_dll_DW.gyro_kg[1] = 1.0;
    Lifting_wing_HIL_model_dll_DW.gyro_kg[2] = 1.0;

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_nbg_var'
    // '<S394>:1:5' gyro_nbg_var_init = 0;
    // '<S394>:1:6' gyro_nbg_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_T.data[0] = 0.0;

    // '<S394>:1:7' gyro_nbg_var_dt = 0;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_dt.data[0] = 0.0;

    // '<S394>:1:8' gyro_nbg_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.gyro_nbg_var_am.data[0] = 1.0;

    // '<S394>:1:9' gyro_nbg_var_en = 0;
    // '<S394>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_e.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_e.size[1] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_e.data[0] = 1.0;

    // '<S394>:1:11' v = 0;
    Lifting_wing_HIL_model_dll_DW.v_j.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.v_j.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S382>/failture_magl_km_cm'
    // '<S399>:1:6' mag_init = 0;
    // '<S399>:1:7' mag_km_limit = 0;
    Lifting_wing_HIL_model_dll_DW.mag_km_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_km_limit.data[0] = 0.0;

    // '<S399>:1:8' mag_km_cm_en = 0;
    // '<S399>:1:9' mag_cm_limit = 0;
    Lifting_wing_HIL_model_dll_DW.mag_cm_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_cm_limit.data[0] = 0.0;

    // '<S399>:1:10' mag_km = ones(3, 1);
    // '<S399>:1:11' mag_cm = zeros(3, 1);
    Lifting_wing_HIL_model_dll_DW.mag_km[0] = 1.0;
    Lifting_wing_HIL_model_dll_DW.mag_km[1] = 1.0;
    Lifting_wing_HIL_model_dll_DW.mag_km[2] = 1.0;

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_nm_var'
    // '<S398>:1:5' mag_nm_var_init = 0;
    // '<S398>:1:6' mag_nm_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_T.data[0] = 0.0;

    // '<S398>:1:7' mag_nm_var_dt = 0;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_dt.data[0] = 0.0;

    // '<S398>:1:8' mag_nm_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nm_var_am.data[0] = 1.0;

    // '<S398>:1:9' mag_nm_var_en = 0;
    // '<S398>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init.size[1] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init.data[0] = 1.0;

    // '<S398>:1:11' v = 0;
    Lifting_wing_HIL_model_dll_DW.v.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.v.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_nbm_var'
    // '<S397>:1:5' mag_nbm_var_init = 0;
    // '<S397>:1:6' mag_nbm_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_T.data[0] = 0.0;

    // '<S397>:1:7' mag_nbm_var_dt = 0;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_dt.data[0] = 0.0;

    // '<S397>:1:8' mag_nbm_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_nbm_var_am.data[0] = 1.0;

    // '<S397>:1:9' mag_nbm_var_en = 0;
    // '<S397>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_k.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_k.size[1] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_k.data[0] = 1.0;

    // '<S397>:1:11' v = 0;
    Lifting_wing_HIL_model_dll_DW.v_b.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.v_b.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S379>/failture_baro_nb_var'
    // '<S378>:1:6' GPS_multipath_effect_en_ = 0;
    // '<S378>:1:7' motor_stop_en_ = 0;
    // '<S378>:1:8' battery_short_en_ = 0;
    // '<S378>:1:9' GPS_search_failed_en_ = 0;
    // '<S378>:1:10' GPS_communication_interrupted_en_ = 0;
    // '<S378>:1:11' IMU_communication_interrupted_en_ = 0;
    // '<S386>:1:5' baro_nb_var_init = 0;
    // '<S386>:1:6' baro_nb_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.baro_nb_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nb_var_T.data[0] = 0.0;

    // '<S386>:1:7' baro_nb_var_dt = 0;
    // '<S386>:1:8' baro_nb_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nb_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nb_var_am.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S379>/failture_baro_nbb_var'
    // '<S386>:1:9' baro_nb_var_en = 0;
    // '<S386>:1:10' x_init = 1;
    // '<S386>:1:11' v = 0;
    // '<S387>:1:5' baro_nbb_var_init = 0;
    // '<S387>:1:6' baro_nbb_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nbb_var_T.data[0] = 0.0;

    // '<S387>:1:7' baro_nbb_var_dt = 0;
    // '<S387>:1:8' baro_nbb_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.baro_nbb_var_am.data[0] = 1.0;

    // '<S387>:1:9' baro_nbb_var_en = 0;
    // '<S387>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_hs.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_hs.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_ka_ca'
    // '<S387>:1:11' v = 0;
    // '<S388>:1:6' accel_init = 0;
    // '<S388>:1:7' accel_kg_limit = 0;
    Lifting_wing_HIL_model_dll_DW.accel_kg_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_kg_limit.data[0] = 0.0;

    // '<S388>:1:8' accel_kg_cg_en = 0;
    // '<S388>:1:9' accel_cg_limit = 0;
    Lifting_wing_HIL_model_dll_DW.accel_cg_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_cg_limit.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_kap'
    // '<S388>:1:10' accel_kg = ones(3, 1);
    // '<S388>:1:11' accel_cg = zeros(3, 1);
    // '<S389>:1:5' accel_kgp_init = 0;
    // '<S389>:1:6' accel_kgp_T = 0;
    Lifting_wing_HIL_model_dll_DW.accel_kgp_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_kgp_T.data[0] = 0.0;

    // '<S389>:1:7' accel_kgp_dt = 0;
    // '<S389>:1:8' accel_kgp_am = 1;
    Lifting_wing_HIL_model_dll_DW.accel_kgp_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_kgp_am.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_na_var'
    // '<S389>:1:9' accel_kgp_en = 0;
    // '<S389>:1:10' x_init = 1;
    // '<S389>:1:11' v = 0;
    // '<S390>:1:5' accel_na_var_init = 0;
    // '<S390>:1:6' accel_na_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.accel_na_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_na_var_T.data[0] = 0.0;

    // '<S390>:1:7' accel_na_var_dt = 0;
    // '<S390>:1:8' accel_na_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.accel_na_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_na_var_am.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_nba_var'
    // '<S390>:1:9' accel_na_var_en = 0;
    // '<S390>:1:10' x_init = 1;
    // '<S390>:1:11' v = 0;
    // '<S391>:1:5' accel_nbg_var_init = 0;
    // '<S391>:1:6' accel_nbg_var_T = 0;
    Lifting_wing_HIL_model_dll_DW.accel_nbg_var_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_nbg_var_T.data[0] = 0.0;

    // '<S391>:1:7' accel_nbg_var_dt = 0;
    // '<S391>:1:8' accel_nbg_var_am = 1;
    Lifting_wing_HIL_model_dll_DW.accel_nbg_var_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.accel_nbg_var_am.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_dm'
    // '<S391>:1:9' accel_nbg_var_en = 0;
    // '<S391>:1:10' x_init = 1;
    // '<S391>:1:11' v = 0;
    // '<S396>:1:5' mag_dm_init = 0;
    // '<S396>:1:6' mag_dm_T = 0;
    Lifting_wing_HIL_model_dll_DW.mag_dm_T.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_dm_T.data[0] = 0.0;

    // '<S396>:1:7' mag_dm_dt = 0;
    // '<S396>:1:8' mag_dm_am = 1;
    Lifting_wing_HIL_model_dll_DW.mag_dm_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.mag_dm_am.data[0] = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor1'
    // '<S396>:1:9' mag_dm_en = 0;
    // '<S396>:1:10' x_init = 1;
    // '<S396>:1:11' v = 0;
    // '<S400>:1:6' motor_init = 0;
    // '<S400>:1:7' motor_speed_T = 0;
    // '<S400>:1:8' motor_speed_dt = 0;
    // '<S400>:1:9' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_f.data[0] = 1.0;

    // '<S400>:1:10' motor_speed_en = 0;
    // '<S400>:1:11' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_pc = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor2'
    // '<S400>:1:12' v = 0;
    // '<S401>:1:5' motor_init = 0;
    // '<S401>:1:6' motor_speed_T = 0;
    // '<S401>:1:7' motor_speed_dt = 0;
    // '<S401>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_id.data[0] = 1.0;

    // '<S401>:1:9' motor_speed_en = 0;
    // '<S401>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_lu = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor3'
    // '<S401>:1:11' v = 0;
    // '<S402>:1:5' motor_init = 0;
    // '<S402>:1:6' motor_speed_T = 0;
    // '<S402>:1:7' motor_speed_dt = 0;
    // '<S402>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_a.data[0] = 1.0;

    // '<S402>:1:9' motor_speed_en = 0;
    // '<S402>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_pt = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor4'
    // '<S402>:1:11' v = 0;
    // '<S403>:1:5' motor_init = 0;
    // '<S403>:1:6' motor_speed_T = 0;
    // '<S403>:1:7' motor_speed_dt = 0;
    // '<S403>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_e.data[0] = 1.0;

    // '<S403>:1:9' motor_speed_en = 0;
    // '<S403>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_bz = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor5'
    // '<S403>:1:11' v = 0;
    // '<S404>:1:5' motor_init = 0;
    // '<S404>:1:6' motor_speed_T = 0;
    // '<S404>:1:7' motor_speed_dt = 0;
    // '<S404>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_h.data[0] = 1.0;

    // '<S404>:1:9' motor_speed_en = 0;
    // '<S404>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_pa = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor6'
    // '<S404>:1:11' v = 0;
    // '<S405>:1:5' motor_init = 0;
    // '<S405>:1:6' motor_speed_T = 0;
    // '<S405>:1:7' motor_speed_dt = 0;
    // '<S405>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_m.data[0] = 1.0;

    // '<S405>:1:9' motor_speed_en = 0;
    // '<S405>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_m = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor7'
    // '<S405>:1:11' v = 0;
    // '<S406>:1:5' motor_init = 0;
    // '<S406>:1:6' motor_speed_T = 0;
    // '<S406>:1:7' motor_speed_dt = 0;
    // '<S406>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am_i.data[0] = 1.0;

    // '<S406>:1:9' motor_speed_en = 0;
    // '<S406>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_l = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor8'
    // '<S406>:1:11' v = 0;
    // '<S407>:1:5' motor_init = 0;
    // '<S407>:1:6' motor_speed_T = 0;
    // '<S407>:1:7' motor_speed_dt = 0;
    // '<S407>:1:8' motor_speed_am = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_speed_am.data[0] = 1.0;

    // '<S407>:1:9' motor_speed_en = 0;
    // '<S407>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_bp = 1.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc1'
    // '<S407>:1:11' v = 0;
    // '<S408>:1:6' motor_init = 0;
    // '<S408>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_iq.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_iq.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc2'
    // '<S408>:1:8' motor_ktc_en = 0;
    // '<S408>:1:9' motor_ktc = ones(3, 1);
    // '<S409>:1:6' motor_init = 0;
    // '<S409>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_mf.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_mf.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc3'
    // '<S409>:1:8' motor_ktc_en = 0;
    // '<S409>:1:9' motor_ktc = ones(3, 1);
    // '<S410>:1:6' motor_init = 0;
    // '<S410>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_p.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_p.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc4'
    // '<S410>:1:8' motor_ktc_en = 0;
    // '<S410>:1:9' motor_ktc = ones(3, 1);
    // '<S411>:1:6' motor_init = 0;
    // '<S411>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_a.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_a.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc5'
    // '<S411>:1:8' motor_ktc_en = 0;
    // '<S411>:1:9' motor_ktc = ones(3, 1);
    // '<S412>:1:6' motor_init = 0;
    // '<S412>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_i.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_i.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc6'
    // '<S412>:1:8' motor_ktc_en = 0;
    // '<S412>:1:9' motor_ktc = ones(3, 1);
    // '<S413>:1:6' motor_init = 0;
    // '<S413>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_o.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_o.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc7'
    // '<S413>:1:8' motor_ktc_en = 0;
    // '<S413>:1:9' motor_ktc = ones(3, 1);
    // '<S414>:1:6' motor_init = 0;
    // '<S414>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_m.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit_m.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc8'
    // '<S414>:1:8' motor_ktc_en = 0;
    // '<S414>:1:9' motor_ktc = ones(3, 1);
    // '<S415>:1:6' motor_init = 0;
    // '<S415>:1:7' motor_ktc_limit = 0;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.motor_ktc_limit.data[0] = 0.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller1'
    // '<S415>:1:8' motor_ktc_en = 0;
    // '<S415>:1:9' motor_ktc = ones(3, 1);
    // '<S416>:1:5' propeller_init = 0;
    // '<S416>:1:6' propeller_kct_T = 0;
    // '<S416>:1:7' propeller_kct_dt = 0;
    // '<S416>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_c.data[0] = 1.0;

    // '<S416>:1:9' propeller_kct_en = 0;
    // '<S416>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_a = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller2'
    // '<S416>:1:11' v = 0;
    // '<S417>:1:5' propeller_init = 0;
    // '<S417>:1:6' propeller_kct_T = 0;
    // '<S417>:1:7' propeller_kct_dt = 0;
    // '<S417>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_m.data[0] = 1.0;

    // '<S417>:1:9' propeller_kct_en = 0;
    // '<S417>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_b = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller3'
    // '<S417>:1:11' v = 0;
    // '<S418>:1:5' propeller_init = 0;
    // '<S418>:1:6' propeller_kct_T = 0;
    // '<S418>:1:7' propeller_kct_dt = 0;
    // '<S418>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_k.data[0] = 1.0;

    // '<S418>:1:9' propeller_kct_en = 0;
    // '<S418>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_ee = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller4'
    // '<S418>:1:11' v = 0;
    // '<S419>:1:5' propeller_init = 0;
    // '<S419>:1:6' propeller_kct_T = 0;
    // '<S419>:1:7' propeller_kct_dt = 0;
    // '<S419>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_j.data[0] = 1.0;

    // '<S419>:1:9' propeller_kct_en = 0;
    // '<S419>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_cr = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller5'
    // '<S419>:1:11' v = 0;
    // '<S420>:1:5' propeller_init = 0;
    // '<S420>:1:6' propeller_kct_T = 0;
    // '<S420>:1:7' propeller_kct_dt = 0;
    // '<S420>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_i.data[0] = 1.0;

    // '<S420>:1:9' propeller_kct_en = 0;
    // '<S420>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_oi = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller6'
    // '<S420>:1:11' v = 0;
    // '<S421>:1:5' propeller_init = 0;
    // '<S421>:1:6' propeller_kct_T = 0;
    // '<S421>:1:7' propeller_kct_dt = 0;
    // '<S421>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_e.data[0] = 1.0;

    // '<S421>:1:9' propeller_kct_en = 0;
    // '<S421>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_i1 = 1.0;

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller7'
    // '<S421>:1:11' v = 0;
    // '<S422>:1:5' propeller_init = 0;
    // '<S422>:1:6' propeller_kct_T = 0;
    // '<S422>:1:7' propeller_kct_dt = 0;
    // '<S422>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am_a.data[0] = 1.0;

    // '<S422>:1:9' propeller_kct_en = 0;
    // '<S422>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_o = 1.0;

    // SystemInitialize for MATLAB Function: '<Root>/CollisionDetection'
    // '<S422>:1:11' v = 0;
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_bm[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_ng_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_nk[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_kgp'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_bu[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_kg_cg'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_c0[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S381>/failture_gyro_nbg_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_ke[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S382>/failture_magl_km_cm'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_kv[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_nm_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_m2[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_nbm_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_c[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S379>/failture_baro_nb_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_e3[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S379>/failture_baro_nbb_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_k4[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_ka_ca'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_nk2[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_kap'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_a[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_na_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_i5[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S380>/failture_accel_nba_var'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_oa[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S382>/failture_mag_dm'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_e5[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor1'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_no[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor2'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_lo[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor3'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_o[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor4'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_b[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor5'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_p[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor6'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_dy[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor7'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_gz[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor8'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_dmq[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc1'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_n5[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc2'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_g[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc3'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_m[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc4'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_i[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc5'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_el[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc6'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_f[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc7'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_ns[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S383>/failture_motor_ktc8'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_e[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller1'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_n[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller2'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_dm[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller3'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_kf[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller4'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_l[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller5'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_k[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller6'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_j[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller7'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state_d[0], &tmp[0], 625U *
                sizeof(uint32_T));

    // SystemInitialize for MATLAB Function: '<S384>/failture_propeller8'
    std::memcpy(&Lifting_wing_HIL_model_dll_DW.state[0], &tmp[0], 625U * sizeof
                (uint32_T));

    // '<S423>:1:5' propeller_init = 0;
    // '<S423>:1:6' propeller_kct_T = 0;
    // '<S423>:1:7' propeller_kct_dt = 0;
    // '<S423>:1:8' propeller_kct_am = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am.size[0] = 1;
    Lifting_wing_HIL_model_dll_DW.propeller_kct_am.data[0] = 1.0;

    // '<S423>:1:9' propeller_kct_en = 0;
    // '<S423>:1:10' x_init = 1;
    Lifting_wing_HIL_model_dll_DW.x_init_c = 1.0;

    // '<S423>:1:11' v = 0;
  }

  // set "at time zero" to false
  if ((&Lifting_wing_HIL_model_dll_M)->isFirstInitCond()) {
    (&Lifting_wing_HIL_model_dll_M)->setFirstInitCond(0);
  }
}

// Model terminate function
void MulticopterModelClass::terminate()
{
  // (no terminate code required)
}

boolean_T MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  getStopRequested() const
{
  return (Timing.stopRequestedFlag);
}

void MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::setStopRequested
  (boolean_T aStopRequested)
{
  (Timing.stopRequestedFlag = aStopRequested);
}

void MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::setFirstInitCond
  (boolean_T aFirstInitCond)
{
  (Timing.firstInitCondFlag = aFirstInitCond);
}

boolean_T MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  isFirstInitCond() const
{
  return (Timing.firstInitCondFlag);
}

const char_T* MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  getErrorStatus() const
{
  return (errorStatus);
}

void MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::setErrorStatus(
  const char_T* const aErrorStatus)
{
  (errorStatus = aErrorStatus);
}

time_T* MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::getTPtr() const
{
  return (Timing.t);
}

void MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::setTPtr(time_T
  * aTPtr)
{
  (Timing.t = aTPtr);
}

boolean_T* MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  getStopRequestedPtr()
{
  return (&(Timing.stopRequestedFlag));
}

const char_T** MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  getErrorStatusPtr()
{
  return &errorStatus;
}

boolean_T MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  isMajorTimeStep() const
{
  return ((Timing.simTimeStep) == MAJOR_TIME_STEP);
}

boolean_T MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::
  isMinorTimeStep() const
{
  return ((Timing.simTimeStep) == MINOR_TIME_STEP);
}

time_T** MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::getTPtrPtr()
{
  return &(Timing.t);
}

time_T MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T::getTStart() const
{
  return (Timing.tStart);
}

// Constructor
MulticopterModelClass::MulticopterModelClass() :
  Lifting_wing_HIL_model_dll_U(),
  Lifting_wing_HIL_model_dll_Y(),
  Lifting_wing_HIL_model_dll_B(),
  Lifting_wing_HIL_model_dll_DW(),
  Lifting_wing_HIL_model_dll_X(),
  Lifting_wing_HIL_model_dll_XDis(),
  Lifting_wing_HIL_model_dll_M()
{
  // Currently there is no constructor body generated.
}

// Destructor
// Currently there is no destructor body generated.
MulticopterModelClass::~MulticopterModelClass() = default;

// Real-Time Model get method
MulticopterModelClass::RT_MODEL_Lifting_wing_HIL_mod_T * MulticopterModelClass::
  getRTM()
{
  return (&Lifting_wing_HIL_model_dll_M);
}

//
// File trailer for generated code.
//
// [EOF]
//
